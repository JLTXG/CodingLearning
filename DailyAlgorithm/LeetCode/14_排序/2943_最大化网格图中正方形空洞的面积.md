[2943. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/description/?envType=daily-question&envId=2026-01-15)

>标签：数组  |  排序

# 一、题目描述

给你两个整数 `n` 和 `m`，以及两个整数数组 `hBars` 和 `vBars`。网格由 `n + 2` 条水平线和 `m + 2` 条竖直线组成，形成 1x1 的单元格。网格中的线条从 `1` 开始编号。

你可以从 `hBars` 中 **删除** 一些水平线条，并从 `vBars` 中删除一些竖直线条。注意，其他线条是固定的，无法删除。

返回一个整数表示移除一些线条（可以不移除任何线条）后，网格中 **正方形空洞的最大面积** 。

 

**示例 1：**

![img](E:\NoteTakingSoftwares\Typora\Images\screenshot-from-2023-11-05-22-40-25.png)

**输入:** n = 2, m = 1, hBars = [2,3], vBars = [2]

**输出:** 4

**解释:**

左侧图片展示了网格的初始状态。水平线是 `[1,2,3,4]`，竖直线是 `[1,2,3]`。

构造最大正方形空洞的一种方法是移除水平线 2 和竖直线 2。

**示例 2：**

![img](E:\NoteTakingSoftwares\Typora\Images\screenshot-from-2023-11-04-17-01-02.png)

**输入:** n = 1, m = 1, hBars = [2], vBars = [2]

**输出:** 4

**解释:**

移除水平线 2 和竖直线 2，可以得到最大正方形空洞。

**示例 3：**

![img](E:\NoteTakingSoftwares\Typora\Images\unsaved-image-2.png)

**输入:** n = 2, m = 3, hBars = [2,3], vBars = [2,4]

**输出:** 4

**解释:**

构造最大正方形空洞的一种方法是移除水平线 3 和竖直线 4。

 

**提示：**

- `1 <= n <= 109`
- `1 <= m <= 109`
- `1 <= hBars.length <= 100`
- `2 <= hBars[i] <= n + 1`
- `1 <= vBars.length <= 100`
- `2 <= vBars[i] <= m + 1`
- `hBars` 中所有值互不相同。
- `vBars` 中所有值互不相同。



# 二、解题思路

这道题是一道中等难度的题目，需要换一种思路去思考题目，想一想，如果我把网格图中能删除的所有线段都删除了，那是不是意味着这个时候的矩形面积是不是最大的，而题目要求的是正方形最大的面积，那我们就取长和宽中较小的那个值，将其进行平方，即可得到最终的答案！

我们来分析一个案例，以题目给的`hBars`数组为例，我们先将数组`hBars`数组进行排序，假设`hBars`数组中所有的值都是连续的，那么如下：
- 不删除任何线条，长度为1
- 删除一条数值连续的线条，长度为2
- 删除两条数值连续的线条，长度为3
- 删除三条数值连续的线条，长度为4
- ......
- 以此类推

所以，根据上述案例分析，我们可以得知，题目其实就是变相的让我们求给的两个数组中连续数组值的长度是多少，然后我们在取其中较小的那个值，然后进行平方，即是最终的答案！



# 三、代码演示

## Java代码

```java
class Solution {
    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {
        int side = Math.min(result(hBars), result(vBars)) + 1;
        return side * side;
    }

    private int result(int[] arr) {
        // 需要将数组进行排序，这样后续才好判断是否存在连续的数组值
        Arrays.sort(arr);
        int flag = 1, count = 1;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1] + 1) {
                // 如果上述判断中的条件相等，就说明这两个相邻的数组值是连续的，然后记录数count加1，然后在更新最终的flag值
                count++;
                flag = flag > count ? flag : count;
            } else {
                // 如果上述判断中的条件不相等，说明这两个相邻的数组值不是连续的，就需要将记录数count重置为1
                count = 1;
            }
        }
        return flag;
    }
}
```



## Python代码

```Python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        side = min(self.result(hBars), self.result(vBars)) + 1
        return side * side
        
    def result(self, arr: List[int]) -> int:
        arr.sort()
        flag, count = 1, 1
        for i in range(1, len(arr)):
            if arr[i] == arr[i - 1] + 1 :
                count += 1
                flag = flag if flag > count else count
            else :
                count = 1
        return flag
```



## C++代码

```C++
class Solution {
public:
    int maximizeSquareHoleArea(int n, int m, vector<int>& hBars, vector<int>& vBars) {
        int side = min(result(hBars), result(vBars)) + 1;
        return side * side;
    }

private:
    int result(vector<int>& arr) {
        // 需要将数组进行排序，这样后续才好判断是否存在连续的数组值
        sort(arr.begin(), arr.end());
        int flag = 1, count = 1;
        for (int i = 1; i < arr.size(); i++) {
            if (arr[i] == arr[i - 1] + 1) {
                // 如果上述判断中的条件相等，就说明这两个相邻的数组值是连续的，然后记录数count加1，然后在更新最终的flag值
                count++;
                flag = flag > count ? flag : count;
            } else {
                // 如果上述判断中的条件不相等，说明这两个相邻的数组值不是连续的，就需要将记录数count重置为1
                count = 1;
            }
        }
        return flag;
    }
};
```

![2943_最大化网格图中正方形空洞的面积_C++]()