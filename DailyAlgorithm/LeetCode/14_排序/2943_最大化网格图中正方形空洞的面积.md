本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[2943. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/description/?envType=daily-question&envId=2026-01-15)

>标签：数组  |  排序

# 一、题目描述

## **问题概括**

给定一个由 `n+2` 条水平线和 `m+2` 条竖直线组成的网格，水平线编号为 `1` 到 `n+2`，竖直线编号为 `1` 到 `m+2`。其中一部分线条是可选的：水平线集合 `hBars` 和竖直线集合 `vBars` 中的线条可以被删除，其他线条（包括边界线）固定不可删除。

你可以选择删除 `hBars` 中的任意条水平线和 `vBars` 中的任意条竖直线。删除后，网格中会形成若干连续的矩形区域。你的目标是使得这些区域中 **最大的正方形** 的面积尽可能大，并返回该最大面积。

## **示例说明**

- **示例1**：初始网格有4条水平线（1,2,3,4）和3条竖直线（1,2,3）。删除水平线2、3和竖直线2后，形成一个边长为2的正方形，面积为4。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/14_%E6%8E%92%E5%BA%8F/Images/2943_%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%A9%BA%E6%B4%9E%E7%9A%84%E9%9D%A2%E7%A7%AF_%E7%A4%BA%E4%BE%8B1.png)

- **示例2**：删除唯一的可选水平线2和竖直线2，得到边长为2的正方形，面积4。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/14_%E6%8E%92%E5%BA%8F/Images/2943_%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%A9%BA%E6%B4%9E%E7%9A%84%E9%9D%A2%E7%A7%AF_%E7%A4%BA%E4%BE%8B2.png)

- **示例3**：删除水平线3和竖直线4，得到边长为2的正方形，面积4。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/14_%E6%8E%92%E5%BA%8F/Images/2943_%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%A9%BA%E6%B4%9E%E7%9A%84%E9%9D%A2%E7%A7%AF_%E7%A4%BA%E4%BE%8B3.png)

## **数据范围**

- `1 ≤ n, m ≤ 10^9`
- `1 ≤ hBars.length, vBars.length ≤ 100`
- `hBars` 和 `vBars` 中的元素互不相同，且取值在 `[2, n+1]` 或 `[2, m+1]` 之间。



# 二、解题思路

这道题是一道中等难度的题目，需要换一种思路去思考题目，想一想，如果我把网格图中能删除的所有线段都删除了，那是不是意味着这个时候的矩形面积是不是最大的，而题目要求的是正方形最大的面积，那我们就取长和宽中较小的那个值，将其进行平方，即可得到最终的答案！

我们来分析一个案例，以题目给的`hBars`数组为例，我们先将数组`hBars`数组进行排序，假设`hBars`数组中所有的值都是连续的，那么如下：
- 不删除任何线条，长度为1
- 删除一条数值连续的线条，长度为2
- 删除两条数值连续的线条，长度为3
- 删除三条数值连续的线条，长度为4
- ......
- 以此类推

所以，根据上述案例分析，我们可以得知，题目其实就是变相的让我们求给的两个数组中连续数组值的长度是多少，然后我们在取其中较小的那个值，然后进行平方，即是最终的答案！



# 三、代码演示

## Java代码

```java
class Solution {
    public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) {
        int side = Math.min(result(hBars), result(vBars)) + 1;
        return side * side;
    }

    private int result(int[] arr) {
        // 需要将数组进行排序，这样后续才好判断是否存在连续的数组值
        Arrays.sort(arr);
        int flag = 1, count = 1;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1] + 1) {
                // 如果上述判断中的条件相等，就说明这两个相邻的数组值是连续的，然后记录数count加1，然后在更新最终的flag值
                count++;
                flag = flag > count ? flag : count;
            } else {
                // 如果上述判断中的条件不相等，说明这两个相邻的数组值不是连续的，就需要将记录数count重置为1
                count = 1;
            }
        }
        return flag;
    }
}
```



## Python代码

```Python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        side = min(self.result(hBars), self.result(vBars)) + 1
        return side * side
        
    def result(self, arr: List[int]) -> int:
        arr.sort()
        flag, count = 1, 1
        for i in range(1, len(arr)):
            if arr[i] == arr[i - 1] + 1 :
                count += 1
                flag = flag if flag > count else count
            else :
                count = 1
        return flag
```



## C++代码

```C++
class Solution {
public:
    int maximizeSquareHoleArea(int n, int m, vector<int>& hBars, vector<int>& vBars) {
        int side = min(result(hBars), result(vBars)) + 1;
        return side * side;
    }

private:
    int result(vector<int>& arr) {
        // 需要将数组进行排序，这样后续才好判断是否存在连续的数组值
        sort(arr.begin(), arr.end());
        int flag = 1, count = 1;
        for (int i = 1; i < arr.size(); i++) {
            if (arr[i] == arr[i - 1] + 1) {
                // 如果上述判断中的条件相等，就说明这两个相邻的数组值是连续的，然后记录数count加1，然后在更新最终的flag值
                count++;
                flag = flag > count ? flag : count;
            } else {
                // 如果上述判断中的条件不相等，说明这两个相邻的数组值不是连续的，就需要将记录数count重置为1
                count = 1;
            }
        }
        return flag;
    }
};
```

![2943_最大化网格图中正方形空洞的面积_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/14_%E6%8E%92%E5%BA%8F/Images/2943_%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%A9%BA%E6%B4%9E%E7%9A%84%E9%9D%A2%E7%A7%AF_C++.png)