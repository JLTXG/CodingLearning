本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3010. 将数组分成最小总代价的子数组 I - 力扣（LeetCode）](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/?envType=daily-question&envId=2026-02-01)

>标签：数组  |  枚举  |  排序

# 一、题目描述

## **问题概括**

给定一个长度为 `n` 的整数数组 `nums`。定义数组的**代价**为其第一个元素的值。你需要将 `nums` 分割成三个**连续且互不重叠**的非空子数组，即选择两个分割点将数组分为三部分。请计算这三个子数组的代价之和，并返回可能的最小总和。

## **示例说明**

- **示例1**：`nums = [1,2,3,12]`，最优分割为 `[1]`、`[2]`、`[3,12]`，代价分别为 1、2、3，总和为 6。
- **示例2**：`nums = [5,4,3]`，唯一分割方式为 `[5]`、`[4]`、`[3]`，总和为 12。
- **示例3**：`nums = [10,3,1,1]`，最优分割为 `[10,3]`、`[1]`、`[1]`，代价分别为 10、1、1，总和为 12。

## **数据范围**

- `3 <= n <= 50`
- `1 <= nums[i] <= 50`



# 二、解题思路\解题过程

这是今天的每日一题，题目要求将数组分成三个部分，然后将每个部分的最小值加起来，然后返回即可！需要注意的是，数组的第一个值——`nums[0]`——是必须加上的——因为第一段的第一个数是确定的，所以，接下来就是从数组剩下的值——`[1, nums.length - 1]`——中选择两个最小的值即可，所以，接下来我们可以对剩下的数组值——`[1, nums.length - 1]`——进行排序，然后选最小的两个值，然后在将这三个值相加即可得到答案！

当然，我们也可以手动更新除第一段第一个数之外的两个值——“最小值”和“次小值”——`mini`，`sec`！我们可以循环`[1, nums.length - 1]`的数组值，如果当前的值——`tmp`——小于`mini`，我们可以将当前的`mini`的值赋给`sec`，然后再把`tmp`赋给`mini`，使当前的最小`tmp`覆盖`mini`，使原来的`mini`成为次小`sec`；如果`tmp`小于`sec`，那我们就把当前的`tmp`赋给次小`sec`，最后循环完了之后，将`nums[0]`、`mini`、`sec`这三个数相加返回即可！

# 三、代码演示

## Java代码

```Java
// 排序
class Solution {
    public int minimumCost(int[] nums) {
        Arrays.sort(nums, 1, nums.length);
        return nums[0] + nums[1] + nums[2];
    }
}

// 手动更新
class Solution {
    public int minimumCost(int[] nums) {
        int mini = Integer.MAX_VALUE, sec = Integer.MAX_VALUE;
        for (int i = 1; i < nums.length; i++) {
            int tmp = nums[i];
            if (tmp < mini) {
                sec = mini;
                mini = tmp;
            } else if (tmp < sec) {
                sec = tmp;
            }
        }
        return nums[0] + mini + sec;
    }
}
```



## Python代码

```Python
# 排序
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        num_sort = sorted(nums[1:])
        return nums[0] + num_sort[0] + num_sort[1]

# 手动更新
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        mini, sec = inf, inf
        for i in range(1, len(nums)):
            tmp = nums[i]
            if tmp < mini:
                sec, mini = mini, tmp
            elif tmp < sec:
                sec = tmp
        return nums[0] + mini + sec
```



## C++代码

```C++
// 排序
class Solution {
public:
    int minimumCost(vector<int>& nums) {
        sort(nums.begin() + 1, nums.end());
        return nums[0] + nums[1] + nums[2];
    }
};

// 手动更新
class Solution {
public:
    int minimumCost(vector<int>& nums) {
        int mini = INT_MAX, sec = INT_MAX;
        for (int i = 1; i < nums.size(); i++) {
            int tmp = nums[i];
            if (tmp < mini) {
                sec = mini;
                mini = tmp;
            } else if (tmp < sec) {
                sec = tmp;
            }
        }
        return nums[0] + mini + sec;
    }
};
```

![3010_将数组分成最小总代价的子数组 I_C++]()