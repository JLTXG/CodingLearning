[1351. 统计有序矩阵中的负数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/?envType=daily-question&envId=2025-12-27)

>标签：数组  |  二分查找  |  矩阵

# 一、题目描述

给你一个 `m * n` 的矩阵 `grid`，矩阵中的元素无论是按行还是按列，都以非严格递减顺序排列。 请你统计并返回 `grid` 中 **负数** 的数目。

 

**示例 1：**

```
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
```

**示例 2：**

```
输入：grid = [[3,2],[1,0]]
输出：0
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 100`
- `-100 <= grid[i][j] <= 100`

 

**进阶：**你可以设计一个时间复杂度为 `O(n + m)` 的解决方案吗？



# 二、解题思路\解题过程

今天是一道简单的题目，就是给定一个二维数组，去里面找有多少个负数，然后返回最终的负数个数，挺简单的今天的题目，不知道是不是因为昨天来了一道困难题，今天就出了一道简单题，不过，虽然一遍就过了，但是，第一次提交的Java代码的“执行用时”和“消耗内存”都不是很理想，代码如下：
```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] < 0){
                    flag++;
                }
            }
        }
        return flag;
    }
}
```
后面我想着，既然每一行都是非递增的，那么，我直接在循环每一行的时候，直接倒序遍历，这样遇到大于等于0的，那么就说明前面的就没有必要遍历了，直接跳出里面的这一行循环，直接进行下一行的循环，然后我提交了代码，发现虽然“执行时间”和“消耗内存”都有所优化，但是，优化不大，然后我去看了题解，可以采用“二分查找”的方法，我修改了代码，如下：
```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            //  需要排除正行都是非负数的情况
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
}
```
很明显，在使用了“二分查找”的思想之后，整个代码的“执行用时”已经击败了100%的用户，但是“消耗内存”还是没什么提升！然后，我用了Python来提交代码，同样采用的是“二分查找”的思想，然后一提交，发现“执行用时”击败100%的用户，“消耗内存”击败了96.83%。

同样，我采用了C++写了一遍题目，“执行用时”一样，但是，我发现C++的“消耗内存”竟然比Java的要好很多。



# 三、代码演示

## Java代码

```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            //  需要排除正行都是非负数的情况
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
}
```

![1351_统计有序矩阵中的负数_力扣_Java](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_Java.png?raw=true)

## Python代码

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        flag, m, n = 0, len(grid), len(grid[0])
        for i in range(m):
            l, r = 0, n - 1
            while l < r :
                mid = (l + r) // 2
                if grid[i][mid] < 0 :
                    r = mid
                else :
                    l = mid + 1
            if grid[i][r] < 0 :
                flag += n - r
        return flag
```

![1351_统计有序矩阵中的负数_力扣_Python](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_Python.png?raw=true)

## C++代码

```C++
class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int flag = 0, m = size(grid), n = size(grid[0]);
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
};
```

![1351_统计有序矩阵中的负数_力扣_C++](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_C++.png?raw=true)
