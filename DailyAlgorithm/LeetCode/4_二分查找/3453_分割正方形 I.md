[3453. 分割正方形 I - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13)

>标签：数组  |  二分查找

# 一、题目描述

给你一个二维整数数组 `squares` ，其中 `squares[i] = [xi, yi, li]` 表示一个与 x 轴平行的正方形的左下角坐标和正方形的边长。

找到一个**最小的** y 坐标，它对应一条水平线，该线需要满足它以上正方形的总面积 **等于** 该线以下正方形的总面积。

答案如果与实际答案的误差在 `10-5` 以内，将视为正确答案。

**注意**：正方形 **可能会** 重叠。重叠区域应该被 **多次计数** 。

 

**示例 1：**

**输入：** squares = [[0,0,1],[2,2,1]]

**输出：** 1.00000

**解释：**

![img](E:\NoteTakingSoftwares\Typora\Images\1739609465-UaFzhk-4062example1drawio.png)

任何在 `y = 1` 和 `y = 2` 之间的水平线都会有 1 平方单位的面积在其上方，1 平方单位的面积在其下方。最小的 y 坐标是 1。

**示例 2：**

**输入：** squares = [[0,0,2],[1,1,1]]

**输出：** 1.16667

**解释：**

![img](E:\NoteTakingSoftwares\Typora\Images\1739609527-TWqefZ-4062example2drawio.png)

面积如下：

- 线下的面积：`7/6 * 2 (红色) + 1/6 (蓝色) = 15/6 = 2.5`。
- 线上的面积：`5/6 * 2 (红色) + 5/6 (蓝色) = 15/6 = 2.5`。

由于线以上和线以下的面积相等，输出为 `7/6 = 1.16667`。

 

**提示：**

- `1 <= squares.length <= 5 * 104`
- `squares[i] = [xi, yi, li]`
- `squares[i].length == 3`
- `0 <= xi, yi <= 109`
- `1 <= li <= 109`
- 所有正方形的总面积不超过 `1012`。



# 二、解题思路\解题过程

这道题用二分的思想求解，具体详细的思路可以参考灵神的题解——[3453. 分割正方形 I - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-i/solutions/3076424/zheng-shu-er-fen-pythonjavacgo-by-endles-8yn5/?envType=daily-question&envId=2026-01-13)，我对这部分题解进行了手写+熟悉，具体如下图所示：

![3453_分割正方形 I_二分思路]()

代码如下：
```java
class Solution {
    public double separateSquares(int[][] squares) {
        long totArea = 0;
        int maxY = 0;
        for (int[] sq : squares) {
            int l = sq[2];
            // 计算所有正方形的总面积
            totArea += (long) l * l;
            // 所有正方形的最高 y 坐标（上边界）
            maxY = Math.max(maxY, sq[1] + l);
        }

        double left = 0;
        double right = maxY;
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半 → 可以尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半 → 需要更大的 y
                left = mid;
            }
        }
        // 区间中点误差更小
        return (left + right) / 2;
    }

    private boolean check(int[][] squares, double y, long totArea) {
        double area = 0;
        for (int[] sq : squares) {
            double yi = sq[1];
            // 只有底部在 y 以下的正方形才贡献面积
            if (yi < y) {
                double l = sq[2];
                // 计算该正方形在 y 以下的部分高度：
                // - 如果 y >= yi + l → 整个正方形在线下 → 高度 = l
                // - 否则 → 高度 = y - yi
                area += l * Math.min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public double separateSquares(int[][] squares) {
        long totArea = 0;
        int maxY = 0;
        for (int[] sq : squares) {
            int l = sq[2];
            // 计算所有正方形的总面积
            totArea += (long) l * l;
            // 所有正方形的最高 y 坐标（上边界）
            maxY = Math.max(maxY, sq[1] + l);
        }

        double left = 0;
        double right = maxY;
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半 → 可以尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半 → 需要更大的 y
                left = mid;
            }
        }
        // 区间中点误差更小
        return (left + right) / 2;
    }

    private boolean check(int[][] squares, double y, long totArea) {
        double area = 0;
        for (int[] sq : squares) {
            double yi = sq[1];
            // 只有底部在 y 以下的正方形才贡献面积
            if (yi < y) {
                double l = sq[2];
                // 计算该正方形在 y 以下的部分高度：
                // - 如果 y >= yi + l → 整个正方形在线下 → 高度 = l
                // - 否则 → 高度 = y - yi
                area += l * Math.min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
}
```



## Python代码

```Python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        tot_area = 0
        max_y = 0
        for x, y, l in squares:
            tot_area += l * l
            max_y = max(max_y, y + l)
        
        left = 0.0
        right = float(max_y)

        # 固定 47 次迭代，保证精度
        for _ in range(47):
            mid = (left + right) / 2.0
            if self._check(squares, mid, tot_area):
                # 线下面积 >= 一半，尝试更小的 y
                right = mid
            else:
                # 线下面积 < 一半，需要更大的 y
                left = mid
        
        return (left + right) / 2.0

    def _check(self, squares, y, tot_area):
        area = 0.0
        for x, yi, l in squares:
            if yi < y :
                # 正方形在 y 以下的部分高度：min(y - yi, l)
                area += l * min(y - yi, l)
        return area >= tot_area / 2.0
```



## C++代码

```C++
class Solution {
public:
    double separateSquares(vector<vector<int>>& squares) {
        long long totArea = 0;
        int maxY = 0;
        for (const auto& sq : squares) {
            int l = sq[2];
            // 防止溢出
            totArea += static_cast<long long>(l) * l;
            maxY = max(maxY, sq[1] + l);
        }

        double left = 0.0;
        double right = static_cast<double>(maxY);

        // 固定 47 次迭代，确保精度
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2.0;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半，尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半，需要更大的 y
                left = mid;
            }
        }
        return (left + right) / 2.0;
    }

private:
    bool check(const vector<vector<int>> & squares, double y, long long totArea) {
        double area = 0.0;
        for (const auto& sq : squares) {
            double yi = sq[1];
            if (yi < y) {
                double l = sq[2];
                // 计算正方形在 y 以下的部分高度
                area += l * min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
};
```

![3453_分割正方形 I_C++]()