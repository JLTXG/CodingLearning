本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/description/?envType=study-plan-v2&envId=primers-list)

>标签：位运算  |  递归  |  数学

# 一、题目描述

## **问题概括**

给定一个整数 `n`，判断它是否是 2 的幂次方。即是否存在整数 `x` 使得 `n == 2^x`。如果是，返回 `true`；否则，返回 `false`。

## **示例说明**

- **示例1**：`n = 1`，返回 `true`，因为 `2^0 = 1`。
- **示例2**：`n = 16`，返回 `true`，因为 `2^4 = 16`。
- **示例3**：`n = 3`，返回 `false`。

## **数据范围**

- `-2^31 <= n <= 2^31 - 1`

## **进阶挑战**

能否在不使用循环或递归的情况下解决此问题？



# 二、解题思路\解题过程

这也是一道简单的数学题目，这里提供两种解题思路：
## 第一种：模拟（暴力求解）

根据题意一步步模拟，只需要保证代码中更新的数据在不超过对应的数值范围即可，具体代码如下所示：
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
};
```
## 第二种：位运算

参考灵神的题解——[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/solutions/2973442/yan-ge-zheng-ming-yi-xing-xie-fa-pythonj-h04o/?envType=study-plan-v2&envId=primers-list)，知识合集——[分享｜从集合论到位运算，常见位运算技巧分类总结！ - 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)！

总得来说，灵神的位运算思路归结如下：
- 如果 `n>0`，可以用 `n&(n−1)=0` 判断。若成立，则 `n` 是 `2` 的幂；若不成立，则 `n` 不是 `2` 的幂。
- 如果 `n≤0`，`n` 不是 `2` 的幂。

> 注：n&(n−1) 相当于去掉 n 二进制的最低位，可以用这个技巧枚举 n 中的比特 1。

代码如下：
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
};
```



# 三、代码演示

## Java代码

```Java
// 模拟（暴力求解）
class Solution {
    public boolean isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
}

// 位运算
class Solution {
    public boolean isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
}
```



## Python代码

```Python
# 模拟（暴力求解）
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1 :
            return True
        flag = 1
        for i in range(1, 32):
            flag *= 2
            if flag == n :
                return True
            elif flag > n :
                return False
        return False
    
# 位运算
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
```



## C++代码

```C++
// 模拟（暴力求解）
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
};

// 位运算
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
};
```

![231_2 的幂_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E6%95%B0%E5%AD%A6/Images/231_2%20%E7%9A%84%E5%B9%82_C++.png)