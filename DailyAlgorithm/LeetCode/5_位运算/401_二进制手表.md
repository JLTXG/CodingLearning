本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[401. 二进制手表 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-watch/description/?envType=daily-question&envId=2026-02-17)

>标签：位运算  |  回溯

# 一、题目描述

## **问题概括**

二进制手表由两组 LED 组成：4 个 LED 表示小时（可显示 0 到 11），6 个 LED 表示分钟（可显示 0 到 59）。每个 LED 代表一个二进制位，亮表示 1，灭表示 0。给定一个整数 `turnedOn`，表示当前亮着的 LED 总数，请找出所有可能的时间，使得亮着的 LED 数量恰好为 `turnedOn`。时间以字符串形式返回，格式为 `"H:MM"`，其中小时没有前导零，分钟总是两位（若不足两位则补零）。返回结果顺序任意。

## **示例说明**

- 输入 `turnedOn = 1`，输出包含所有只有一盏 LED 亮的时间，如 `"0:01"`, `"0:02"`, ..., `"8:00"` 等。
- 输入 `turnedOn = 9`，由于最大可能亮灯数为 10（小时最多 4 个，分钟最多 6 个），但 9 没有有效组合，返回空列表。

## **数据范围**

- `0 <= turnedOn <= 10`



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```cpp
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> binRes; // 存储所有合法时间字符串

        // 枚举所有可能的小时（0 ~ 11）和分钟（0 ~ 59）
        for (int hour = 0; hour < 12; hour++) {
            for (int minute = 0; minute < 60; minute++) {
                // 计算当前时间在二进制表示中 1 的总个数
                // 小时部分（4位LED） + 分钟部分（6位LED）
                int totalOnBits = countOnes(hour) + countOnes(minute);

                // 如果 1 的总数等于题目要求的亮灯数，则该时间合法
                if (totalOnBits == turnedOn) {
                    // 格式化为 "H:MM" 形式（分钟必须两位，如 05）
                    char timeStr[6]; // 足够容纳 "11:59\0"
                    sprintf(timeStr, "%d:%02d", hour, minute);
                    binRes.emplace_back(string(timeStr));
                }
            }
        }
        return binRes;
    }

    // 辅助函数：计算一个整数的二进制表示中 1 的个数
    int countOnes(int num) {
        int cnt = 0;
        while (num > 0) {
            if (num & 1) {      // 检查最低位是否为 1
                cnt++;
            }
            num >>= 1;          // 无符号右移一位（等价于 num /= 2）
        }
        return cnt;
    }
};
```

> 💡 注意：
>
> - 小时范围是 `0~11`（共 12 小时），对应 4 位二进制（最大 11 = 1011₂）
> - 分钟范围是 `0~59`，对应 6 位二进制（最大 59 = 111011₂）
> - 总共 10 个 LED 灯（4 小时 + 6 分钟）

---

## 🧠 核心解题思想分析

### 🔍 问题背景：

- 二进制手表有 **4 个 LED 表示小时（0–11）**，**6 个 LED 表示分钟（0–59）**；
- 每个 LED 亮表示二进制位为 1；
- 给定亮灯总数 `turnedOn`，求所有可能显示的时间（格式 `"H:MM"`）。

> 例如：`turnedOn = 1`  
> 可能时间包括：`"1:00"`, `"2:00"`, `"4:00"`, `"8:00"`, `"0:01"`, `"0:02"`, ..., `"0:32"`

---

### 💡 核心思想：**枚举所有合法时间 + 位计数验证**

#### 1. **为什么可以暴力枚举？**

- 小时只有 12 种（0~11）
- 分钟只有 60 种（0~59）
- 总共仅 `12 × 60 = 720` 种组合 → **完全可接受**

#### 2. **如何判断一个时间是否合法？**

- 将 `hour` 和 `minute` 转为二进制；
- 统计其中 `1` 的个数（即亮灯数）；
- 若 `countOnes(hour) + countOnes(minute) == turnedOn`，则合法。

#### 3. **位计数技巧**

- 使用 `num & 1` 判断最低位是否为 1；
- 使用 `num >>= 1` 逐位右移；
- 循环直到 `num == 0`。

> 📌 也可用内置函数（如 `__builtin_popcount`），但手写更通用。

#### 4. **格式化输出**

- 使用 `sprintf(..., "%d:%02d", h, m)` 确保分钟始终两位（如 `05` 而非 `5`）。

---

### 🔄 示例说明

假设 `turnedOn = 2`

枚举到 `hour = 3`（二进制 `11` → 2 个 1），`minute = 0`（0 个 1）→ 总共 2 → 合法 → `"3:00"`

枚举到 `hour = 1`（1 个 1），`minute = 2`（二进制 `10` → 1 个 1）→ 总共 2 → 合法 → `"1:02"`

...

最终收集所有满足条件的时间。

---

### ⏱️ 复杂度分析：

- **时间复杂度**：O(12 × 60 × log(max(12,60))) ≈ O(720 × 6) = **O(1)**  
    —— 因为输入规模固定（最多 720 次），视为常数时间
- **空间复杂度**：O(1)（不计输出列表）  
    —— 只用常数额外变量

> ✅ 对于本题约束（`turnedOn ≤ 10`），这是最简单、最可靠的解法！

---

## 📚 笔记总结

### 🧩 问题定义：

- 4 位表示小时（0–11），6 位表示分钟（0–59）；
- 给定亮灯总数 `turnedOn`，返回所有可能的时间（格式 `"H:MM"`）。

### 💡 核心思想：

> **暴力枚举所有时间 + 位计数验证**

### ✅ 算法步骤：

1. 遍历 `hour ∈ [0, 11]`，`minute ∈ [0, 59]`；
2. 对每个 `(hour, minute)`：
    - 计算 `popcount(hour) + popcount(minute)`
    - 若等于 `turnedOn`，则格式化并加入结果；
3. 返回结果列表。

### 🔑 关键技巧：

- **枚举范围小**（仅 720 种），暴力完全可行；
- **位计数**：`while (n) { cnt += n & 1; n >>= 1; }`
- **格式化分钟**：`%02d` 确保两位显示；
- **无需回溯或位掩码生成**，简洁高效。

### ⏱️ 复杂度：

- 时间：O(1)（固定 720 次循环）
- 空间：O(1)（忽略输出）

### 💡 延伸思考：

- 若 LED 数更多？→ 可考虑预计算 `popcount` 表；
- 本题体现了“**小规模问题优先考虑枚举**”的工程思维。

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> binRes = new ArrayList<>();
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 60; j++) {
                int temp = flagOne(i) + flagOne(j);
                if (temp == turnedOn) {
                    String time = String.format("%d:%02d", i, j);
                    binRes.add(time);
                }
            }
        }
        return binRes;
    }

    public int flagOne(int num) {
        int cnt = 0;
        while (num > 0) {
            if ((num & 1) == 1) {
                cnt++;
            }
            num >>= 1;
        }
        return cnt;
    }
}
```



## Python代码

```Python
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        bin_res = []
        for i in range(12):
            for j in range(60):
                temp = self.flag_one(i) + self.flag_one(j)
                if temp == turnedOn:
                    time = f"{i}:{j:02d}"
                    bin_res.append(time)
        return bin_res
    
    def flag_one(self, num: int) -> int:
        cnt = 0
        while num > 0:
            if num & 1:
                cnt += 1
            num >>= 1
        return cnt
```



## C++代码

```C++
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> binRes;
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 60; j++) {
                int temp = flagOne(i) + flagOne(j);
                if (temp == turnedOn) {
                    char time[6];
                    sprintf(time, "%d:%02d", i, j);
                    binRes.emplace_back(string{ time });
                }
            }
        }
        return binRes;
    }

    int flagOne(int num) {
        int cnt = 0;
        while (num > 0) {
            if (num & 1) {
                cnt++;
            }
            num >>= 1;
        }
        return cnt;
    }
};
```

![401_二进制手表_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/5_%E4%BD%8D%E8%BF%90%E7%AE%97/Images/401_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8_C++.png)