本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[189. 轮转数组 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  数学  |  双指针

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums` 和一个非负整数 `k`，请将数组中的元素整体向右轮转 `k` 个位置（即数组末尾的元素移动到前面，其余元素依次后移）。返回轮转后的数组。

## **示例说明**

- **示例1**：`nums = [1,2,3,4,5,6,7]`, `k = 3`，轮转结果为 `[5,6,7,1,2,3,4]`。
- **示例2**：`nums = [-1,-100,3,99]`, `k = 2`，轮转结果为 `[3,99,-1,-100]`。

## **数据范围**

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

## **进阶要求**

尝试设计至少三种不同的解决方案，并考虑使用空间复杂度为 O(1) 的原地算法。



# 二、解题思路\解题过程

这是LeetCode热题100中的一道题目，题意很简单，就是将整个数组向右轮转`k`个位置即可！有两种方法！

第一种就是，复制题目提供的数组，注意得是“深拷贝”，需要与原数组隔离，然后在根据`nums[(i + k) % n] = tmp[i]`来修改原数组！

第二种就是，**不用额外数组（原地）** 且 **高效** 的方法，我们可以采用**三次反转**来实现，核心思想如下：
```
右移 `k` 位，等价于：

1. 将整个数组反转
2. 反转前 `k` 个元素
3. 反转后 `n - k` 个元素
```



# 三、代码演示

## Java代码

```Java
// 深拷贝数组
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        int[] tmp = Arrays.copyOf(nums, n);
        for (int i = 0; i < n; i++) {
            nums[(i + k) % n] = tmp[i];
        }
    }
}

// 三次反转
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        if (k == 0) return;

        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
}
```



## Python代码

```Python
# 深拷贝数组
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        tmp = copy.deepcopy(nums)
        n = len(nums)
        for i in range(n):
            nums[(i + k) % n] = tmp[i]

# 三次反转
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k %= n
        if k == 0:
            return
        
        self.reverse(nums, 0, n - 1)
        self.reverse(nums, 0, k - 1)
        self.reverse(nums, k, n - 1)

    def reverse(self, nums: List[int], start: int, end: int) -> None:
        while start < end:
            tmp = nums[start]
            nums[start] = nums[end]
            nums[end] = tmp
            start += 1
            end -= 1
```



## C++代码

```C++
// 深拷贝数组
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        vector<int> tmp;
        int n = nums.size();
        for (auto num : nums) tmp.push_back(num);
        for (int i = 0; i < n; i++) {
            nums[(i + k) % n] = tmp[i];
        }
    }
};

// 三次反转
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;
        if (k == 0) return;

        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

private:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            start++;
            end--;
        }
    }
};
```

![189_轮转数组_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/13_%E6%95%B0%E7%BB%84/Images/189_%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84_C++.png)