本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  矩阵  |  模拟

# 一、题目描述

## **问题概括**

给定一个 `m` 行 `n` 列的整数矩阵 `matrix`，请按照顺时针螺旋顺序，依次返回矩阵中的所有元素。螺旋遍历从左上角开始，先向右遍历到底，然后向下、向左、向上，依次由外向内层层遍历，直到所有元素都被访问一次。

## **示例说明**

- **示例1**：`matrix = [[1,2,3],[4,5,6],[7,8,9]]`，螺旋顺序输出为 `[1,2,3,6,9,8,7,4,5]`。
- **示例2**：`matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]`，输出为 `[1,2,3,4,8,12,11,10,9,5,6,7]`。

## **数据范围**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`



# 二、解题思路\解题过程

这是今天做的`LeetCode热题100`中的一道，直接模拟就好了，只需要注意上下左右四个边界的临界值就好了，具体代码实现如下所示！

# 三、代码演示

## Java代码

```Java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if (result == null) {
            return result;
        }
        int left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1;
        while (left <= right && top <= bottom) {
            for (int i = left; i <= right; i++) {
                result.add(matrix[top][i]);
            }
            for (int j = top + 1; j <= bottom; j++) {
                result.add(matrix[j][right]);
            }
            if (left < right && top < bottom) {
                for (int i = right - 1; i > left; i--) {
                    result.add(matrix[bottom][i]);
                }
                for (int j = bottom; j > top; j--) {
                    result.add(matrix[j][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        result = []
        if len(matrix) == 0:
            return result
        left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1
        while left <= right and top <= bottom:
            for i in range(left, right + 1):
                result.append(matrix[top][i])
            for j in range(top + 1, bottom + 1):
                result.append(matrix[j][right])
            if left < right and top < bottom:
                for i in range(right - 1, left, -1):
                    result.append(matrix[bottom][i])
                for j in range(bottom, top, -1):
                    result.append(matrix[j][left])
            left += 1
            right -= 1
            top += 1
            bottom -= 1
        return result
```



## C++代码

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if (matrix.size() == 0) {
            return result;
        }
        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1;
        while (left <= right && top <= bottom) {
            for (int i = left; i <= right; i++) {
                result.push_back(matrix[top][i]);
            }
            for (int j = top + 1; j <= bottom; j++) {
                result.push_back(matrix[j][right]);
            }
            if (left < right && top < bottom) {
                for (int i = right - 1; i > left; i--) {
                    result.push_back(matrix[bottom][i]);
                }
                for (int j = bottom; j > top; j--) {
                    result.push_back(matrix[j][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return result;
    }
};
```

![54_螺旋矩阵_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/13_%E6%95%B0%E7%BB%84/Images/54_%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_C++.png)