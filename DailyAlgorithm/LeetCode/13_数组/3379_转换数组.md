本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3379. 转换数组 - 力扣（LeetCode）](https://leetcode.cn/problems/transformed-array/description/?envType=daily-question&envId=2026-02-05)

>标签：中级工程师  |  数组  |  模拟

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums`，将其视为**循环数组**（即首尾相连）。请根据以下规则构建一个与 `nums` 长度相同的数组 `result`：

- 对于每个下标 `i`（`0 ≤ i < nums.length`）：
    - 若 `nums[i] > 0`，则从下标 `i` 开始**向右**移动 `nums[i]` 步（若超出数组末尾则绕回开头），将到达位置的 `nums` 元素值赋给 `result[i]`。
    - 若 `nums[i] < 0`，则从下标 `i` 开始**向左**移动 `|nums[i]|` 步（若超出数组开头则绕回末尾），将到达位置的 `nums` 元素值赋给 `result[i]`。
    - 若 `nums[i] == 0`，则直接将 `nums[i]`（即 0）赋给 `result[i]`。

返回构造出的 `result` 数组。

## **示例说明**

- **示例1**：`nums = [3,-2,1,1]`，计算得到 `result = [1,1,1,3]`。
- **示例2**：`nums = [-1,4,-1]`，计算得到 `result = [-1,-1,4]`。

## **数据范围**

- 数组长度 `n` 满足 `1 ≤ n ≤ 100`。
- 数组元素满足 `-100 ≤ nums[i] ≤ 100`。



# 二、解题思路\解题过程

这是今天的`LeetCode`上的每日一题，就是将数组中的值进行移动，如果`nums[i] > 0`就向右移动，如果`nums[i] < 0`就向左移动，如果`nums[i] == 0`那就不移动；向左和向右移动都可以使用公式——`k = ((i + nums[i]) % n + n) % n`——来解决，首先`(i + nums[i]) % n`的结果的范围为`-n ~ n —— [-n + 1, n - 1]`，然后在此基础上加上`n`，然后在对`n`取余，即在 **所有情况下（无论 `nums[i]` 多大、正负）都能正确计算环形数组中的下一个索引**，且结果 ∈ `[0, n-1]`。

# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] constructTransformedArray(int[] nums) {
        int n = nums.length, k = 0;
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                k = ((i + nums[i]) % n + n) % n;
            } else {
                k = i;
            }
            result[i] = nums[k];
        }
        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        n, k = len(nums), 0
        result = [0] * n
        for i in range(n):
            if nums != 0:
                k = ((i + nums[i]) % n + n) % n
            else:
                k = i
            result[i] = nums[k]
        return result
```



## C++代码

```C++
class Solution {
public:
    vector<int> constructTransformedArray(vector<int>& nums) {
        int n = nums.size(), k = 0;
        vector<int> result(n);
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                k = ((i + nums[i]) % n + n) % n;
            } else {
                k = i;
            }
            result[i] = nums[k];
        }
        return result;
    }
};
```

![3379_转换数组_C++]()