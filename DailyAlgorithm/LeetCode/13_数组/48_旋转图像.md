本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  数学  |  矩阵

# 一、题目描述

## **问题概括**

给定一个 n × n 的二维矩阵，表示一个图像。你需要将该图像顺时针旋转 90 度。要求必须 **原地** 修改矩阵，不得使用额外的矩阵进行存储。

## **示例说明**

- 一个 3×3 的矩阵在旋转后，行与列的位置会按特定规律变换。
- 如 `[[1,2,3],[4,5,6],[7,8,9]]` 旋转后变为 `[[7,4,1],[8,5,2],[9,6,3]]`。

## **数据范围**

- 矩阵为正方形，边长 n 满足 `1 <= n <= 20`
- 矩阵元素取值范围为 `-1000` 到 `1000`



# 二、解题思路\解题过程

## 🧩 题目理解

给定一个 `n × n` 的二维矩阵 `matrix`，**原地**（in-place）将其 **顺时针旋转 90 度**。

> - 不能使用额外的矩阵（必须修改原 `matrix`）
> - 例如：
>
>     ```
>     输入：
>     [[1,2,3],
>      [4,5,6],
>      [7,8,9]]
>     
>     输出（顺时针旋转90°）：
>     [[7,4,1],
>      [8,5,2],
>      [9,6,3]]
>     ```
>

---

## ✅ 核心思想：**分层旋转（Layer-by-Layer Rotation）**

- 把矩阵看作若干个“同心正方形”（称为“层”）
    - 最外层：第 0 行/列 到 第 n-1 行/列
    - 次外层：第 1 行/列 到 第 n-2 行/列
    - ...
- 对每一层，**每次处理 4 个对应位置的元素**，进行轮换（rotate four corners）
- 每次只处理“上边”的前 `n - 2*i - 1` 个元素（避免重复）

> 💡 关键观察：顺时针旋转 90° 后，
>
> - 原 `(i, j)` → 新位置是 `(j, n - 1 - i)`
> - 但直接赋值会覆盖数据，所以要用**临时变量 + 四步轮换**

---

## 📝 带详细中文注释的 C++ 代码

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();

        // 外层循环：遍历每一“层”，从最外层到中心
        // 共有 n / 2 层（奇数时中心点不动）
        for (int i = 0; i < n / 2; i++) {

            // 内层循环：遍历当前层的“上边”元素（从左到右，但不包括最后一个）
            // 为什么到 n - i - 1？因为当前层的右边界是 n - 1 - i
            for (int j = i; j < n - i - 1; j++) {

                // 保存左上角的值（即将被覆盖）
                int tmp = matrix[i][j];

                // 左下 → 左上
                // 原左下位置：(n-1-j, i)
                matrix[i][j] = matrix[n - 1 - j][i];

                // 右下 → 左下
                // 原右下位置：(n-1-i, n-1-j)
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];

                // 右上 → 右下
                // 原右上位置：(j, n-1-i)
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];

                // 左上（tmp）→ 右上
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
};
```

---

## 🔁 四个位置的对应关系（以 4×4 矩阵为例）

对于位置 `(i, j)`，在当前层中，四个要轮换的位置是：

| 方向 | 坐标             | 说明               |
| ---- | ---------------- | ------------------ |
| 左上 | `(i, j)`         | 当前处理点         |
| 左下 | `(n-1-j, i)`     | 原本在左边列的下方 |
| 右下 | `(n-1-i, n-1-j)` | 对角位置           |
| 右上 | `(j, n-1-i)`     | 原本在上边行的右侧 |

**轮换顺序（顺时针）**：

```
左下 → 左上  
右下 → 左下  
右上 → 右下  
tmp（原左上）→ 右上
```

> 这样就完成了一组 4 个元素的 90° 顺时针轮换！

---

## 📌 笔记重点

### ✅ 方法：**原地分层旋转**

- 时间复杂度：**O(n²)**（每个元素访问一次）
- 空间复杂度：**O(1)**（仅用一个临时变量）

### ✅ 为什么 `j` 的范围是 `[i, n - i - 1)`？

- 当前层的“上边”是从列 `i` 到列 `n - 1 - i`
- 但最后一个点 `(i, n-1-i)` 是“右上角”，它会在处理 `(i, i)` 时被轮换到正确位置
- 所以**不包含右端点**，避免重复旋转

### ✅ 替代方法（补充知识）：

1. **先转置（transpose），再每行反转**：
   
    ```cpp
    // 转置
    for (int i = 0; i < n; i++)
        for (int j = i; j < n; j++)
            swap(matrix[i][j], matrix[j][i]);
    // 每行反转
    for (auto& row : matrix)
        reverse(row.begin(), row.end());
    ```
    
    - 更简洁，也 O(1) 空间，面试可提！

---

## ✅ 总结一句话

> **顺时针旋转 90° = 分层处理，每层对四个对称位置做轮换；或等价于“转置 + 行反转”。**

# 三、代码演示

## Java代码

```Java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; i++) {  // 遍历每一“层”（从外到内）
            for (int j = i; j < n - i - 1; j++) {  // 遍历当前层的“上边”（除最后一个点）
                int tmp = matrix[i][j];  // 保存左上角
                matrix[i][j] = matrix[n - 1 - j][i];  // 左上 → 左下
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];  // 右下 → 左下
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];  // 右上 → 右下
                matrix[j][n - 1 - i] = tmp;  // 左上 → 右上
            }
        }
    }
}
```



## Python代码

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n // 2):  # 遍历每一“层”（从外到内）
            for j in range(i, n - i - 1):  # 遍历当前层的“上边”（除最后一个点）
                tmp = matrix[i][j]  # 保存左上角
                matrix[i][j] = matrix[n - 1 - j][i]  # 左上 → 左下
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]  # 右下 → 左下
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]  # 右上 → 右下
                matrix[j][n - 1 - i] = tmp  # 左下 → 右上
```



## C++代码

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {  // 遍历每一“层”（从外到内）
            for (int j = i; j < n - i - 1; j++) {  // 遍历当前层的“上边”（除最后一个点）
                int tmp = matrix[i][j];  // 保存左上角
                matrix[i][j] = matrix[n - 1 - j][i];  // 左上 → 左下
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];  // 右下 → 左下
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];  // 右上 → 右下
                matrix[j][n - 1 - i] = tmp;  // 左上 → 右上
            }
        }
    }
};
```

![48_旋转图像_C++]()