本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3640. 三段式数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/trionic-array-ii/description/?envType=daily-question&envId=2026-02-04)

>标签：高级专家  |  数组  |  动态规划

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums`，请找出所有满足以下条件的连续子数组：该子数组可以划分为三个连续部分，且存在下标 `l < p < q < r`，使得：

- 子数组从下标 `l` 到 `p` 的部分是**严格递增**的；
- 从下标 `p` 到 `q` 的部分是**严格递减**的；
- 从下标 `q` 到 `r` 的部分是**严格递增**的。

你需要计算所有这样的子数组中，其元素之和的最大值，并返回这个最大值。

## **示例说明**

- **示例1**：数组 `[0,-2,-1,-3,0,2,-1]` 中，满足条件的一个子数组为 `[-2,-1,-3,0,2]`，其和为 -4。
- **示例2**：数组 `[1,4,2,7]` 本身即满足条件，和为 14。

## **数据范围**

- `4 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- 保证至少存在一个满足条件的子数组。



# 二、解题思路\解题过程

## ✅ 题目背景简述

题目要求：在一个数组中找到一个 **“三段式子数组”（Trionic Subarray）**，使得其元素和最大。

> **三段式子数组定义**：
>
> - 第一段：严格递增（至少两个元素）
> - 第二段：严格递减（至少两个元素）
> - 第三段：严格递增（至少两个元素）
>
> 整体形状像：**↗ ↘ ↗**（先升、再降、再升），且每段至少包含两个数。
>
> 注意：三段必须**连续衔接**，不能跳跃。

目标：返回所有合法三段式子数组中，**元素总和的最大值**。若不存在，返回 `Long.MIN_VALUE`（但题目保证有解或需处理无解情况）。

---

## 📚 笔记总结

### 🔑 核心思想

本题不是简单找一个固定形状的子数组，而是：

- **强制包含**：每段的“连接处”元素必须选（如第一段最后两个、第二段全部、第三段前两个）；
- **可选扩展**：在强制部分之外，**向左/向右延伸的部分可以选也可以不选**，但要选就选**和最大的连续部分**（类似“最大子数组和”，但允许空选 → 最小为 0）。

> 💡 本质：**在满足三段结构的前提下，最大化总和 = 强制部分 + 最优可选前缀 + 最优可选后缀**

---

### 🧩 三段结构详解

| 段     | 要求            | 是否强制选       | 可选部分                               |
| ------ | --------------- | ---------------- | -------------------------------------- |
| 第一段 | 严格递增，≥2 个 | **最后两个必选** | 从倒数第三个往左的任意前缀（取最大和） |
| 第二段 | 严格递减，≥2 个 | **全部必选**     | 无                                     |
| 第三段 | 严格递增，≥2 个 | **前两个必选**   | 从第三个往右的任意后缀（取最大和）     |

> ✅ 为什么可选部分可以“不选”？  
> 因为如果延伸部分是负数，不加反而更大。所以用 `max(0, 最大子段和)` 的思想，但这里通过 `maxS = max(maxS, s)` 且初始为 0 实现。

---

### ⚙️ 算法流程

1. **外层循环**：以每个位置为潜在起点，尝试构建三段式。
2. **第一段**：向右找严格递增序列，记录起点 `start` 和峰值 `peak`。
3. **第二段**：从 `peak` 向右找严格递减序列，记录谷底 `bottom`。
4. **第三段**：从 `bottom` 向右找严格递增序列。
5. **合法性检查**：每段至少两个元素，且严格单调（无相等）。
6. **计算总和**：
    - 强制部分：`nums[peak-1] + nums[peak] + 第二段所有 + nums[bottom+1]`
    - 可选前缀：第一段 `[start, peak-2]` 的最大后缀和（从右往左累加）
    - 可选后缀：第三段 `[bottom+2, ...]` 的最大前缀和（从左往右累加）
7. **更新答案**，并**跳转到谷底**作为下一次起点（避免重复无效搜索）。

---

### 💡 关键技巧

- **滑动窗口 + 贪心扩展**：用指针 `i` 一路向右推进，自动划分三段。
- **最大子段和变种**：可选部分使用“最大前缀/后缀和”，但允许为空（初始 `maxS = 0`）。
- **高效跳转**：`i = bottom` 避免回溯，保证线性时间复杂度（每个元素最多被访问常数次）。

---

### ⏱️ 时间复杂度

- **O(n)**：每个元素在主循环、前缀、后缀中最多被访问几次，整体线性。

---

### ❗ 易错点提醒

- 三段都必须 **严格单调**（不能有相等元素）。
- 每段 **至少两个元素**（注意边界判断）。
- **可选部分可以不选**（所以最大和至少为 0）。
- **指针跳转**：`i = bottom` 是关键优化，否则会超时或漏解。

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public long maxSumTrionic(int[] nums) {
        int n = nums.length;
        // 初始化答案为最小值，用于后续更新最大值
        long result = Long.MIN_VALUE;
        
        // 外层循环：枚举每一个可能的“三段式”起始位置 i
        for (int i = 0; i < n;) {
            // 第一段：严格递增（至少两个元素）
            int start = i;  // 记录第一段的起始索引
            // 从 i 开始，向右扩展，只要 nums[i - 1] < nums[i] 就继续（严格递增）
            for (i++; i < n && nums[i - 1] < nums[i]; i++);

            // 检查第一段是否合法：至少要有两个元素 → i 至少前进到 start + 2
            // 如果 i == start + 1，说明只走了 1 步（即只有一个元素），不合法
            if (i == start + 1) {
                continue;  // 跳过，尝试下一个起点
            }

            // 此时 i 指向第一段结束后的位置
            // 第一段的最后一个元素（即峰值前一个）是 i - 2，峰值是 i - 1
            int peak = i - 1;  // 峰值位置（第一段的最后一个元素）

            // 第一段的最后两个数必须选（因为第二段要从 peak 开始下降）
            long res = nums[peak - 1] + nums[peak];

            // 第二段：严格递减（至少两个元素）
            // 从 peak 开始：继续向右，只要 nums[i - 1] > nums[i] 就继续（严格递减）
            for (; i < n && nums[i - 1] > nums[i]; i++) {
                res += nums[i];  // 第二段的所有元素都必须加入总和
            }

            // 检查第二段是否合法：
            // i == peak + 1：第二段只走了一步（即只有一个元素），不合法
            // i == n：已经到数组末尾，无法开始第三段
            // nums[i - 1] == nums[i]：违反“严格”递减（虽然循环已停，但可能是相等导致停止）
            if (i == peak + 1 || i == n || nums[i - 1] == nums[i]) {
                continue;  // 不合法，跳过
            }

            // 此时 i 指向第二段结束后的位置（即第三段的第二个元素位置）
            int bottom = i - 1;  // 谷底位置（第二段最后一个元素）
            // 第三段的第一个元素是 bottom（已在第二段循环中加入）
            // 第三段的第二个元素是 i（当前 i 指向它），必须选
            res += nums[i];  // 加入第三段的第二个元素

            // 第三段：严格递增（至少两个元素，但可选更多）
            // 从第三段到第三个元素开始（i + 1），向右扩展
            long maxS = 0; // 记录第三段“可选后缀”的最大和（可以不选，所以最小为 0）
            long s = 0;  // 当前后缀和
            for (i++; i < n && nums[i - 1] < nums[i]; i++) {
                s += nums[i];
                maxS = Math.max(maxS, s);  // 只保留最大的正贡献
            }
            res += maxS;  // 加上第三段最优后缀

            // 回头优化第一段：可选前缀
            // 第一段的最后两个元素已固定（peak - 1 和 peak）
            // 但从 peak - 2 往左（到 start），可以选择一些前缀来增加总和
            maxS = 0;
            s = 0;
            // 从 peak - 2 开始往左遍历到 start
            for (int j = peak - 2; j >= start; j--) {
                s += nums[j];
                maxS = Math.max(maxS, s);  // 同样只取最大正贡献（可不选）
            }
            res += maxS;  // 加上第一段最优前缀

            // 更新全局最大值
            result = Math.max(result, res);

            // 关键：下一次搜索从当前谷底 bottom 开始
            // 因为 bottom 可能是下一个三段式的起点
            i = bottom;
        }
        return result;
    }
}
```

![3640_三段式数组 II_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/13_%E6%95%B0%E7%BB%84/Images/3640_%E4%B8%89%E6%AE%B5%E5%BC%8F%E6%95%B0%E7%BB%84%20II_Java.png)

## Python代码

```Python
class Solution:
    def maxSumTrionic(self, nums: List[int]) -> int:
        n = len(nums)
        ans = float('-inf')  # 对应 Java 的 Long.MIN_VALUE（题目返回 int，但中间用 long；Python 用 -inf 模拟）
        
        i = 0
        while i < n:
            # 第一段
            start = i
            i += 1
            while i < n and nums[i - 1] < nums[i]:
                i += 1
            if i == start + 1:  # 第一段至少要有两个数
                continue

            # 第二段
            peak = i - 1
            res = nums[peak - 1] + nums[peak]  # 第一段的最后两个数必选
            while i < n and nums[i - 1] > nums[i]:
                res += nums[i]  # 第二段的所有元素必选
                i += 1
            if i == peak + 1 or i == n or nums[i - 1] == nums[i]:  # 第二段至少两个，第三段至少两个
                continue

            # 第三段
            bottom = i - 1
            res += nums[i]  # 第三段的前两个数必选（第一个已在第二段循环中加了？注意：此处 i 是第三段第二个元素）
            
            # 从第三段的第三个数往右，计算最大元素和
            maxS = 0
            s = 0
            i += 1
            while i < n and nums[i - 1] < nums[i]:
                s += nums[i]
                maxS = max(maxS, s)
                i += 1
            res += maxS

            # 从第一段的倒数第三个数往左，计算最大元素和
            maxS = 0
            s = 0
            for j in range(peak - 2, start - 1, -1):
                s += nums[j]
                maxS = max(maxS, s)
            res += maxS

            ans = max(ans, res)
            i = bottom  # 第三段的起点也是下一个极大三段式子数组的第一段的起点

        return ans
```



## C++代码

```C++
class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size();
        long long ans = LLONG_MIN; // 对应 Java 的 Long.MIN_VALUE

        for (int i = 0; i < n;) {
            // 第一段
            int start = i;
            for (i++; i < n && nums[i - 1] < nums[i]; i++);
            if (i == start + 1) { // 第一段至少要有两个数
                continue;
            }

            // 第二段
            int peak = i - 1;
            long long res = (long long)nums[peak - 1] + nums[peak]; // 第一段的最后两个数必选
            for (; i < n && nums[i - 1] > nums[i]; i++) {
                res += nums[i]; // 第二段的所有元素必选
            }
            if (i == peak + 1 || i == n || nums[i - 1] == nums[i]) { // 第二段至少两个，第三段至少两个
                continue;
            }

            // 第三段
            int bottom = i - 1;
            res += nums[i]; // 第三段的前两个数必选（第一个在上面循环已加？注意：此处 i 是第三段第二个元素）

            // 从第三段的第三个数往右，计算最大元素和
            long long maxS = 0;
            long long s = 0;
            for (i++; i < n && nums[i - 1] < nums[i]; i++) {
                s += nums[i];
                maxS = max(maxS, s);
            }
            res += maxS;

            // 从第一段的倒数第三个数往左，计算最大元素和
            maxS = 0;
            s = 0;
            for (int j = peak - 2; j >= start; j--) {
                s += nums[j];
                maxS = max(maxS, s);
            }
            res += maxS;

            ans = max(ans, res);
            i = bottom; // 第三段的起点也是下一个极大三段式子数组的第一段的起点
        }
        return ans;
    }
};
```

