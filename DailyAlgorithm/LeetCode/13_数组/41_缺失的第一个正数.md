本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  哈希表

# 一、题目描述

## **问题概括**

给定一个未排序的整数数组 `nums`，请找出数组中**没有出现的最小的正整数**。要求算法的时间复杂度为 **O(n)**，并且只能使用**常数级别**的额外空间。

## **示例说明**

- **示例1**：`nums = [1,2,0]`，缺失的最小正整数是 `3`。
- **示例2**：`nums = [3,4,-1,1]`，缺失的最小正整数是 `2`。
- **示例3**：`nums = [7,8,9,11,12]`，缺失的最小正整数是 `1`。

## **数据范围**

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`



# 二、解题思路\解题过程

## 🔑 题目要求

> 给定一个未排序的整数数组 `nums`，找出其中**没有出现的最小正整数**。  
> 要求：**时间复杂度 O(n)**，**空间复杂度 O(1)**（即不能使用哈希表等额外空间）。

---

## 💡 核心思想：**原地哈希（In-place Hashing）**

- 数组长度为 `n`，那么**答案一定在 `[1, n+1]` 范围内**。
    - 最坏情况：`nums = [1,2,3,...,n]` → 缺失 `n+1`
    - 其他情况：缺失某个 `1~n` 中的数
- 利用数组**自身作为哈希表**：
    - 规定：**数字 `x` 应该存放在下标 `x-1` 处**
    - 例如：1 放在 index 0，2 放在 index 1，…，n 放在 index n-1

> ✅ 这样，最终只要扫描一遍数组，第一个 `nums[i] != i+1` 的位置，就说明 `i+1` 缺失！

---

## ⚙️ 算法步骤

### 步骤 1：**重排数组（原地归位）**

- 遍历每个位置 `i`
- 如果 `nums[i]` 是 `[1, n]` 中的数，且**还没放到正确位置**，就把它交换到 `nums[nums[i]-1]`
- 使用 `while` 循环确保当前位置最终放的是“无法再移动”或“不在 [1,n]”的数

> ⚠️ 注意：必须用 `while` 而不是 `if`！  
> 因为交换过来的新值可能也需要继续归位（例如 `[3,4,-1,1]`）

### 步骤 2：**线性扫描找缺失**

- 检查每个位置 `i`：是否 `nums[i] == i+1`
- 第一个不满足的位置 → 缺失 `i+1`

### 步骤 3：**全匹配 → 返回 n+1**

---

## 🧪 举例说明

输入：`nums = [3, 4, -1, 1]`，`n = 4`

**归位过程**：

- i=0: nums[0]=3 → 应放 index 2 → 交换 → `[-1, 4, 3, 1]`
    - 现在 nums[0]=-1（不在 [1,4]），停止
- i=1: nums[1]=4 → 应放 index 3 → 交换 → `[-1, 1, 3, 4]`
    - 现在 nums[1]=1 → 应放 index 0 → 交换 → `[1, -1, 3, 4]`
    - 现在 nums[1]=-1，停止
- i=2: nums[2]=3 → 已在 index 2（正确）
- i=3: nums[3]=4 → 已在 index 3（正确）

最终数组：`[1, -1, 3, 4]`

**扫描**：

- i=0: 1 == 1 ✅
- i=1: -1 != 2 ❌ → 返回 **2**

---

## ⏱️ 复杂度分析

- **时间复杂度：O(n)**
    - 每个元素最多被交换两次（一旦归位就不会再动）
    - 总操作次数是线性的
- **空间复杂度：O(1)**
    - 只使用常数额外变量，原地修改数组

---

## ❗ 关键细节 & 易错点

| 问题                                          | 说明                                                       |
| --------------------------------------------- | ---------------------------------------------------------- |
| **为什么用 `while`？**                        | 一次交换后，新来的数可能仍需归位（如上面例子中的 `4 → 1`） |
| **为什么检查 `nums[nums[i]-1] != nums[i]`？** | 防止死循环！例如 `nums = [1,1]`，若不检查，会无限交换      |
| **负数/大于 n 的数怎么处理？**                | 直接跳过，它们不影响 `[1,n]` 的缺失判断                    |
| **为什么答案不会超过 n+1？**                  | 鸽巢原理：n 个位置最多容纳 n 个不同的正整数 `[1,n]`        |

---

## 🧠 记忆口诀

> “**让每个数字坐回自己的座位，第一个空座就是答案！**”

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 第一步：将每个在 [1, n] 范围内的正整数“放到它应该在的位置”
        // 即：数字 x 应该放在下标 x-1 的位置（因为数组从 0 开始）
        for (int i = 0; i < n; i++) {
            // 循环条件解释：
            // 1. nums[i] 是正整数且在 [1, n] 范围内 → 说明它“有资格”被放到正确位置
            // 2. nums[nums[i] - 1] != nums[i] → 说明它的“真身”还没坐在正确座位上（避免死循环）
            while (1 <= nums[i] && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 找到 nums[i] 应该去的座位编号 j = nums[i] - 1
                int j = nums[i] - 1;
                // 交换 nums[i] 和 nums[j]，把 nums[i] 送到它该去的位置
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
        }

        // 第二步：遍历数组，找第一个“座位号”和“学号”不匹配的位置
        // 座位 i（0-indexed）应该坐学号 i+1 的学生
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                // 如果座位 i 上的学生学号不是 i+1，说明 i+1 缺失了
                return i + 1;
            }
        }

        // 第三步：如果所有座位都匹配，说明 [1, n] 都存在，那么缺失的是 n+1
        return n + 1;
    }
}
```

![41_缺失的第一个正数_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/13_%E6%95%B0%E7%BB%84/Images/41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0_Java.png)

## Python代码

```Python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            # 如果当前学生的学号在 [1,n] 中，但（真身）没有坐在正确的座位上
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                # 那么就交换 nums[i] 和 nums[j]，其中 j 是 i 的学号
                j = nums[i] - 1  # 减一是因为数组下标从 0 开始
                tmp = nums[i]
                nums[i] = nums[j]
                nums[j] = tmp

        # 找第一个学号与座位编号不匹配的学生
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1

        # 所有学生都坐在正确的座位上
        return n + 1
```



## C++代码

```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // 如果当前学生的学号在 [1,n] 中，但（真身）没有坐在正确的座位上
            while (1 <= nums[i] && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 那么就交换 nums[i] 和 nums[j]，其中 j 是 i 的学号
                int j = nums[i] - 1; // 减一是因为数组下标从 0 开始
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
        }

        // 找第一个学号与座位编号不匹配的学生
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        // 所有学生都坐在正确的座位上
        return n + 1;
    }
};
```

