本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[961. 在长度 2N 的数组中找出重复 N 次的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/description/?envType=daily-question&envId=2026-01-02)

>标签：数组  |  哈希表

# 一、题目描述

## **问题概括**

给定一个长度为 `2 * n` 的整数数组 `nums`，它满足以下三个条件：

1. 数组包含 `n + 1` 个 **互不相同** 的元素。
2. 在这些元素中，**恰好有一个元素**重复出现了 `n` 次，其余 `n` 个元素各出现一次。
3. 数组长度是 `2 * n`。

您的任务是找出并返回那个重复了 `n` 次的元素。

## **示例说明**

- **示例1**：`nums = [1,2,3,3]`，`n=2`，元素 `3` 重复了 `2` 次，因此返回 `3`。
- **示例2**：`nums = [2,1,2,5,3,2]`，`n=3`，元素 `2` 重复了 `3` 次，因此返回 `2`。
- **示例3**：`nums = [5,1,5,2,5,3,5,4]`，`n=4`，元素 `5` 重复了 `4` 次，因此返回 `5`。

## **数据范围**

- `2 <= n <= 5000`
- `nums.length == 2 * n`
- `0 <= nums[i] <= 10^4`
- 输入保证满足上述条件。



# 二、解题思路\解题过程

这道题比较简单，我采用的是“桶排序”的思想，我的思路如下：
题目给出的数组的长度为“2n”，题目的意思就是找出数组中重复了“n”次的元素，而且该元素只有一个，另外，该元素重复次数在“2~5000”之间（包括2和5000），nums[]数组的长度为“0~10000”，那么我想的是创建一个长度为10001的int整数数组——newNums[]，然后遍历nums[]，给“newNums[nums[i]]++”，最后我们在遍历newNums[]数组，如果“newNums[i] * 2 = nums[].length”，那么我们就返回这个下标“i”即可！
代码如下：

```java
class Solution {
    public int repeatedNTimes(int[] nums) {
        int[] newNums = new int[10001];
        int n = nums.length, flag = 0;
        for(int i = 0; i < n; i++){
            newNums[nums[i]]++;
        }
        for(int i = 0; i < 10001; i++){
            if(newNums[i] * 2 == n){
                flag = i;
                break;
            }
        }
        return flag;
    }
}
```

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        cnn = len(nums)
        for i in nums:
            if nums.count(i) * 2 == cnn :
                return i
```

但是，我觉得这个代码的“执行时间”和“消耗内存”不是很好！于是我去看了题解，在看题解的过程中我又找到一道类似的题目，如下题所示！好，接下来言归正传，看题解中的思路（下面一段是引用哈！原链接：[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/solutions/3744717/on-mo-er-tou-piao-fa-yan-jin-zheng-ming-ww1zv/)，[961. 在长度 2N 的数组中找出重复 N 次的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/solutions/3870905/si-chong-fang-fa-ha-xi-ji-he-mo-er-tou-p-f95m/?envType=daily-question&envId=2026-01-02)）：

用「擂台赛」打比方：
1. 擂主登场：nums[0] 成为初始擂主，生命值为 1。
2. 挑战者出现：遍历后续元素，作为挑战者。
3. 比武：如果挑战者与擂主属于同一门派（值相同），那么擂主生命值加 1，否则擂主生命值减 1。
4. 擂主更迭：如果比武后，擂主生命值降为 0（同归于尽），那么下一个挑战者成为新的擂主，生命值为 1。
5. 最后在擂台上的那人，便是武林盟主（严格众数）。

为什么这样做是对的？
设出现次数最多的元素的出现次数为 a，其余元素的出现次数之和为 b = n − a。题目保证 a > b。

为了让出现 n 次的那个数变成绝对众数，我们可以分类讨论：

- 如果 nums[0] 在下标 [1,n−1] 中出现过，那么返回 nums[0]。
- 否则，去掉 nums[0]，剩下 2n−1 个数，出现次数为 n 的那个数变成绝对众数，可以用 169 题的算法解决。

这两件事情可以在同一个循环中完成。

代码如下：（目前“执行用时”和“消耗内存”最佳的思路！）
```C++
class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        int blood = 0, mode = 0, n = size(nums);
        for(int i = 1; i < n; i++){
            int flag = nums[i];
            if(flag == nums[0]){
                return flag;
            }
            if(blood == 0){
                mode = flag;
                blood = 1;
            } else {
                blood += flag == mode ? 1 : -1;
            }
        }
        return mode;
    }
};
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int repeatedNTimes(int[] nums) {
        int[] newNums = new int[10001];
        int n = nums.length, flag = 0;
        for(int i = 0; i < n; i++){
            newNums[nums[i]]++;
        }
        for(int i = 0; i < 10001; i++){
            if(newNums[i] * 2 == n){
                flag = i;
                break;
            }
        }
        return flag;
    }
}
```

![961_在长度 2N 的数组中找出重复 N 次的元素_力扣_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E6%95%B0%E7%BB%84/Images/961_%E5%9C%A8%E9%95%BF%E5%BA%A6%202N%20%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%20N%20%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0_Java.png)

## Python代码

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        cnn = len(nums)
        for i in nums:
            if nums.count(i) * 2 == cnn :
                return i
```

![961_在长度 2N 的数组中找出重复 N 次的元素_力扣_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E6%95%B0%E7%BB%84/Images/961_%E5%9C%A8%E9%95%BF%E5%BA%A6%202N%20%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%20N%20%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0_Python.png)

## C++代码

```C++
class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        int blood = 0, mode = 0, n = size(nums);
        for(int i = 1; i < n; i++){
            int flag = nums[i];
            if(flag == nums[0]){
                return flag;
            }
            if(blood == 0){
                mode = flag;
                blood = 1;
            } else {
                blood += flag == mode ? 1 : -1;
            }
        }
        return mode;
    }
};
```

![961_在长度 2N 的数组中找出重复 N 次的元素_力扣_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E6%95%B0%E7%BB%84/Images/961_%E5%9C%A8%E9%95%BF%E5%BA%A6%202N%20%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%20N%20%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0_C++.png)
