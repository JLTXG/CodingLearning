æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[3651. å¸¦ä¼ é€çš„æœ€å°è·¯å¾„æˆæœ¬ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-cost-path-with-teleportations/description/?envType=daily-question&envId=2026-01-28)

>æ ‡ç­¾ï¼šç½‘æ ¼å›¾DP  |  åç¼€æœ€å°å€¼ä¼˜åŒ–

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ª `m` è¡Œ `n` åˆ—çš„æ•´æ•°çŸ©é˜µ `grid`ï¼Œä»£è¡¨ä¸€ä¸ªç½‘æ ¼ã€‚ä½ çš„èµ·ç‚¹æ˜¯å·¦ä¸Šè§’å•å…ƒæ ¼ `(0,0)`ï¼Œç›®æ ‡æ˜¯åˆ°è¾¾å³ä¸‹è§’å•å…ƒæ ¼ `(m-1, n-1)`ã€‚ç§»åŠ¨è§„åˆ™å¦‚ä¸‹ï¼š

1. **æ™®é€šç§»åŠ¨**ï¼šå¯ä»¥ä»å½“å‰å•å…ƒæ ¼ `(i, j)` **å‘å³**ï¼ˆåˆ°è¾¾ `(i, j+1)`ï¼‰æˆ–**å‘ä¸‹**ï¼ˆåˆ°è¾¾ `(i+1, j)`ï¼‰ç§»åŠ¨ä¸€æ¬¡ã€‚è¿™ç§ç§»åŠ¨çš„æˆæœ¬ç­‰äºç›®æ ‡å•å…ƒæ ¼çš„å€¼ `grid[x][y]`ã€‚
2. **ä¼ é€ç§»åŠ¨**ï¼šå¯ä»¥ä»å½“å‰å•å…ƒæ ¼ `(i, j)` **å…è´¹**ä¼ é€åˆ°ä»»æ„ä¸€ä¸ªæ»¡è¶³æ¡ä»¶ `grid[x][y] <= grid[i][j]` çš„å•å…ƒæ ¼ `(x, y)`ï¼ˆå¯ä»¥ä¼ é€åˆ°ç½‘æ ¼å†…çš„ä»»æ„ä½ç½®ï¼ŒåŒ…æ‹¬å·²è®¿é—®è¿‡çš„å•å…ƒæ ¼ï¼‰ã€‚ä¼ é€ç§»åŠ¨çš„**æˆæœ¬ä¸º0**ã€‚æ•´ä¸ªè·¯å¾„ä¸­ï¼Œä¼ é€ç§»åŠ¨æœ€å¤šåªèƒ½ä½¿ç”¨ **k** æ¬¡ã€‚

ä½ çš„ä»»åŠ¡æ˜¯ï¼Œè®¾è®¡ä¸€æ¡ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„è·¯å¾„ï¼ˆå¯ä»¥æ··åˆä½¿ç”¨æ™®é€šç§»åŠ¨å’Œä¼ é€ç§»åŠ¨ï¼‰ï¼Œä½¿å¾—è·¯å¾„çš„**æ€»æˆæœ¬æœ€å°**ï¼ˆæ€»æˆæœ¬ä¸ºæ‰€æœ‰æ™®é€šç§»åŠ¨æ‰€äº§ç”Ÿçš„æˆæœ¬ä¹‹å’Œï¼Œä¼ é€æˆæœ¬ä¸è®¡ï¼‰ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼š`grid = [[1,3,3],[2,5,4],[4,3,5]], k = 2`ã€‚ä¸€ç§æœ€ä¼˜è·¯å¾„ä¸ºï¼šä» `(0,0)` å‘ä¸‹ç§»åŠ¨åˆ° `(1,0)`ï¼ˆæˆæœ¬+2ï¼‰ï¼Œå†å‘å³ç§»åŠ¨åˆ° `(1,1)`ï¼ˆæˆæœ¬+5ï¼‰ï¼Œæœ€åä½¿ç”¨ä¸€æ¬¡ä¼ é€ä» `(1,1)` ç§»åŠ¨åˆ° `(2,2)`ï¼ˆæ»¡è¶³æ¡ä»¶ä¸”å…è´¹ï¼‰ã€‚æ€»æˆæœ¬ä¸º `2+5=7`ã€‚
- **ç¤ºä¾‹2**ï¼š`grid = [[1,2],[2,3],[3,4]], k = 1`ã€‚ä½¿ç”¨ä¼ é€æ— æ³•æœ‰æ•ˆé™ä½æˆæœ¬ï¼Œæœ€ä¼˜è·¯å¾„ä¸ºè¿ç»­å‘ä¸‹å’Œå‘å³ç§»åŠ¨ï¼Œæ€»æˆæœ¬ä¸º `2+3+4=9`ã€‚

## **æ•°æ®èŒƒå›´**

- `2 <= m, n <= 80`
- `0 <= grid[i][j] <= 10^4`
- `0 <= k <= 10`



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## ğŸ”¹ è§£é¢˜æ€è·¯ï¼šåˆ†å±‚åŠ¨æ€è§„åˆ’ + å€¼åŸŸä¼˜åŒ–

### 1. **åˆ†å±‚ DPï¼ˆæŒ‰ä¼ é€æ¬¡æ•°åˆ†å±‚ï¼‰**

- è®¾ `t = 0, 1, ..., k` è¡¨ç¤º**æœ€å¤šä½¿ç”¨ `t` æ¬¡ä¼ é€**åçš„æœ€ä¼˜è§£ã€‚
- å¯¹æ¯ä¸€å±‚ `t`ï¼Œæˆ‘ä»¬è®¡ç®—ï¼šåœ¨ä½¿ç”¨ â‰¤ `t` æ¬¡ä¼ é€çš„å‰æä¸‹ï¼Œèµ°åˆ°æ¯ä¸ªä½ç½®çš„æœ€å°æˆæœ¬ã€‚

### 2. **çŠ¶æ€å‹ç¼©ï¼šåªè®°å½•æ¯åˆ—çš„æœ€å°æˆæœ¬ï¼ˆæ»šåŠ¨æ•°ç»„ï¼‰**

- å› ä¸ºåªèƒ½å‘å³/å‘ä¸‹èµ°ï¼Œå¯ä»¥ç”¨ä¸€ç»´æ•°ç»„ `f[j]` è¡¨ç¤ºå½“å‰è¡Œç¬¬ `j` åˆ—çš„æœ€å°æˆæœ¬ï¼ˆç©ºé—´ä¼˜åŒ–ï¼‰ã€‚

### 3. **å…³é”®ä¼˜åŒ–ï¼šæŒ‰â€œæ ¼å­å€¼â€èšåˆä¿¡æ¯**

- å®šä¹‰ `minF[x]`ï¼šåœ¨å½“å‰å±‚ `t` ä¸­ï¼Œ**æ‰€æœ‰å€¼ä¸º `x` çš„æ ¼å­çš„æœ€å° `f` å€¼**ã€‚
- è¿™æ ·ï¼Œä¸‹ä¸€å±‚ï¼ˆ`t+1`ï¼‰ä¸­ï¼Œå½“ä½ èµ°åˆ°ä¸€ä¸ªå€¼ä¸º `x` çš„æ ¼å­æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©ï¼š
    - **æ­£å¸¸èµ°è¿‡æ¥**ï¼š`min(å·¦, ä¸Š) + x`
    - **ä¼ é€è¿‡æ¥**ï¼šç›´æ¥ç»§æ‰¿ `minF[x]`ï¼ˆå› ä¸ºä¼ é€è½åœ°ä¸ä»˜è´¹ï¼ï¼‰

> ğŸ’¡ æ³¨æ„ï¼šè¿™é‡Œ `minF[x]` å°±æ˜¯â€œä¸Šä¸€è½®ä¸­ï¼Œå€¼ä¸º `x` çš„æ ¼å­çš„æœ€å°æˆæœ¬â€ï¼Œè€Œç”±äºä¼ é€ä¸ä»˜è´¹ï¼Œä¸‹ä¸€è½®å¯ä»¥ç›´æ¥ç”¨è¿™ä¸ªå€¼ä½œä¸ºèµ·ç‚¹ï¼

## ğŸ”¹ ç®—æ³•æµç¨‹æ€»ç»“

1. é¢„å¤„ç†ï¼šæ‰¾å‡ºç½‘æ ¼ä¸­æœ€å¤§å€¼ `mx`ã€‚
2. åˆå§‹åŒ– `sufMinF` ä¸ºæ— ç©·å¤§ï¼ˆç”¨äºç¬¬ 0 å±‚çš„ä¼ é€æ¥æºï¼‰ã€‚
3. è¿›è¡Œ `k+1` è½®è¿­ä»£ï¼ˆ`t = 0` åˆ° `k`ï¼‰ï¼š
    - æ¯è½®åšä¸€æ¬¡â€œæœ€å°è·¯å¾„å’Œâ€DPï¼ˆåªèƒ½å³/ä¸‹ï¼‰ï¼Œ
    - åŒæ—¶è®°å½• `minF[x]`ï¼šæœ¬è½®ä¸­å€¼ä¸º `x` çš„æœ€å°æˆæœ¬ï¼Œ
    - æ›´æ–° `sufMinF[x]` ä¸º `minF` çš„åç¼€æœ€å°å€¼ï¼ˆä¾›ä¸‹ä¸€è½®ä½¿ç”¨ï¼‰ã€‚
4. è¿”å› `f[n]`ï¼ˆå³æœ€åä¸€åˆ—çš„æœ€å°æˆæœ¬ï¼‰ã€‚

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
class Solution {
    public int minCost(int[][] grid, int k) {
        int n = grid[0].length; // åˆ—æ•°
        int mx = 0;
        // æ‰¾å‡º grid ä¸­çš„æœ€å¤§å€¼ï¼Œç”¨äºç¡®å®šå€¼åŸŸå¤§å°
        for (int[] row : grid) {
            for (int x : row) {
                mx = Math.max(mx, x);
            }
        }

        // sufMinF[x] = min{ minF[y] for y >= x }ï¼Œå³å€¼ >= x çš„æœ€å°æˆæœ¬
        // å¤§å°ä¸º mx+2ï¼Œé¿å…è¶Šç•Œï¼ˆsufMinF[mx+1] = INFï¼‰
        int[] sufMinF = new int[mx + 2];
        Arrays.fill(sufMinF, Integer.MAX_VALUE);
        
        // minF[x]ï¼šå½“å‰è½®æ¬¡ä¸­ï¼Œæ‰€æœ‰å€¼ä¸º x çš„æ ¼å­çš„æœ€å° dp å€¼
        int[] minF = new int[mx + 1];
        
        // f[j]ï¼šå½“å‰è¡Œç¬¬ j-1 åˆ—çš„æœ€å°æˆæœ¬ï¼ˆç©ºé—´ä¼˜åŒ–çš„ä¸€ç»´ DP æ•°ç»„ï¼‰
        int[] f = new int[n + 1];

        // è¿›è¡Œ k+1 è½® DPï¼ˆt=0 è¡¨ç¤ºä¸ç”¨ä¼ é€ï¼Œt=k è¡¨ç¤ºæœ€å¤šç”¨ k æ¬¡ï¼‰
        for (int t = 0; t <= k; t++) {
            // é‡ç½® minF ä¸ºæ— ç©·å¤§
            Arrays.fill(minF, Integer.MAX_VALUE);

            // åˆå§‹åŒ–å½“å‰è½®æ¬¡çš„ DP æ•°ç»„
            Arrays.fill(f, Integer.MAX_VALUE / 2); // é˜²æ­¢æº¢å‡º
            f[1] = -grid[0][0]; // èµ·ç‚¹è´¹ç”¨ä¸è®¡ï¼Œæ‰€ä»¥å…ˆå‡å»å®ƒï¼ˆåé¢åŠ å›æ¥ï¼‰

            // éå†æ¯ä¸€è¡Œ
            for (int[] row : grid) {
                // éå†æ¯ä¸€åˆ—
                for (int j = 0; j < n; j++) {
                    int x = row[j]; // å½“å‰æ ¼å­çš„å€¼
                    
                    // ä¸¤ç§æ–¹å¼åˆ°è¾¾ (i,j)ï¼š
                    // 1. æ­£å¸¸èµ°ï¼šä»å·¦è¾¹ f[j] æˆ–ä¸Šè¾¹ f[j+1] è½¬ç§»ï¼ŒåŠ ä¸Šå½“å‰è´¹ç”¨ x
                    // 2. ä¼ é€æ¥ï¼šä»ä¸Šä¸€è½®çš„ sufMinF[x] ç›´æ¥è·³è¿‡æ¥ï¼ˆä¸ä»˜è´¹ï¼ï¼‰
                    f[j + 1] = Math.min(
                        Math.min(f[j], f[j + 1]) + x,  // æ­£å¸¸èµ°
                        sufMinF[x]                      // ä¼ é€ï¼ˆè½åœ°ä¸ä»˜è´¹ï¼‰
                    );
                    
                    // æ›´æ–° minF[x]ï¼šè®°å½•å½“å‰è½®æ¬¡ä¸­å€¼ä¸º x çš„æœ€å°æˆæœ¬
                    if (f[j + 1] < minF[x]) {
                        minF[x] = f[j + 1];
                    }
                }
            }

            // è®¡ç®— minF çš„åç¼€æœ€å°å€¼ï¼Œä¾›ä¸‹ä¸€è½®ä½¿ç”¨
            // sufMinF[i] = min(minF[i], minF[i+1], ..., minF[mx])
            for (int i = mx; i >= 0; i--) {
                sufMinF[i] = Math.min(sufMinF[i + 1], minF[i]);
            }
        }

        // f[n] å³ä¸ºåˆ°è¾¾å³ä¸‹è§’çš„æœ€å°æˆæœ¬
        return f[n];
    }
}
```

![3651_å¸¦ä¼ é€çš„æœ€å°è·¯å¾„æˆæœ¬_Java]()

## Pythonä»£ç 

```Python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        n = len(grid[0])
        # æ‰¾æœ€å¤§å€¼
        mx = max(max(row) for row in grid)
        
        # sufMinF[x] = min{ minF[y] for y >= x }
        sufMinF = [float('inf')] * (mx + 2)
        # minF[x]: å½“å‰è½®æ¬¡ä¸­å€¼ä¸º x çš„æœ€å°æˆæœ¬
        minF = [0] * (mx + 1)
        # f[j]: å½“å‰è¡Œç¬¬ j-1 åˆ—çš„æœ€å°æˆæœ¬
        f = [0] * (n + 1)
        
        for t in range(k + 1):
            # é‡ç½® minF
            for i in range(mx + 1):
                minF[i] = float('inf')
            
            # åˆå§‹åŒ– f
            for i in range(n + 1):
                f[i] = float('inf')
            f[1] = -grid[0][0]  # èµ·ç‚¹è´¹ç”¨ä¸è®¡
            
            # åŠ¨æ€è§„åˆ’
            for row in grid:
                for j in range(n):
                    x = row[j]
                    # æ­£å¸¸èµ° vs ä¼ é€
                    normal = min(f[j], f[j + 1]) + x
                    teleport = sufMinF[x]
                    f[j + 1] = min(normal, teleport)
                    # æ›´æ–° minF
                    if f[j + 1] < minF[x]:
                        minF[x] = f[j + 1]
            
            # è®¡ç®—åç¼€æœ€å°å€¼
            sufMinF[mx + 1] = float('inf')
            for i in range(mx, -1, -1):
                sufMinF[i] = min(sufMinF[i + 1], minF[i])
        
        return f[n]
```



## C++ä»£ç 

```C++
class Solution {
public:
    int minCost(vector<vector<int>>& grid, int k) {
        int n = grid[0].size();
        int mx = 0;
        for (auto& row : grid)
            for (int x : row)
                mx = max(mx, x);
        
        // sufMinF[x] = min{ minF[y] for y >= x }
        vector<int> sufMinF(mx + 2, INT_MAX);
        vector<int> minF(mx + 1);
        vector<int> f(n + 1);
        
        for (int t = 0; t <= k; t++) {
            // é‡ç½® minF
            fill(minF.begin(), minF.end(), INT_MAX);
            
            // åˆå§‹åŒ– f
            fill(f.begin(), f.end(), INT_MAX / 2);
            f[1] = -grid[0][0]; // èµ·ç‚¹ä¸è®¡è´¹
            
            // DP
            for (auto& row : grid) {
                for (int j = 0; j < n; j++) {
                    int x = row[j];
                    int normal = min(f[j], f[j + 1]) + x;
                    int teleport = sufMinF[x];
                    f[j + 1] = min(normal, teleport);
                    if (f[j + 1] < minF[x])
                        minF[x] = f[j + 1];
                }
            }
            
            // åç¼€æœ€å°å€¼
            sufMinF[mx + 1] = INT_MAX;
            for (int i = mx; i >= 0; i--)
                sufMinF[i] = min(sufMinF[i + 1], minF[i]);
        }
        
        return f[n];
    }
};
```

