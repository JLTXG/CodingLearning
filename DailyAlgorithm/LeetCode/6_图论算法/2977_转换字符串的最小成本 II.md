æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[2977. è½¬æ¢å­—ç¬¦ä¸²çš„æœ€å°æˆæœ¬ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/?envType=daily-question&envId=2026-01-30)

>æ ‡ç­¾ï¼šå›¾  |  å­—å…¸æ ‘  |  æ•°ç»„  |  å­—ç¬¦ä¸²  |  åŠ¨æ€è§„åˆ’  |  æœ€çŸ­è·¯

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸¤ä¸ªé•¿åº¦ç›¸ç­‰çš„å­—ç¬¦ä¸² `source` å’Œ `target`ï¼Œä»¥åŠä¸€ç»„å­ä¸²æ›¿æ¢è§„åˆ™ï¼šæ¯ä¸ªè§„åˆ™ç”±åŸå­ä¸² `original[i]`ã€ç›®æ ‡å­ä¸² `changed[i]` å’Œå¯¹åº”çš„æ›¿æ¢æˆæœ¬ `cost[i]` ç»„æˆã€‚ä½ å¯ä»¥å¯¹ `source` è¿›è¡Œä»»æ„æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥é€‰æ‹©ä¸€ä¸ªå­ä¸²ï¼ˆè¦æ±‚ç­‰äºæŸä¸ª `original[i]`ï¼‰å¹¶å°†å…¶æ›¿æ¢ä¸ºå¯¹åº”çš„ `changed[i]`ï¼Œå¹¶æ”¯ä»˜ç›¸åº”æˆæœ¬ã€‚æ“ä½œå¿…é¡»æ»¡è¶³ï¼šä»»æ„ä¸¤æ¬¡æ“ä½œè¦ä¹ˆä½œç”¨åœ¨å®Œå…¨ä¸ç›¸äº¤çš„åŒºé—´ä¸Šï¼ˆå³ä¸€ä¸ªåŒºé—´çš„ç»“æŸä½ç½®ä¸¥æ ¼å°äºå¦ä¸€ä¸ªåŒºé—´çš„èµ·å§‹ä½ç½®ï¼‰ï¼Œè¦ä¹ˆä½œç”¨åœ¨å®Œå…¨ç›¸åŒçš„åŒºé—´ä¸Šï¼ˆèµ·å§‹å’Œç»“æŸä½ç½®å‡ç›¸åŒï¼‰ã€‚è¯·è®¡ç®—å°† `source` è½¬æ¢ä¸º `target` æ‰€éœ€çš„æœ€å°æ€»æˆæœ¬ï¼›å¦‚æœæ— æ³•å®Œæˆè½¬æ¢ï¼Œè¿”å› `-1`ã€‚

## **ç¤ºä¾‹æ ¸å¿ƒè¯´æ˜**

- **ç¤ºä¾‹1**ï¼šé€šè¿‡ä¸€ç³»åˆ—å•å­—ç¬¦å­ä¸²çš„æ›¿æ¢ï¼Œæ€»æˆæœ¬ä¸º28ã€‚

```
è¾“å…¥ï¼šsource = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
è¾“å‡ºï¼š28
```

- **ç¤ºä¾‹2**ï¼šé€šè¿‡æ›¿æ¢ä¸ç›¸äº¤æˆ–ç›¸åŒåŒºé—´çš„è¾ƒé•¿å­ä¸²ï¼Œæ€»æˆæœ¬ä¸º9ã€‚

```
è¾“å…¥ï¼šsource = "abcdefgh", target = "acdeeghh", original = ["bcd","fgh","thh"], changed = ["cde","thh","ghh"], cost = [1,3,5]
è¾“å‡ºï¼š9
```

- **ç¤ºä¾‹3**ï¼šç”±äºæ“ä½œåŒºé—´å†²çªï¼Œæ— æ³•å®Œæˆè½¬æ¢ï¼Œè¿”å›-1ã€‚

```
è¾“å…¥ï¼šsource = "abcdefgh", target = "addddddd", original = ["bcd","defgh"], changed = ["ddd","ddddd"], cost = [100,1578]
è¾“å‡ºï¼š-1
```

## **æ•°æ®èŒƒå›´**

- `1 <= source.length == target.length <= 1000`
- `1 <= cost.length == original.length == changed.length <= 100`
- `1 <= original[i].length == changed[i].length <= source.length`
- `1 <= cost[i] <= 10^6`



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## ğŸ§  é¢˜ç›®ç®€è¿°

ç»™å®šï¼š

- å­—ç¬¦ä¸² `source` å’Œ `target`ï¼ˆé•¿åº¦ç›¸åŒï¼‰
- ä¸€ç»„è½¬æ¢è§„åˆ™ï¼š`original[i] â†’ changed[i]`ï¼Œä»£ä»·ä¸º `cost[i]`

ç›®æ ‡ï¼š
å°† `source` å˜æˆ `target`ï¼Œæ¯æ¬¡æ“ä½œå¯å°†ä»»æ„å­ä¸²æ›¿æ¢ä¸ºå¦ä¸€ä¸ªå­ä¸²ï¼ˆå¿…é¡»åœ¨è§„åˆ™ä¸­å­˜åœ¨æˆ–å¯é€šè¿‡è§„åˆ™é—´æ¥è½¬æ¢ï¼‰ï¼Œæ±‚**æœ€å°æ€»ä»£ä»·**ã€‚è‹¥æ— æ³•å®Œæˆï¼Œè¿”å› `-1`ã€‚

> âš ï¸ æ³¨æ„ï¼š**å¯ä»¥å¤šæ¬¡ä½¿ç”¨è§„åˆ™ï¼Œä¸”å…è®¸ä¸­é—´å­—ç¬¦ä¸²ä¸åœ¨åŸå§‹è§„åˆ™ä¸­** â†’ è¿™æç¤ºæˆ‘ä»¬éœ€è¦**é¢„å¤„ç†æ‰€æœ‰å¯èƒ½çš„è½¬æ¢è·¯å¾„**ã€‚

------

## ğŸ”‘ æ ¸å¿ƒæ€è·¯ä¸‰æ­¥èµ°

### âœ… ç¬¬ä¸€æ­¥ï¼š**ç»Ÿä¸€å­—ç¬¦ä¸²è¡¨ç¤º â€”â€” ç”¨ Trie åˆ†é…å”¯ä¸€ ID**

- æ‰€æœ‰å‡ºç°åœ¨ `original` æˆ– `changed` ä¸­çš„å­—ç¬¦ä¸²éƒ½éœ€è¦è¢«â€œè¯†åˆ«â€ã€‚
- ç›´æ¥ç”¨ `Map<String, Integer>` ä¹Ÿå¯ä»¥ï¼Œä½†é¢˜ç›®å­—ç¬¦ä¸²å¯èƒ½å¾ˆé•¿ã€å¾ˆå¤šï¼Œ**Trie æ›´èŠ‚çœç©ºé—´ä¸”å¤©ç„¶æ”¯æŒå‰ç¼€åŒ¹é…**ï¼ˆä¸ºåç»­ DFS åšå‡†å¤‡ï¼‰ã€‚
- ä»£ç ä¸­ç”¨ `put(str)` å‡½æ•°å°†æ¯ä¸ªå­—ç¬¦ä¸²æ’å…¥ Trieï¼Œå¹¶åˆ†é…å…¨å±€å”¯ä¸€ `sid`ï¼ˆä» 0 å¼€å§‹é€’å¢ï¼‰ã€‚
- **ä¼˜ç‚¹**ï¼šåç»­åœ¨ DFS ä¸­éå† `source[i:]` å’Œ `target[i:]` çš„å…¬å…±å‰ç¼€æ—¶ï¼Œèƒ½**åŒæ­¥åœ¨ Trie ä¸­ä¸‹è¡Œ**ï¼Œå¿«é€Ÿåˆ¤æ–­å½“å‰å­ä¸²æ˜¯å¦â€œæœ‰æ„ä¹‰â€ï¼ˆå³æ˜¯å¦åœ¨è§„åˆ™é›†ä¸­å‡ºç°è¿‡ï¼‰ã€‚

> ğŸ’¡ å°æŠ€å·§ï¼š`sid` åˆå§‹ä¸º 0ï¼Œæ¯é‡åˆ°ä¸€ä¸ªæ–°å­—ç¬¦ä¸²å°± `sid++`ï¼Œæœ€ç»ˆæ€»èŠ‚ç‚¹æ•° â‰¤ `2 * m`ï¼ˆå› ä¸ºæœ€å¤š `m` ä¸ª original + `m` ä¸ª changedï¼‰ã€‚

------

### âœ… ç¬¬äºŒæ­¥ï¼š**æ„å»ºè½¬æ¢å›¾ + å…¨æºæœ€çŸ­è·¯ï¼ˆFloyd-Warshallï¼‰**

- æŠŠæ¯ä¸ªå­—ç¬¦ä¸²çœ‹ä½œå›¾ä¸­çš„ä¸€ä¸ª**èŠ‚ç‚¹**ï¼ˆID = `sid`ï¼‰ã€‚

- æ¯æ¡è§„åˆ™ `original[i] â†’ changed[i]` æ˜¯ä¸€æ¡**æœ‰å‘è¾¹**ï¼Œæƒé‡ä¸º `cost[i]`ã€‚

- ç”±äºå…è®¸**é—´æ¥è½¬æ¢**ï¼ˆå¦‚ Aâ†’B, Bâ†’C â‡’ Aâ†’Cï¼‰ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“**ä»»æ„ä¸¤ä¸ªå­—ç¬¦ä¸²ä¹‹é—´çš„æœ€å°è½¬æ¢ä»£ä»·**ã€‚

- ä½¿ç”¨ `Floyd-Warshall` ç®—æ³• è®¡ç®—æ‰€æœ‰ç‚¹å¯¹æœ€çŸ­è·¯å¾„ï¼š

    ```java
    for (k) for (i) for (j)
        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    ```

- åˆå§‹åŒ–æ—¶ï¼Œ`dis[i][i] = 0`ï¼Œå…¶ä½™ä¸º `INF`ï¼ˆä»£ç ä¸­ç”¨äº† `Integer.MAX_VALUE / 2` é˜²æº¢å‡ºï¼Œéå¸¸è§„èŒƒï¼ï¼‰ã€‚

------

### âœ… ç¬¬ä¸‰æ­¥ï¼š**åŠ¨æ€è§„åˆ’ï¼ˆDFS + è®°å¿†åŒ–ï¼‰åŒ¹é…è½¬æ¢**

- å®šä¹‰ `dfs(i)`ï¼šå°† `source[i..n-1]` è½¬æ¢ä¸º `target[i..n-1]` çš„æœ€å°ä»£ä»·ã€‚
- çŠ¶æ€è½¬ç§»ï¼š
    1. **è·³è¿‡å½“å‰å­—ç¬¦**ï¼šå¦‚æœ `s[i] == t[i]`ï¼Œåˆ™ `dfs(i) = dfs(i+1)`
    2. å°è¯•ä¸€æ®µæ›¿æ¢ï¼šä»ä½ç½®`i`å¼€å§‹ï¼Œæšä¸¾ç»“æŸä½ç½®`j`ï¼ˆ`j â‰¥ i`ï¼‰ï¼š
        - åœ¨ Trie ä¸­åŒæ­¥éå† `source[i..j]` å’Œ `target[i..j]`
        - å¦‚æœä¸¤è€…éƒ½å­˜åœ¨äº Trie ä¸­ï¼ˆå³ `p.sid >= 0 && q.sid >= 0`ï¼‰
        - ä¸”å­˜åœ¨è½¬æ¢è·¯å¾„ï¼ˆ`dis[p.sid][q.sid] < INF`ï¼‰
        - åˆ™æ›´æ–°ï¼š`dfs(i) = min(dfs(i), cost + dfs(j+1))`

> ğŸ” å…³é”®ä¼˜åŒ–ï¼š  
>
> - **Trie åŒæ­¥éå†**é¿å…äº†åå¤æˆªå–å­ä¸²ï¼ˆ`substring` å¼€é”€å¤§ï¼‰ï¼›
> - **æå‰ç»ˆæ­¢**ï¼šä¸€æ—¦ `p` æˆ– `q` ä¸º `null`ï¼Œè¯´æ˜å‰ç¼€ä¸å­˜åœ¨ï¼Œç›´æ¥ `break`ï¼›
> - **è®°å¿†åŒ–**é˜²æ­¢é‡å¤è®¡ç®—ï¼Œæ—¶é—´å¤æ‚åº¦å¯æ§ã€‚

------

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ­¥éª¤      | æ—¶é—´å¤æ‚åº¦                | è¯´æ˜                                              |
| --------- | ------------------------- | ------------------------------------------------- |
| Trie æ’å…¥ | O(L)                      | *L*= æ‰€æœ‰è§„åˆ™å­—ç¬¦ä¸²æ€»é•¿åº¦                         |
| Floyd     | O(k^3)                    | *k*= ä¸åŒå­—ç¬¦ä¸²æ•°é‡ï¼ˆâ‰¤ 2mï¼‰                       |
| DFS       | *O*(*n*â‹…min(*n*,max_len)) | `n = source.length()`ï¼Œæ¯å±‚æœ€å¤šéå†åˆ°æœ€é•¿è§„åˆ™é•¿åº¦ |

> å®é™…è¿è¡Œæ•ˆç‡å¾ˆé«˜ï¼Œå› ä¸ºï¼š
>
> - è§„åˆ™å­—ç¬¦ä¸²é•¿åº¦é€šå¸¸ä¸é•¿ï¼ˆé¢˜ç›®æœªé™ï¼Œä½†æµ‹è¯•æ•°æ®åˆç†ï¼‰
> - Trie å‰ªææ•ˆæœæ˜¾è‘—

------

## ğŸ§© æ˜“é”™ç‚¹ & ä»£ç äº®ç‚¹

### âœ… ä¼˜ç§€å®è·µï¼š

- `Integer.MAX_VALUE / 2` é˜²åŠ æ³•æº¢å‡º âœ”ï¸
- Trie èŠ‚ç‚¹å¤ç”¨ï¼ŒèŠ‚çœå†…å­˜ âœ”ï¸
- DFS ä¸­åŒæ­¥åŒæŒ‡é’ˆéå† source/target å­ä¸² âœ”ï¸
- è¾¹ç•Œå¤„ç†æ¸…æ™°ï¼ˆ`i >= s.length` è¿”å› 0ï¼‰âœ”ï¸

### âš ï¸ æ½œåœ¨æ³¨æ„ç‚¹ï¼š

- **Floyd å¾ªç¯ä¸Šç•Œåº”ä¸º `sid`ï¼Œä¸æ˜¯ `dis.length`**
    ä»£ç ä¸­å†™äº† `for (int k = 0; k < sid; k++)` â€”â€” **å®Œå…¨æ­£ç¡®ï¼**ï¼ˆå¾ˆå¤šäººè¯¯ç”¨ `dis.length` å¯¼è‡´ TLE æˆ–é”™è¯¯ï¼‰
- **Trie ä¸­æœªå‡ºç°çš„å­—ç¬¦ä¸² `sid = -1`ï¼Œåˆ¤æ–­æ¡ä»¶ `p.sid < 0` æ­£ç¡®**

------

## ğŸ“ ç¬”è®°æ€»ç»“

> **LeetCode 2977 è§£é¢˜æ¡†æ¶**
>
> 1. **å­—ç¬¦ä¸² ID åŒ–**ï¼šç”¨ Trie ç»™æ‰€æœ‰ `original/changed` ä¸­çš„å­—ç¬¦ä¸²åˆ†é…å”¯ä¸€ IDï¼Œä¾¿äºå»ºå›¾ã€‚
> 2. **å»ºè½¬æ¢å›¾ + å…¨æºæœ€çŸ­è·¯**ï¼šç”¨ Floyd-Warshall é¢„å¤„ç†ä»»æ„å­—ç¬¦ä¸²å¯¹çš„æœ€å°è½¬æ¢ä»£ä»·ã€‚
> 3. DP åŒ¹é…è½¬æ¢ï¼šä»å·¦åˆ°å³ DFSï¼Œå°è¯•ï¼š
>     - è·³è¿‡ç›¸åŒå­—ç¬¦ï¼›
>     - æšä¸¾å­ä¸²æ›¿æ¢ï¼ˆåˆ©ç”¨ Trie å¿«é€ŸéªŒè¯å­ä¸²æ˜¯å¦å­˜åœ¨ï¼ŒæŸ¥ Floyd è¡¨å¾—ä»£ä»·ï¼‰ã€‚
> 4. **å…³é”®ä¼˜åŒ–**ï¼šTrie åŒæ­¥éå†é¿å… substringï¼Œè®°å¿†åŒ–é˜²é‡å¤è®¡ç®—ã€‚

------

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
class Node {
    Node[] son = new Node[26]; // å­—æ¯ 'a'-'z'
    int sid = -1; // è¯¥èŠ‚ç‚¹ä»£è¡¨çš„å­—ç¬¦ä¸²åœ¨å›¾ä¸­çš„å”¯ä¸€ID
}

class Solution {
    private Node root = new Node();
    private int sid = 0; // å…¨å±€å­—ç¬¦ä¸²IDè®¡æ•°å™¨
    private char[] s, t;
    private int[][] dis; // è·ç¦»çŸ©é˜µï¼Œdis[i][j] è¡¨ç¤ºä»å­—ç¬¦ä¸²iå˜ä¸ºå­—ç¬¦ä¸²jçš„æœ€å°æˆæœ¬
    private long[] memo; // è®°å¿†åŒ–æ•°ç»„ï¼Œmemo[i] è¡¨ç¤ºä» source[i:] å˜ä¸º target[i:] çš„æœ€å°æˆæœ¬

    public long minimumCost(String source, String target, String[] original, String[] changed, int[] cost) {
        int m = cost.length;
        
        // 1. æ„å»ºå­—å…¸æ ‘ï¼Œå¹¶ç»™æ¯ä¸ªå‡ºç°çš„å­—ç¬¦ä¸²åˆ†é…å”¯ä¸€ID
        // åŒæ—¶åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
        dis = new int[m * 2][m * 2]; // æœ€å¤šå¯èƒ½æœ‰ 2*m ä¸ªä¸åŒå­—ç¬¦ä¸²
        for (int i = 0; i < dis.length; i++) {
            Arrays.fill(dis[i], Integer.MAX_VALUE / 2); // é˜²æ­¢æº¢å‡º
            dis[i][i] = 0;
        }

        // å¡«å……è¾¹ï¼šoriginal[i] -> changed[i]
        for (int i = 0; i < m; i++) {
            int x = put(original[i]); // è·å–æˆ–åˆ›å»º original[i] çš„ID
            int y = put(changed[i]);  // è·å–æˆ–åˆ›å»º changed[i] çš„ID
            dis[x][y] = Math.min(dis[x][y], cost[i]); // å¯èƒ½æœ‰é‡è¾¹ï¼Œå–æœ€å°
        }

        // 2. Floyd-Warshall ç®—æ³•æ±‚æ‰€æœ‰ç‚¹å¯¹æœ€çŸ­è·¯
        for (int k = 0; k < sid; k++) {
            for (int i = 0; i < sid; i++) {
                if (dis[i][k] == Integer.MAX_VALUE / 2) continue;
                for (int j = 0; j < sid; j++) {
                    dis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }

        // 3. å‡†å¤‡ DFS
        s = source.toCharArray();
        t = target.toCharArray();
        memo = new long[s.length];
        Arrays.fill(memo, -1);

        long ans = dfs(0);
        return ans < Long.MAX_VALUE / 2 ? ans : -1;
    }

    // è¾…åŠ©å‡½æ•°ï¼šå°†å­—ç¬¦ä¸² s æ’å…¥å­—å…¸æ ‘ï¼Œè¿”å›å…¶ ID
    private int put(String str) {
        Node o = root;
        for (char c : str.toCharArray()) {
            int idx = c - 'a';
            if (o.son[idx] == null) {
                o.son[idx] = new Node();
            }
            o = o.son[idx];
        }
        if (o.sid < 0) {
            o.sid = sid++; // åˆ†é…æ–°ID
        }
        return o.sid;
    }

    // DFS + è®°å¿†åŒ–ï¼šä»ä½ç½® i å¼€å§‹è½¬æ¢çš„æœ€å°æˆæœ¬
    private long dfs(int i) {
        if (i >= s.length) return 0; // ç»ˆæ­¢æ¡ä»¶
        if (memo[i] != -1) return memo[i];

        long res = Long.MAX_VALUE / 2;

        // æƒ…å†µ1ï¼šå½“å‰å­—ç¬¦ç›¸åŒï¼Œæ— éœ€æ“ä½œï¼Œç›´æ¥è·³è¿‡
        if (s[i] == t[i]) {
            res = dfs(i + 1);
        }

        // æƒ…å†µ2ï¼šå°è¯•ç”¨æ›¿æ¢æ“ä½œè¦†ç›–ä» i å¼€å§‹çš„ä¸€æ®µ
        Node p = root, q = root; // p éå† source å­ä¸²ï¼Œq éå† target å­ä¸²
        for (int j = i; j < s.length; j++) {
            p = p.son[s[j] - 'a'];
            q = q.son[t[j] - 'a'];
            
            // å¦‚æœå­—å…¸æ ‘ä¸­æ²¡æœ‰è¯¥å‰ç¼€ï¼Œç›´æ¥ç»ˆæ­¢
            if (p == null || q == null) break;
            
            // å¦‚æœå½“å‰å‰ç¼€æ²¡æœ‰å¯¹åº”çš„å­—ç¬¦ä¸²IDï¼ˆå³æœªåœ¨ original/changed ä¸­å‡ºç°ï¼‰ï¼Œè·³è¿‡
            if (p.sid < 0 || q.sid < 0) continue;

            // å°è¯•å°† source[i:j+1] æ›¿æ¢ä¸º target[i:j+1]
            // å‰ææ˜¯å­˜åœ¨è½¬æ¢è·¯å¾„ p.sid -> q.sid
            int d = dis[p.sid][q.sid];
            if (d < Integer.MAX_VALUE / 2) {
                res = Math.min(res, d + dfs(j + 1));
            }
        }
        return memo[i] = res;
    }
}
```

![2977_è½¬æ¢å­—ç¬¦ä¸²çš„æœ€å°æˆæœ¬ II_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/6_%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Images/2977_%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%20II_Java.png)

## Pythonä»£ç 

```Python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        # å­—å…¸æ ‘èŠ‚ç‚¹ç”¨å­—å…¸è¡¨ç¤º
        root = {}
        sid_map = {}  # å­—ç¬¦ä¸² -> ID æ˜ å°„
        next_id = 0

        def insert(s):
            nonlocal next_id
            node = root
            for c in s:
                if c not in node:
                    node[c] = {}
                node = node[c]
            # åœ¨èŠ‚ç‚¹æœ«å°¾æ ‡è®° ID
            if 'id' not in node:
                node['id'] = next_id
                next_id += 1
            return node['id']

        m = len(cost)
        # æ”¶é›†æ‰€æœ‰å­—ç¬¦ä¸²å¹¶åˆ†é… ID
        str_to_id = {}
        for s in original + changed:
            if s not in str_to_id:
                str_to_id[s] = insert(s)
        
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
        INF = 10**13
        dis = [[INF] * next_id for _ in range(next_id)]
        for i in range(next_id):
            dis[i][i] = 0

        # å¡«è¾¹
        for i in range(m):
            u = str_to_id[original[i]]
            v = str_to_id[changed[i]]
            dis[u][v] = min(dis[u][v], cost[i])

        # Floyd-Warshall
        for k in range(next_id):
            for i in range(next_id):
                if dis[i][k] == INF:
                    continue
                for j in range(next_id):
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])

        # DFS + è®°å¿†åŒ–
        n = len(source)
        memo = [-1] * n

        def dfs(i):
            if i >= n:
                return 0
            if memo[i] != -1:
                return memo[i]
            
            res = INF
            # æƒ…å†µ1ï¼šå­—ç¬¦ç›¸åŒï¼Œè·³è¿‡
            if source[i] == target[i]:
                res = dfs(i + 1)
            
            # æƒ…å†µ2ï¼šå°è¯•æ›¿æ¢ä¸€æ®µ
            node_src, node_tgt = root, root
            for j in range(i, n):
                c_src, c_tgt = source[j], target[j]
                if c_src not in node_src or c_tgt not in node_tgt:
                    break
                node_src = node_src[c_src]
                node_tgt = node_tgt[c_tgt]
                
                # æ£€æŸ¥æ˜¯å¦ä¸ºå®Œæ•´å­—ç¬¦ä¸²ï¼ˆæœ‰IDï¼‰
                if 'id' not in node_src or 'id' not in node_tgt:
                    continue
                
                id_src, id_tgt = node_src['id'], node_tgt['id']
                if dis[id_src][id_tgt] < INF:
                    res = min(res, dis[id_src][id_tgt] + dfs(j + 1))
            
            memo[i] = res
            return res

        ans = dfs(0)
        return ans if ans < INF else -1
```



## C++ä»£ç 

```C++
class Solution {
private:
    // å­—å…¸æ ‘èŠ‚ç‚¹
    struct Node {
        Node* son[26];
        int sid;
        Node() {
            for (int i = 0; i < 26; i++) son[i] = nullptr;
            sid = -1;
        }
    };

    Node* root;
    int sid;
    string s, t;
    vector<vector<long long>> dis; // ä½¿ç”¨ long long é˜²æ­¢æº¢å‡º
    vector<long long> memo;
    const long long INF = 1e13;

    // æ’å…¥å­—ç¬¦ä¸²å¹¶è¿”å›ID
    int put(const string& str) {
        Node* o = root;
        for (char c : str) {
            int i = c - 'a';
            if (o->son[i] == nullptr) {
                o->son[i] = new Node();
            }
            o = o->son[i];
        }
        if (o->sid == -1) {
            o->sid = sid++;
        }
        return o->sid;
    }

    long long dfs(int i) {
        if (i >= s.size()) return 0;
        if (memo[i] != -1) return memo[i];

        long long res = INF;

        // æƒ…å†µ1ï¼šå­—ç¬¦ç›¸åŒ
        if (s[i] == t[i]) {
            res = dfs(i + 1);
        }

        // æƒ…å†µ2ï¼šå°è¯•æ›¿æ¢ä¸€æ®µ
        Node* p = root;
        Node* q = root;
        for (int j = i; j < s.size(); j++) {
            int idx_s = s[j] - 'a';
            int idx_t = t[j] - 'a';
            if (p->son[idx_s] == nullptr || q->son[idx_t] == nullptr) {
                break;
            }
            p = p->son[idx_s];
            q = q->son[idx_t];

            if (p->sid == -1 || q->sid == -1) continue;

            long long d = dis[p->sid][q->sid];
            if (d < INF) {
                res = min(res, d + dfs(j + 1));
            }
        }
        return memo[i] = res;
    }

public:
    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {
        root = new Node();
        sid = 0;

        int m = cost.size();
        // é¢„ä¼°æœ€å¤§èŠ‚ç‚¹æ•°
        dis.assign(m * 2, vector<long long>(m * 2, INF));
        for (int i = 0; i < m * 2; i++) {
            dis[i][i] = 0;
        }

        // å»ºå›¾
        for (int i = 0; i < m; i++) {
            int x = put(original[i]);
            int y = put(changed[i]);
            dis[x][y] = min(dis[x][y], (long long)cost[i]);
        }

        // Floyd
        for (int k = 0; k < sid; k++) {
            for (int i = 0; i < sid; i++) {
                if (dis[i][k] == INF) continue;
                for (int j = 0; j < sid; j++) {
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }

        s = source;
        t = target;
        memo.assign(s.size(), -1);

        long long ans = dfs(0);
        return ans < INF ? ans : -1;
    }
};
```

