本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3650. 边反转的最小路径总成本 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/description/?envType=daily-question&envId=2026-01-27)

>标签：图  |  最短路  |  堆（优先队列）

# 一、题目描述

## **问题概括**

给定一个包含 `n` 个节点的有向带权图，节点编号为 `0` 到 `n-1`。边的信息通过数组 `edges` 给出，其中每条边由 `[起点, 终点, 权重]` 表示。每个节点配有一个**最多只能使用一次**的特殊开关：当你**首次**到达该节点时，可以选择将其**任意一条入边**（即原本指向该节点的边）进行**瞬时反转**（变为从该节点指向原起点），并**立即**沿着这条反转后的边移动到下一个节点。反转操作的成本为原边权重的**两倍**。

你的目标是：从节点 `0` 出发，到达节点 `n-1`，并使得路径的总成本（包括正常经过边的成本和使用反转边所产生的双倍成本）**最小**。如果无法到达终点，则返回 `-1`。

## **示例说明**

- **示例1**： `n = 4`, `edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]`。
    一种最优路径：

    1. 从 0 正常走到 1，成本 3。
    2. 在节点 1 使用开关，将原本从 3 指向 1 的边反转为从 1 指向 3，并立即走过，成本为 `2 * 1 = 2`。
        总成本 = 3 + 2 = 5。

    ![3650_边反转的最小路径总成本_示例1]()

- **示例2**： `n = 4`, `edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]`。
    最优路径不需要使用反转：0 → 2 (成本1) → 1 (成本1) → 3 (成本1)，总成本 = 3。

## **数据范围**

- `2 <= n <= 5 * 10^4`
- `1 <= edges.length <= 10^5`
- `0 <= 起点, 终点 <= n - 1`
- `1 <= 权重 <= 1000`



# 二、解题思路\解题过程

这是今天的“每日一题”，我们可以采用`Dijkstra算法`来进行求解！相关算法知识和代码求解如下！

## Dijkstra算法笔记
### **基本设定**

- 图用邻接矩阵 `g[i][j]` 表示：
    - `g[i][j]`：节点 `i` 到 `j` 的边权；
    - 若无边，则 `g[i][j] = ∞`。
- `dis[i]`：从起点 `k` 到节点 `i` 的最短路径长度。
    - 初始化：`dis[k] = 0`，其余 `dis[i] = ∞`。

### **核心思想**

1. 每次从未确定最短路的节点中，选出当前 `dis` 值最小的节点 `u`。
2. **关键性质**（无负权边）：
    - 此时 `dis[u]` 已是最短路径，不可能再被更新（可用反证法证明）。
3. 用 `u` 更新其所有邻居 `y`：
    - 若 `dis[u] + g[u][y] < dis[y]`，则更新 `dis[y]`。

重复上述过程，直到所有可达节点的最短路都确定。

---

### **两种实现方式**

#### **1. 朴素 Dijkstra（适合稠密图）**

- **适用场景**：边数接近 (O(n^2)) 的图。
- **做法**：
    - 每次遍历所有未确定节点，找 `dis` 最小者。
    - 用该节点松弛其邻居。
- **提前终止**：
    - 若当前最小 `dis[i] == ∞`，说明剩余节点不可达，可提前结束。
- **返回值**（依题意）：
    - 若所有点可达，返回 `max(dis)`；
    - 否则返回 `-1`。
- **复杂度**：
    - 时间：(O(n^2))
    - 空间：(O(n^2))（邻接矩阵）

> 注：节点编号建议从 0 开始。

```Java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        final int INF = Integer.MAX_VALUE / 2; // 防止加法溢出
        int[][] g = new int[n][n]; // 邻接矩阵
        for (int[] row : g) {
            Arrays.fill(row, INF);
        }
        for (int[] t : times) {
            g[t[0] - 1][t[1] - 1] = t[2];
        }

        int maxDis = 0;
        int[] dis = new int[n];
        Arrays.fill(dis, INF);
        dis[k - 1] = 0;
        boolean[] done = new boolean[n];
        while (true) {
            int x = -1;
            for (int i = 0; i < n; i++) {
                if (!done[i] && (x < 0 || dis[i] < dis[x])) {
                    x = i;
                }
            }
            if (x < 0) {
                return maxDis; // 最后一次算出的最短路就是最大的
            }
            if (dis[x] == INF) { // 有节点无法到达
                return -1;
            }
            maxDis = dis[x]; // 求出的最短路会越来越大
            done[x] = true; // 最短路长度已确定（无法变得更小）
            for (int y = 0; y < n; y++) {
                // 更新 x 的邻居的最短路
                dis[y] = Math.min(dis[y], dis[x] + g[x][y]);
            }
        }
    }
}
```

---

#### **2. 堆优化 Dijkstra（适合稀疏图）**

- **适用场景**：边数远小于 (n^2)（如 (O(n)) 或 (O(n \log n))）。
- **优化点**：
    - 用**最小堆（优先队列）** 快速取出当前 `dis` 最小的节点。
- **流程**：
    1. 起始时将 `(0, k)` 入堆。
    2. 每次弹出堆顶 `(dx, x)`：
        - 若 `dx > dis[x]`，说明 `x` 已被更优路径处理过，**跳过**（避免重复松弛）。
        - 否则，用 `x` 松弛其邻居，并将新 `dis[y]` 入堆。
- **无需 `done` 数组**，靠 `dx > dis[x]` 判断是否已处理。

> ✅ **为什么判断 `dx > dis[x]`？**  
> 因为同一个节点可能多次入堆（每次 `dis[x]` 更新就入堆一次）。只有第一次出堆时 `dx == dis[x]` 是有效的；后续更大的 `dx` 出堆时，`dis[x]` 已更小，无需再处理。

- **复杂度**：
    - 时间：(O((n + m) \log n))，其中 (m) 为边数
    - 空间：(O(n + m))（可用邻接表存储）

```Java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        List<int[]>[] g = new ArrayList[n]; // 邻接表
        Arrays.setAll(g, i -> new ArrayList<>());
        for (int[] t : times) {
            g[t[0] - 1].add(new int[]{t[1] - 1, t[2]});
        }

        int maxDis = 0;
        int left = n; // 未确定最短路的节点个数
        int[] dis = new int[n];
        Arrays.fill(dis, Integer.MAX_VALUE);
        dis[k - 1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));
        pq.offer(new int[]{0, k - 1});
        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int dx = p[0];
            int x = p[1];
            if (dx > dis[x]) { // x 之前出堆过
                continue;
            }
            maxDis = dx; // 求出的最短路会越来越大
            left--;
            for (int[] e : g[x]) {
                int y = e[0];
                int newDis = dx + e[1];
                if (newDis < dis[y]) {
                    dis[y] = newDis; // 更新 x 的邻居的最短路
                    pq.offer(new int[]{newDis, y});
                }
            }
        }
        return left == 0 ? maxDis : -1;
    }
}
```

---

### **关键前提**

- **图中不能有负权边**！否则 Dijkstra 不成立（无法保证首次出堆即最短）。

---

## 本道题目的解题展示

根据`Dijkstra算法`，我们只会去访问一次节点（同一个），如果我们需要反向去访问的话，只需要将对应的边的边权乘以2即可！最终代码如下！

```java
class Solution {
    public int minCost(int n, int[][] edges) {
        // 1. 构建邻接表：g[i] 存储所有从节点 i 出发的边，每条边是 [邻居节点, 边权]
        List<int[]>[] g = new ArrayList[n];
        Arrays.setAll(g, _ -> new ArrayList<>());  // 初始化每个节点的邻接列表

        // 2. 遍历输入的边，构建无向图（但注意：两个方向权重不同）
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int wt = e[2];
            // 从 x 到 y 的边权是 wt
            g[x].add(new int[]{y, wt});
            // 从 y 到 x 的边权是 wt * 2（题目特殊规则）
            g[y].add(new int[]{x, wt * 2});
        }

        // 3. 初始化最短距离数组 dis，起点为 0
        int[] dis = new int[n];
        Arrays.fill(dis, Integer.MAX_VALUE);  // 所有节点初始距离设为无穷大
        dis[0] = 0;  // 起点到自己的距离为 0

        // 4. 使用最小堆（优先队列）优化 Dijkstra
        // 堆中元素是 [当前距离, 节点编号]，按距离从小到大排序
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, 0});  // 起点入堆

        // 5. Dijkstra 主循环
        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int disX = p[0];  // 当前弹出的距离
            int x = p[1];  // 当前弹出的节点

            // 6. 懒删除：如果这个距离已经过时（比已知最短距离还大），跳过
            if (disX > dis[x]) {
                continue;
            }

            // 7. 如果到达终点（n-1 号节点），直接返回答案（因为第一次到达就是最短路）
            if (x == n - 1) {
                return disX;
            }

            // 8. 遍历 x 的所有邻居，尝试松弛
            for (int[] e : g[x]) {
                int y = e[0];  // 邻居节点
                int wt = e[1];  // x → y 的边权
                int newDisY = disX + wt;  // 经过 x 到 y 的新距离

                // 9. 如果找到更短路径，更新并入堆
                if (newDisY < dis[y]) {
                    dis[y] = newDisY;
                    pq.offer(new int[]{newDisY, y});  // 入堆（可能重复，但没关系）
                }
            }
        }

        // 10. 如果堆空了还没到达终点，说明不可达
        return -1;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int minCost(int n, int[][] edges) {
        // 1. 构建邻接表：g[i] 存储所有从节点 i 出发的边，每条边是 [邻居节点, 边权]
        List<int[]>[] g = new ArrayList[n];
        Arrays.setAll(g, _ -> new ArrayList<>());  // 初始化每个节点的邻接列表

        // 2. 遍历输入的边，构建无向图（但注意：两个方向权重不同）
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int wt = e[2];
            // 从 x 到 y 的边权是 wt
            g[x].add(new int[]{y, wt});
            // 从 y 到 x 的边权是 wt * 2（题目特殊规则）
            g[y].add(new int[]{x, wt * 2});
        }

        // 3. 初始化最短距离数组 dis，起点为 0
        int[] dis = new int[n];
        Arrays.fill(dis, Integer.MAX_VALUE);  // 所有节点初始距离设为无穷大
        dis[0] = 0;  // 起点到自己的距离为 0

        // 4. 使用最小堆（优先队列）优化 Dijkstra
        // 堆中元素是 [当前距离, 节点编号]，按距离从小到大排序
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, 0});  // 起点入堆

        // 5. Dijkstra 主循环
        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int disX = p[0];  // 当前弹出的距离
            int x = p[1];  // 当前弹出的节点

            // 6. 懒删除：如果这个距离已经过时（比已知最短距离还大），跳过
            if (disX > dis[x]) {
                continue;
            }

            // 7. 如果到达终点（n-1 号节点），直接返回答案（因为第一次到达就是最短路）
            if (x == n - 1) {
                return disX;
            }

            // 8. 遍历 x 的所有邻居，尝试松弛
            for (int[] e : g[x]) {
                int y = e[0];  // 邻居节点
                int wt = e[1];  // x → y 的边权
                int newDisY = disX + wt;  // 经过 x 到 y 的新距离

                // 9. 如果找到更短路径，更新并入堆
                if (newDisY < dis[y]) {
                    dis[y] = newDisY;
                    pq.offer(new int[]{newDisY, y});  // 入堆（可能重复，但没关系）
                }
            }
        }

        // 10. 如果堆空了还没到达终点，说明不可达
        return -1;
    }
}
```



## Python代码

```Python
class Solution:
    def minCost(self, n: int, edges: List[List[int]]) -> int:
        # 1. 构建邻接表
        g = [[] for _ in range(n)]
        for x, y, wt in edges:
            g[x].append((y, wt))
            g[y].append((x, wt * 2))  # 反向边权重翻倍

        # 2. 初始化距离数组
        dis = [float("inf")] * n
        dis[0] = 0

        # 3. 最小堆：(distance, node)
        heap = [(0, 0)]

        while heap:
            disX, x = heapq.heappop(heap)

            # 懒删除：跳过过期数据
            if disX > dis[x]:
                continue
            
            # 到达终点
            if x == n - 1:
                return disX
            
            # 松弛所有邻居
            for y, wt in g[x]:
                new_dis_y = disX + wt
                if new_dis_y < dis[y]:
                    dis[y] = new_dis_y
                    heapq.heappush(heap, (new_dis_y, y))
        
        return -1
```

![3650_边反转的最小路径总成本_Python]()

## C++代码

```C++
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        // 1. 邻接表：g[i] = vector of {neighbor, weight}
        vector<vector<pair<int, int>>> g(n);
        for (auto& e : edges) {
            int x = e[0], y = e[1], wt = e[2];
            g[x].push_back({y, wt});
            g[y].push_back({x, wt * 2});
        }

        // 2. 最短距离数组
        vector<int> dis(n, INT_MAX);
        dis[0] = 0;

        // 3. 最小堆：{distance, node}
        // 注意：C++ 默认是最大堆，所以用 greater 或负号；这里用 greater
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});

        while (!pq.empty()) {
            auto [disX, x] = pq.top();
            pq.pop();

            // 懒删除
            if (disX > dis[x]) continue;

            // 到达终点
            if (x == n - 1) return disX;

            // 松弛邻居
            for (auto [y, wt] : g[x]) {
                int newDisY = disX + wt;
                if (newDisY < dis[y]) {
                    dis[y] = newDisY;
                    pq.push({newDisY, y});
                }
            }
        }

        return -1;
    }
};
```

