本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[799. 香槟塔 - 力扣（LeetCode）](https://leetcode.cn/problems/champagne-tower/description/?envType=daily-question&envId=2026-02-14)

>标签：动态规划

# 一、题目描述

## **问题概括**

有一个由玻璃杯组成的金字塔，从上到下第 `0` 层有 1 个杯子，第 1 层有 2 个，第 2 层有 3 个，依此类推，共 100 层。每个杯子容量相同（假设为 1 单位）。从顶层（第 0 层第 0 个）开始倾倒 `poured` 杯香槟。当某个杯子满了之后，溢出的香槟会等量地流向它正下方左右两侧的两个杯子（即下一层的相邻两个杯子）。如果下一层的杯子也满了，继续向下溢出，以此类推，直到最底层（第 99 层）溢出到地板。

给定 `poured` 以及需要查询的杯子位置 `query_row` 和 `query_glass`（行和列均从 0 开始），返回该杯子中最终所盛香槟占其容量的比例（即香槟体积除以杯子容量）。结果以浮点数表示，误差在 `10^-5` 内视为正确。

## **示例说明**

- 输入 `poured = 1, query_row = 1, query_glass = 1`：顶层倒 1 杯后刚好满，无溢出，所以第二层杯子为空，输出 0.00000。
- 输入 `poured = 2, query_row = 1, query_glass = 1`：顶层倒 2 杯，顶层满后溢出 1 杯，这 1 杯平均分给第二层的两个杯子，每个得到 0.5 杯，因此第二层第 1 个杯子（即右侧）有 0.5，输出 0.50000。
- 输入 `poured = 100000009, query_row = 33, query_glass = 17`：大量香槟导致杯子满，输出 1.00000。

## **数据范围**

- `0 <= poured <= 10^9`
- `0 <= query_glass <= query_row < 100`



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```java
class Solution {
    public double champagneTower(int poured, int queryRow, int queryGlass) {
        // cur 表示当前行每个杯子中的香槟量（初始只有第0行）
        // 第0行只有1个杯子，倒入全部 poured 杯
        double[] cur = new double[]{(double) poured};

        // 从第1行开始，逐层向下模拟，直到目标行 queryRow
        for (int i = 1; i <= queryRow; i++) {
            // 下一行有 i+1 个杯子（第 i 行索引为 0~i）
            double[] nxt = new double[i + 1];

            // 遍历当前行的每一个杯子
            for (int j = 0; j < cur.length; j++) {
                // 当前杯子中超出容量的部分（>1 的部分才会溢出）
                double overflow = cur[j] - 1;

                // 只有当 overflow > 0 时，才会流向下一层
                if (overflow > 0) {
                    // 溢出的香槟平均分给下一层的两个相邻杯子
                    nxt[j]     += overflow / 2.0;   // 左下
                    nxt[j + 1] += overflow / 2.0;   // 右下
                }
            }

            // 滚动数组：当前行变为下一行，继续下一轮模拟
            cur = nxt;
        }

        // 最终，目标杯子的香槟量不能超过 1（杯子容量上限）
        return Math.min(cur[queryGlass], 1.0);
    }
}
```

---

## 🧠 核心解题思想分析

### 🔍 问题建模

- 香槟塔是一个**三角形结构**：
  
    ```
    Row 0:        [0]
    Row 1:      [0] [1]
    Row 2:    [0] [1] [2]
    ...
    ```
    
- 每个杯子 `(i, j)` 的溢出会流向：
    - `(i+1, j)`（左下）
    - `(i+1, j+1)`（右下）

> ✅ 这类似于**杨辉三角**的依赖关系，但值是“溢出量”而非组合数。

---

### 💡 核心思想：**逐层模拟 + 滚动数组优化**

#### 1. **自顶向下模拟**

- 从第 0 行开始，逐层计算每一行每个杯子的香槟量；
- 对于每个杯子，若其内容 > 1，则将 **(content - 1)** 平均分给下一层两个子杯。

#### 2. **只维护当前行（滚动数组）**

- 不需要存储整个三角形（O(n²) 空间）；
- 只需保存**上一行**的结果，即可计算**当前行**；
- 空间优化至 O(n)，其中 n = queryRow。

#### 3. **最终结果截断**

- 即使模拟得到某杯有 1.5 杯香槟，实际它只能装 1 杯；
- 所以返回 `min(value, 1.0)`

---

### 🌰 举例说明

假设 `poured = 4`, `queryRow = 2`, `queryGlass = 1`

**第0行**：`[4.0]`  
→ 溢出 `3.0` → 下一层各得 `1.5`

**第1行**：`[1.5, 1.5]`  
→ 每个溢出 `0.5` →

- 第一个杯子：下一层 [0] += 0.25, [1] += 0.25
- 第二个杯子：下一层 [1] += 0.25, [2] += 0.25

**第2行**：`[0.25, 0.5, 0.25]`

查询 `(2,1)` → `0.5` ✅

---

### ⏱️ 复杂度分析：

- **时间复杂度**：O(queryRow²)  
    —— 第 i 行有 i 个元素，总操作 ≈ 1+2+...+queryRow = O(R²)
- **空间复杂度**：O(queryRow)  
    —— 使用滚动数组，只存两行（实际只存一行）

> 💡 对于 `queryRow ≤ 100`，完全高效！

---

## 📚 笔记总结

### 🧩 问题定义：

向顶部倒 `poured` 杯香槟，每杯容量为 1，溢出部分平均流向下一层左右两杯。  
求第 `queryRow` 行、第 `queryGlass` 列的杯子中最终香槟量（≤1）。

### 💡 核心思想：

> **逐层模拟溢出 + 滚动数组优化**

### ✅ 算法步骤：

1. 初始化第 0 行：`cur = [poured]`
2. 对于第 1 行到 `queryRow`：
    - 创建新数组 `nxt`（长度 = 行号 + 1）
    - 遍历 `cur` 中每个杯子：
        - 若 `cur[j] > 1`，则溢出 `overflow = cur[j] - 1`
        - 将 `overflow/2` 加到 `nxt[j]` 和 `nxt[j+1]`
    - `cur = nxt`
3. 返回 `min(cur[queryGlass], 1.0)`

### 🔑 关键技巧：

- **不模拟未溢出的杯子**（`overflow ≤ 0` 时跳过）；
- **滚动数组**避免 O(n²) 空间；
- **最终结果必须与 1 取最小值**（杯子容量限制）。

### ⏱️ 复杂度：

- 时间：O(R²)，R = queryRow
- 空间：O(R)

### 💡 类比：

- 类似 **杨辉三角** 的递推结构；
- 也像 **水流扩散模拟** 或 **概率分布传播**。

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        // cur 表示当前行每个杯子中的香槟量（初始只有第0行）
        // 第0行只有1个杯子，倒入全部 poured 杯
        double[] cur = new double[]{(double) poured};

        // 从第1行开始，逐层向下模拟，直到目标行 queryRow
        for (int i = 1; i <= query_row; i++) {
            // 下一行有 i+1 个杯子（第 i 行索引为 0~i）
            double[] nxt = new double[i + 1];

            // 遍历当前行的每一个杯子
            for (int j = 0; j < cur.length; j++) {
                // 当前杯子中超出容量的部分（>1 的部分才会溢出）
                double overflow = cur[j] - 1;

                // 只有当 overflow > 0 时，才会流向下一层
                if (overflow > 0) {
                    // 溢出的香槟平均分给下一局的两个相邻杯子
                    nxt[j] += overflow / 2.0;  // 左下
                    nxt[j + 1] += overflow / 2.0;  // 右下
                }
            }

            // 滚动数组：当前行变为下一行，继续下一轮模拟
            cur = nxt;
        }

        // 最终，目标杯子的香槟量不能超过 1（杯子容量上限）
        return Math.min(cur[query_glass], 1.0);
    }
}
```

![799_香槟塔_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/799_%E9%A6%99%E6%A7%9F%E5%A1%94_Java.png)

## Python代码

```Python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # cur 表示当前行的香槟量，初始为第0行
        cur = [float(poured)]
        
        # 从第1行模拟到 query_row
        for i in range(1, query_row + 1):
            # 下一行有 i+1 个杯子
            nxt = [0.0] * (i + 1)
            
            # 遍历当前行每个杯子
            for j in range(len(cur)):
                overflow = cur[j] - 1.0
                if overflow > 0:
                    nxt[j] += overflow / 2.0
                    nxt[j + 1] += overflow / 2.0
            
            cur = nxt  # 滚动数组：更新当前行为下一行
        
        # 返回目标杯子的香槟量，最多为1
        return min(cur[query_glass], 1.0)       
```



## C++代码

```C++
class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
        // cur 表示当前行的香槟量，初始为第0行
        vector<double> cur = {(double)poured};
        
        // 从第1行模拟到 query_row
        for (int i = 1; i <= query_row; i++) {
            // 下一行有 i+1 个杯子
            vector<double> nxt(i + 1, 0.0);
            
            // 遍历当前行每个杯子
            for (int j = 0; j < cur.size(); j++) {
                double overflow = cur[j] - 1.0;
                if (overflow > 0) {
                    nxt[j] += overflow / 2.0;
                    nxt[j + 1] += overflow / 2.0;
                }
            }
            
            cur = nxt; // 滚动数组：更新当前行为下一行
        }
        
        // 返回目标杯子的香槟量，最多为1
        return min(cur[query_glass], 1.0);
    }
};
```

