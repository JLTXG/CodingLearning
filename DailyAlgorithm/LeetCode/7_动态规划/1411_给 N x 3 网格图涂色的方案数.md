本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1411. 给 N x 3 网格图涂色的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/?envType=daily-question&envId=2026-01-03)

>标签：动态规划

# 一、题目描述

## **问题概括**

给定一个 `n` 行 3 列的网格。你需要使用红、黄、绿三种颜色之一为每个格子涂色，并满足以下限制：任何两个具有**公共边**（即水平相邻或垂直相邻）的格子，它们的颜色必须不同。

请你计算满足条件的涂色方案总数。由于结果可能非常大，请将答案对 `10^9 + 7` 取模后返回。

## **示例说明**

- **示例1**：`n = 1`（即一行三列的网格），共有 `12` 种合法的涂色方案。

    ![1411_给 N x 3 网格图涂色的方案数](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/1411_%E7%BB%99%20N%20x%203%20%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0.png)

- **示例2**：`n = 2`，输出 `54`。

- **示例3**：`n = 3`，输出 `246`。

- 更大地示例（如 `n = 5000`）也需在高效算法下求解。

## **数据范围**

- `n` 是网格的行数，满足 `1 <= n <= 5000`。



# 二、解题思路\解题过程

这道题是一道困难题，但是这道题可以通过找规律的方式进行求解，话不多说，下述图片是对应的规律寻找过程：

![1411_给 N x 3 网格图涂色的方案数_思路图解](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/1411_%E7%BB%99%20N%20x%203%20%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0_%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3.jpg)

代码如下：

```java
class Solution {
    public int numOfWays(int n) {
        //  n = 1 的情况
        long twoColor = 6, threeColor = 6, sum = 0, mod = 1000000007l;
        //  n >= 2的情况
        for(int i = 2; i <= n; i++){
            long currentTwo = twoColor, currentThree = threeColor;
            twoColor = (currentTwo * 3 + currentThree * 2) % mod;
            threeColor = (currentTwo * 2 + currentThree * 2) % mod;
        }
        return (int)((twoColor + threeColor) % mod);
    }
}
```

# 三、代码演示

## Java代码

```java
class Solution {
    public int numOfWays(int n) {
        //  n = 1 的情况
        long twoColor = 6, threeColor = 6, mod = 1000000007l;
        //  n >= 2的情况
        for(int i = 2; i <= n; i++){
            long currentTwo = twoColor, currentThree = threeColor;
            twoColor = (currentTwo * 3 + currentThree * 2) % mod;
            threeColor = (currentTwo * 2 + currentThree * 2) % mod;
        }
        return (int)((twoColor + threeColor) % mod);
    }
}
```



## Python代码

```Python
class Solution:
    def numOfWays(self, n: int) -> int:
        two_color, three_color, mod = 6, 6, 1000000007
        for i in range(2, n + 1, 1):
            current_two, current_three = two_color, three_color
            two_color = (current_two * 3 + current_three * 2) % mod
            three_color = (current_two * 2 + current_three * 2) % mod
        return ((two_color + three_color) % mod)
```

![1411_给 N x 3 网格图涂色的方案数_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/1411_%E7%BB%99%20N%20x%203%20%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0_Python.png)

## C++代码

```C++
class Solution {
public:
    int numOfWays(int n) {
        //  n = 1 的情况
        long twoColor = 6, threeColor = 6, mod = 1000000007l;
        //  n >= 2 的情况
        for(int i = 2; i <= n; i++){
            long currentTwo = twoColor, currentThree = threeColor;
            twoColor = (currentTwo * 3 + currentThree * 2) % mod;
            threeColor = (currentTwo * 2 + currentThree * 2) % mod;
        }
        return (int)((twoColor + threeColor) % mod);
    }
};
```

![1411_给 N x 3 网格图涂色的方案数_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/1411_%E7%BB%99%20N%20x%203%20%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0_C++.png)
