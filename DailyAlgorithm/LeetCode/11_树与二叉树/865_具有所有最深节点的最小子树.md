[865. å…·æœ‰æ‰€æœ‰æœ€æ·±èŠ‚ç‚¹çš„æœ€å°å­æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/description/?envType=daily-question&envId=2026-01-09)

>æ ‡ç­¾ï¼šæ ‘  |  æ·±åº¦ä¼˜å…ˆæœç´¢  |  å¹¿åº¦ä¼˜å…ˆæœç´¢  |  å“ˆå¸Œè¡¨  |  äºŒå‰æ ‘

# ä¸€ã€é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªæ ¹ä¸º `root` çš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦æ˜¯ **è¯¥èŠ‚ç‚¹åˆ°æ ¹çš„æœ€çŸ­è·ç¦»** ã€‚

è¿”å›åŒ…å«åŸå§‹æ ‘ä¸­æ‰€æœ‰ **æœ€æ·±èŠ‚ç‚¹** çš„ *æœ€å°å­æ ‘* ã€‚

å¦‚æœä¸€ä¸ªèŠ‚ç‚¹åœ¨ **æ•´ä¸ªæ ‘** çš„ä»»æ„èŠ‚ç‚¹ä¹‹é—´å…·æœ‰æœ€å¤§çš„æ·±åº¦ï¼Œåˆ™è¯¥èŠ‚ç‚¹æ˜¯ **æœ€æ·±çš„** ã€‚

ä¸€ä¸ªèŠ‚ç‚¹çš„ **å­æ ‘** æ˜¯è¯¥èŠ‚ç‚¹åŠ ä¸Šå®ƒçš„æ‰€æœ‰åä»£çš„é›†åˆã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/865_%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91_%E7%A4%BA%E4%BE%8B1.png)

```
è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4]
è¾“å‡ºï¼š[2,7,4]
è§£é‡Šï¼š
æˆ‘ä»¬è¿”å›å€¼ä¸º 2 çš„èŠ‚ç‚¹ï¼Œåœ¨å›¾ä¸­ç”¨é»„è‰²æ ‡è®°ã€‚
åœ¨å›¾ä¸­ç”¨è“è‰²æ ‡è®°çš„æ˜¯æ ‘çš„æœ€æ·±çš„èŠ‚ç‚¹ã€‚
æ³¨æ„ï¼ŒèŠ‚ç‚¹ 5ã€3 å’Œ 2 åŒ…å«æ ‘ä¸­æœ€æ·±çš„èŠ‚ç‚¹ï¼Œä½†èŠ‚ç‚¹ 2 çš„å­æ ‘æœ€å°ï¼Œå› æ­¤æˆ‘ä»¬è¿”å›å®ƒã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
è§£é‡Šï¼šæ ¹èŠ‚ç‚¹æ˜¯æ ‘ä¸­æœ€æ·±çš„èŠ‚ç‚¹ã€‚
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [0,1,3,null,2]
è¾“å‡ºï¼š[2]
è§£é‡Šï¼šæ ‘ä¸­æœ€æ·±çš„èŠ‚ç‚¹ä¸º 2 ï¼Œæœ‰æ•ˆå­æ ‘ä¸ºèŠ‚ç‚¹ 2ã€1 å’Œ 0 çš„å­æ ‘ï¼Œä½†èŠ‚ç‚¹ 2 çš„å­æ ‘æœ€å°ã€‚
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨ `[1, 500]` èŒƒå›´å†…ã€‚
- `0 <= Node.val <= 500`
- æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ **ç‹¬ä¸€æ— äºŒ** çš„ã€‚

 

**æ³¨æ„ï¼š**æœ¬é¢˜ä¸åŠ›æ‰£ 1123 é‡å¤ï¼š[https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

è¿™é“é¢˜çš„è§£é¢˜æ€è·¯å¦‚ä¸‹ï¼š

---
## ğŸ¯ é¢˜ç›®ç›®æ ‡

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ‰¾å‡ºä¸€ä¸ª**æœ€å°çš„å­æ ‘**ï¼Œä½¿å¾—è¿™ä¸ªå­æ ‘åŒ…å«äº†**æ‰€æœ‰çš„æœ€æ·±å¶èŠ‚ç‚¹**ã€‚  
æˆ‘ä»¬è¦è¿”å›è¿™ä¸ªå­æ ‘çš„**æ ¹èŠ‚ç‚¹**ã€‚

> ä¸¾ä¸ªä¾‹å­ï¼š
>
> - å¦‚æœæœ€æ·±çš„å¶å­åªæœ‰ä¸€ä¸ªï¼ˆæ¯”å¦‚åœ¨å·¦ä¸‹è§’ï¼‰ï¼Œé‚£ç­”æ¡ˆå°±æ˜¯é‚£ä¸ªå¶å­è‡ªå·±ã€‚
> - å¦‚æœæœ€æ·±çš„å¶å­æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«åœ¨å·¦å­æ ‘å’Œå³å­æ ‘çš„åº•éƒ¨ï¼Œé‚£ç­”æ¡ˆå°±æ˜¯å®ƒä»¬çš„**æœ€è¿‘å…¬å…±ç¥–å…ˆ**ï¼ˆLCAï¼‰ã€‚
---
## ğŸ” å…³é”®è§‚å¯Ÿ

1. **ä»€ä¹ˆæ˜¯æœ€æ·±å¶èŠ‚ç‚¹ï¼Ÿ**  
    å°±æ˜¯æ•´æ£µæ ‘ä¸­**æ·±åº¦æœ€å¤§**çš„é‚£äº›å¶å­èŠ‚ç‚¹ã€‚å¯èƒ½æœ‰1ä¸ªï¼Œä¹Ÿå¯èƒ½æœ‰å¤šä¸ªã€‚
    
2. **ä»€ä¹ˆæ˜¯æœ€å°å­æ ‘ï¼Ÿ**  
    èƒ½æŠŠ**æ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹éƒ½åŒ…è¿›å»**çš„å­æ ‘ä¸­ï¼Œ**æ ¹èŠ‚ç‚¹å°½å¯èƒ½æ·±**çš„é‚£ä¸ªã€‚  
    æ¢å¥è¯è¯´ï¼šæˆ‘ä»¬ä¸è¦ä»æ ¹å¼€å§‹çš„å¤§å­æ ‘ï¼Œè€Œæ˜¯è¦â€œåˆšå¥½èƒ½ç½©ä½æ‰€æœ‰æœ€æ·±å¶å­â€çš„é‚£ä¸ªæœ€å°èŒƒå›´ã€‚
    
3. **è¿™ä¸ªå­æ ‘çš„æ ¹æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ**  
    å®ƒä¸€å®šæ˜¯è¿™äº›æœ€æ·±å¶èŠ‚ç‚¹çš„**æœ€è¿‘å…¬å…±ç¥–å…ˆ**ï¼ˆLCAï¼‰ã€‚  
    è€Œä¸”ï¼Œå¦‚æœæ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹éƒ½åœ¨åŒä¸€ä¾§ï¼ˆæ¯”å¦‚å…¨åœ¨å·¦è¾¹ï¼‰ï¼Œé‚£ç­”æ¡ˆå°±åœ¨å·¦è¾¹ï¼›å¦‚æœåˆ†æ•£åœ¨å·¦å³ä¸¤è¾¹ï¼Œé‚£ç­”æ¡ˆå°±æ˜¯å½“å‰èŠ‚ç‚¹ã€‚
    
---
## ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼šè‡ªåº•å‘ä¸Š + æ·±åº¦æ¯”è¾ƒ

æˆ‘ä»¬ç”¨**ååºéå†**ï¼ˆå…ˆå¤„ç†å·¦å­æ ‘ï¼Œå†å¤„ç†å³å­æ ‘ï¼Œæœ€åå¤„ç†å½“å‰èŠ‚ç‚¹ï¼‰æ¥åšè¿™ä»¶äº‹ã€‚

å¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬æƒ³çŸ¥é“ä¸¤ä»¶äº‹ï¼š

- å®ƒçš„å­æ ‘ä¸­ï¼Œ**æœ€æ·±èƒ½åˆ°å¤šå°‘å±‚**ï¼ˆå³æœ€å¤§æ·±åº¦ï¼‰ï¼Ÿ
- åœ¨å®ƒçš„å­æ ‘é‡Œï¼Œ**åŒ…å«æ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹çš„æœ€å°å­æ ‘æ ¹æ˜¯è°**ï¼Ÿ

äºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥è®©æ¯ä¸ªé€’å½’å‡½æ•°**è¿”å›ä¸¤ä¸ªä¿¡æ¯**ï¼š

- `depth`ï¼šè¯¥å­æ ‘çš„æœ€å¤§æ·±åº¦
- `node`ï¼šè¯¥å­æ ‘ä¸­æ»¡è¶³æ¡ä»¶çš„å€™é€‰æ ¹èŠ‚ç‚¹
---
## ğŸ§  é€’å½’é€»è¾‘ï¼ˆé‡ç‚¹ï¼ï¼‰

å‡è®¾å½“å‰èŠ‚ç‚¹æ˜¯ `node`ï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†ï¼š

- å·¦å­æ ‘çš„ç»“æœï¼š`(leftNode, leftDepth)`
- å³å­æ ‘çš„ç»“æœï¼š`(rightNode, rightDepth)`

ç°åœ¨åˆ†ä¸‰ç§æƒ…å†µåˆ¤æ–­ï¼š

### âœ… æƒ…å†µ1ï¼š`leftDepth == rightDepth`

- è¯´æ˜å·¦å³å­æ ‘â€œä¸€æ ·æ·±â€ï¼Œè€Œä¸”è¿™ä¸ªæ·±åº¦å°±æ˜¯å½“å‰å­æ ‘çš„æœ€å¤§æ·±åº¦ã€‚
- é‚£ä¹ˆï¼Œ**æœ€æ·±å¶èŠ‚ç‚¹ä¸€å®šåŒæ—¶å‡ºç°åœ¨å·¦å­æ ‘å’Œå³å­æ ‘ä¸­**ã€‚
- æ‰€ä»¥ï¼Œè¦æƒ³åŒ…å«æ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹ï¼Œå¿…é¡»æŠŠå·¦å³éƒ½åŒ…æ‹¬è¿›æ¥ â†’ **å½“å‰èŠ‚ç‚¹ `node` å°±æ˜¯ç­”æ¡ˆ**ï¼

### âœ… æƒ…å†µ2ï¼š`leftDepth > rightDepth`

- å·¦è¾¹æ›´æ·±ï¼Œè¯´æ˜**æ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹éƒ½åœ¨å·¦å­æ ‘é‡Œ**ã€‚
- é‚£ä¹ˆï¼Œå³å­æ ‘å¯ä»¥å¿½ç•¥ï¼Œç›´æ¥**ç»§æ‰¿å·¦å­æ ‘çš„ç­”æ¡ˆ**ï¼ˆå³ `leftNode`ï¼‰ã€‚

### âœ… æƒ…å†µ3ï¼š`rightDepth > leftDepth`

- åŒç†ï¼Œæ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹éƒ½åœ¨å³å­æ ‘é‡Œï¼Œ**ç»§æ‰¿å³å­æ ‘çš„ç­”æ¡ˆ**ï¼ˆå³ `rightNode`ï¼‰ã€‚

> ğŸ“Œ æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦çŸ¥é“â€œå…¨å±€æœ€å¤§æ·±åº¦æ˜¯å¤šå°‘â€ï¼Œå› ä¸ºæˆ‘ä»¬åªå…³å¿ƒ**ç›¸å¯¹æ·±åº¦**â€”â€”å“ªè¾¹æ›´æ·±ï¼Œæˆ–è€…æ˜¯å¦ä¸€æ ·æ·±ã€‚
---
## ğŸ”„ é€’å½’ç»ˆæ­¢æ¡ä»¶

- å½“å‰èŠ‚ç‚¹æ˜¯ `null`ï¼ˆç©ºï¼‰ï¼š
    - æ·±åº¦ä¸º `0`
    - å€™é€‰èŠ‚ç‚¹ä¸º `null`
---
## ğŸš€ æœ€ç»ˆç»“æœ

ä»æ ¹èŠ‚ç‚¹å¼€å§‹è°ƒç”¨é€’å½’ï¼Œæœ€ç»ˆè¿”å›çš„ `node` å°±æ˜¯ç­”æ¡ˆã€‚

---
## âœ… ä¸¾ä¸ªä¾‹å­è¯´æ˜

```
        1
       / \
      2   3
     /   /
    4   5
```

- èŠ‚ç‚¹4å’Œ5éƒ½æ˜¯æ·±åº¦ä¸º3çš„æœ€æ·±å¶èŠ‚ç‚¹ã€‚
- å®ƒä»¬çš„è·¯å¾„ï¼š4 â† 2 â† 1ï¼Œ5 â† 3 â† 1
- åœ¨èŠ‚ç‚¹1å¤„ï¼Œå·¦å­æ ‘æœ€å¤§æ·±åº¦=3ï¼Œå³å­æ ‘æœ€å¤§æ·±åº¦=3 â†’ ç›¸ç­‰ï¼
- æ‰€ä»¥èŠ‚ç‚¹1å°±æ˜¯ç­”æ¡ˆã€‚

å†çœ‹ï¼š

```
    1
   /
  2
 /
3
```

- æœ€æ·±å¶èŠ‚ç‚¹åªæœ‰3ã€‚
- åœ¨èŠ‚ç‚¹2å¤„ï¼šå·¦æ·±åº¦=2ï¼Œå³æ·±åº¦=0 â†’ å·¦æ›´æ·± â†’ ç»§æ‰¿å·¦å­æ ‘ç­”æ¡ˆï¼ˆå³3ï¼‰
- åœ¨èŠ‚ç‚¹1å¤„ï¼šå·¦æ·±åº¦=3ï¼Œå³æ·±åº¦=0 â†’ ç»§æ‰¿å·¦å­æ ‘ç­”æ¡ˆï¼ˆè¿˜æ˜¯3ï¼‰
- æ‰€ä»¥ç­”æ¡ˆæ˜¯3ã€‚
---
## â±ï¸ å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n) â€”â€” æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(h) â€”â€” h æ˜¯æ ‘çš„é«˜åº¦ï¼Œç”¨äºé€’å½’æ ˆï¼ˆæœ€å O(n)ï¼Œå¹³è¡¡æ ‘ O(log n)ï¼‰
---
## âœ… æ€»ç»“ä¸€å¥è¯

> **è°çš„å·¦å³å­æ ‘â€œæœ€æ·±æ·±åº¦â€ç›¸ç­‰ï¼Œè°å°±æ˜¯æ‰€æœ‰æœ€æ·±å¶èŠ‚ç‚¹çš„â€œå…±åŒè€å¤§â€ï¼›å¦‚æœä¸ç­‰ï¼Œå°±è·Ÿç€æ›´æ·±çš„é‚£ä¸€è¾¹èµ°ã€‚**

è¿™ç§æ–¹æ³•å·§å¦™åœ°æŠŠâ€œæ‰¾æœ€æ·±å¶èŠ‚ç‚¹â€å’Œâ€œæ‰¾LCAâ€èåˆåœ¨ä¸€æ¬¡éå†ä¸­ï¼Œæ—¢é«˜æ•ˆåˆç®€æ´ã€‚

## ğŸ§  æœ€ç»ˆä»£ç 
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    pair<TreeNode*, int> dfs(TreeNode* node) {
        if (node == nullptr) {
            return {nullptr, 0};
        }
        
        auto left = dfs(node->left);
        auto right = dfs(node->right);
        
        if (left.second == right.second) {
            // å·¦å³å­æ ‘æ·±åº¦ç›¸åŒï¼Œå½“å‰èŠ‚ç‚¹ä¸ºç­”æ¡ˆ
            return {node, left.second + 1};
        } else if (left.second > right.second) {
            // å·¦å­æ ‘æ›´æ·±ï¼Œç»§æ‰¿å·¦å­æ ‘çš„ç­”æ¡ˆ
            return {left.first, left.second + 1};
        } else {
            // å³å­æ ‘æ›´æ·±ï¼Œç»§æ‰¿å³å­æ ‘çš„ç­”æ¡ˆ
            return {right.first, right.second + 1};
        }
    }

public:
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        return dfs(root).first;
    }
};
```

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        return dfs(root).node;
    }

    private static class Result {
        TreeNode node;
        int depth;
        Result(TreeNode node, int depth) {
            this.node = node;
            this.depth = depth;
        }
    }

    private Result dfs(TreeNode node) {
        if (node == null) {
            return new Result(null, 0);
        }

        Result left = dfs(node.left);
        Result right = dfs(node.right);

        if (left.depth == right.depth) {
            // å·¦å³æ·±åº¦ç›¸åŒï¼Œå½“å‰èŠ‚ç‚¹æ˜¯æ–°çš„å€™é€‰
            return new Result(node, left.depth + 1);
        } else if (left.depth > right.depth) {
            // å·¦è¾¹æ›´æ·±ï¼Œç»§æ‰¿å·¦è¾¹çš„å€™é€‰
            return new Result(left.node, left.depth + 1);
        } else {
            // å³è¾¹æ›´æ·±ï¼Œç»§æ‰¿å³è¾¹çš„å€™é€‰
            return new Result(right.node, right.depth + 1);
        }
    }
}
```



## Pythonä»£ç 

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # å…¨å±€æœ€å¤§æ·±åº¦
        max_depth = -1
        result = None

        def dfs(node: Optional[TreeNode], depth: int) -> int:
            nonlocal result, max_depth
            if node is None:
                # ç»´æŠ¤å…¨å±€æœ€å¤§æ·±åº¦
                max_depth = max(max_depth, depth)
                return depth

            # è·å–å·¦å­æ ‘ä¸­æœ€æ·±å¶èŠ‚ç‚¹çš„æ·±åº¦
            left_max_depth = dfs(node.left, depth + 1)
            # è·å–å³å­æ ‘ä¸­æœ€æ·±å¶èŠ‚ç‚¹çš„æ·±åº¦
            right_max_depth = dfs(node.right, depth + 1)

            if left_max_depth == right_max_depth == max_depth:
                # nodeå¯èƒ½æ˜¯ç­”æ¡ˆ
                result = node
            
            # å½“å‰å­æ ‘æœ€æ·±å¶èŠ‚ç‚¹çš„æ·±åº¦
            return max(left_max_depth, right_max_depth)

        dfs(root, 0)
        return result
```



## C++ä»£ç 

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    pair<TreeNode*, int> dfs(TreeNode* node) {
        if (node == nullptr) {
            return {nullptr, 0};
        }
        
        auto left = dfs(node->left);
        auto right = dfs(node->right);
        
        if (left.second == right.second) {
            // å·¦å³å­æ ‘æ·±åº¦ç›¸åŒï¼Œå½“å‰èŠ‚ç‚¹ä¸ºç­”æ¡ˆ
            return {node, left.second + 1};
        } else if (left.second > right.second) {
            // å·¦å­æ ‘æ›´æ·±ï¼Œç»§æ‰¿å·¦å­æ ‘çš„ç­”æ¡ˆ
            return {left.first, left.second + 1};
        } else {
            // å³å­æ ‘æ›´æ·±ï¼Œç»§æ‰¿å³å­æ ‘çš„ç­”æ¡ˆ
            return {right.first, right.second + 1};
        }
    }

public:
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        return dfs(root).first;
    }
};
```

![865_å…·æœ‰æ‰€æœ‰æœ€æ·±èŠ‚ç‚¹çš„æœ€å°å­æ ‘_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/865_%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91_C++.png)