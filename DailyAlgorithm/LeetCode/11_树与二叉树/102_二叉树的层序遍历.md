[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

>标签：树  |  广度优先搜索  |  二叉树

# 一、题目描述

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/102_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86_%E7%A4%BA%E4%BE%8B1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



# 二、解题思路\解题过程

这道题参考灵神的视频讲解——[二叉树的层序遍历【基础算法精讲 13】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hG4y1277i/?vd_source=12bf3ca6137fdd845e5fdc4e85bccc36)！（灵神视频中采用的是Python，我们可以用其他编程语言来写，进一步加深对题目的理解和学习！）

代码如下：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> value = new ArrayList<>();
        if(root == null){
            return value;
        }
        Queue<TreeNode> qRoot = new LinkedList<>();
        qRoot.offer(root);

        while(!qRoot.isEmpty()){
            int size = qRoot.size();
            List<Integer> flag = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = qRoot.poll();
                flag.add(node.val);
                if(node.left != null){
                    qRoot.add(node.left);
                }
                if(node.right != null){
                    qRoot.add(node.right);
                }
            }
            value.add(flag);
        }
        return value;
    }
}
```

# 三、代码演示

## Java代码

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> value = new ArrayList<>();
        if(root == null){
            return value;
        }
        Queue<TreeNode> qRoot = new LinkedList<>();
        qRoot.offer(root);

        while(!qRoot.isEmpty()){
            int size = qRoot.size();
            List<Integer> flag = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = qRoot.poll();
                flag.add(node.val);
                if(node.left != null){
                    qRoot.add(node.left);
                }
                if(node.right != null){
                    qRoot.add(node.right);
                }
            }
            value.add(flag);
        }
        return value;
    }
}
```



## Python代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None :
            return []
        value, current = [], [root]
        while current:
            nxt = []
            flag = []
            for node in current :
                flag.append(node.val)
                if node.left : nxt.append(node.left)
                if node.right : nxt.append(node.right)
            current = nxt
            value.append(flag)
        return value
```



## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr){
            return result;
        }

        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()){
            int size = q.size();
            vector<int> currentLevel;

            for(int i = 0; i < size; i++){
                TreeNode* node = q.front();
                q.pop();
                currentLevel.push_back(node->val);

                if(node->left != nullptr){
                    q.push(node->left);
                }
                if(node->right != nullptr){
                    q.push(node->right);
                }
            }

            result.push_back(currentLevel);
        }
        return result;
    }
};
```

![102_二叉树的层序遍历_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/102_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86_C++.png)