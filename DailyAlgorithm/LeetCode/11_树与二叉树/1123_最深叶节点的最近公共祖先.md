[1123. 最深叶节点的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/)

>标签：树  |  深度优先搜索  |  广度优先搜索  |  哈希表  |  二叉树

# 一、题目描述

给你一个有根节点 `root` 的二叉树，返回它 *最深的叶节点的最近公共祖先* 。

回想一下：

- **叶节点** 是二叉树中没有子节点的节点
- 树的根节点的 **深度** 为 `0`，如果某一节点的深度为 `d`，那它的子节点的深度就是 `d+1`
- 如果我们假定 `A` 是一组节点 `S` 的 **最近公共祖先**，`S` 中的每个节点都在以 `A` 为根节点的子树中，且 `A` 的深度达到此条件下可能的最大值。

 

**示例 1：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/865_%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91_%E7%A4%BA%E4%BE%8B1.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。
```

**示例 2：**

```
输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点，它是它本身的最近公共祖先。
```

**示例 3：**

```
输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的叶节点是 2 ，最近公共祖先是它自己。
```

 

**提示：**

- 树中的节点数将在 `[1, 1000]` 的范围内。
- `0 <= Node.val <= 1000`
- 每个节点的值都是 **独一无二** 的。

 

**注意：**本题与力扣 865 重复：https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/

 

# 二、解题思路\解题过程

这道题和上述中的[865. 具有所有最深节点的最小子树 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/description/?envType=daily-question&envId=2026-01-09)题目是一样的，可以完全参考上述力扣第865中的思路和代码笔记！

力扣第[865. 具有所有最深节点的最小子树 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/submissions/690203490/?envType=daily-question&envId=2026-01-09)的思路笔记的网址为：

[DailyAlgorithm/LeetCode/11_树与二叉树/865_具有所有最深节点的最小子树.md · AJun/CodingLearning - 码云 - 开源中国](https://gitee.com/lei-weijun/CodingLearning/blob/main/DailyAlgorithm/LeetCode/11_树与二叉树/865_具有所有最深节点的最小子树.md)



也可以去看灵神相关的视频讲解，非常不错！



# 三、代码演示

## Java代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode lcaDeepestLeaves(TreeNode root) {
        return dfs(root).node;
    }

    private static class Result {
        TreeNode node;
        int depth;
        Result(TreeNode node, int depth) {
            this.node = node;
            this.depth = depth;
        }
    }

    private Result dfs(TreeNode node) {
        if (node == null) {
            return new Result(null, 0);
        }

        Result left = dfs(node.left);
        Result right = dfs(node.right);

        if (left.depth == right.depth) {
            // 左右深度相同，当前节点是新的候选
            return new Result(node, left.depth + 1);
        } else if (left.depth > right.depth) {
            // 左边更深，继承左边的候选
            return new Result(left.node, left.depth + 1);
        } else {
            // 右边更深，继承右边的候选
            return new Result(right.node, right.depth + 1);
        }
    }
}
```



## Python代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 全局最大深度
        max_depth = 1
        result = None

        def dfs(node: Optional[TreeNode], depth: int) -> int:
            nonlocal result, max_depth
            if node is None:
                # 维护全局最大深度
                max_depth = max(max_depth, depth)
                return depth
            
            # 获取左子树中最深叶节点的深度
            left_max_depth = dfs(node.left, depth + 1)
            # 获取右子树中最深叶节点的深度
            rigth_max_depth = dfs(node.right, depth + 1)

            if left_max_depth == rigth_max_depth == max_depth:
                # node可能是答案
                result = node
            
            # 当前子树最深叶节点的深度
            return max(left_max_depth, rigth_max_depth)

        dfs(root, 0)
        return result
```



## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    pair<TreeNode*, int> dfs(TreeNode* node) {
        if (node == nullptr) {
            return {nullptr, 0};
        }

        auto left = dfs(node->left);
        auto right = dfs(node->right);

        if (left.second == right.second) {
            // 左右子树深度相同，当前节点为深度
            return {node, left.second + 1};
        } else if (left.second > right.second) {
            // 左子树更深，继承左子树的答案
            return {left.first, left.second + 1};
        } else {
            // 右子树更深，继承右子树的答案
            return {right.first, right.second + 1};
        }
    }

public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        return dfs(root).first;
    }
};
```

