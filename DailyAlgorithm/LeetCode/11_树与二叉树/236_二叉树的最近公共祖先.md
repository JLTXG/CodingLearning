[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

>标签：树  |  深度优先搜索  |  二叉树

# 一、题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](E:\NoteTakingSoftwares\Typora\Images\binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](E:\NoteTakingSoftwares\Typora\Images\binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

 

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。



# 二、解题思路\解题过程

## 🔍 题目理解

给定一棵**普通二叉树**（不是 BST）和两个节点 `p` 和 `q`，要求返回它们的**最近公共祖先**（LCA）。

- **最近公共祖先**：指在所有同时是 `p` 和 `q` 祖先的节点中，**深度最大**的那个。
- 一个节点可以是它自己的祖先（例如当 `p` 是 `q` 的祖先时，答案就是 `p`）。
- 题目保证 `p` 和 `q` 一定存在于树中。
## 💡 解题思路详解

该算法采用**递归 + 后序遍历**的思想，核心在于：**自底向上地判断当前节点是否为最近公共祖先**。
### 核心逻辑：

1. **递归终止条件**：
    - 如果当前节点是 `null`，说明已到叶子下方，返回 `null`。
    - 如果当前节点是 `p` 或 `q`，直接返回该节点。这既表示“找到了目标”，也处理了“一个节点是另一个节点祖先”的特殊情况。
2. **递归左右子树**：
    - 在左子树中查找 `p` 或 `q`，得到结果 `left`。
    - 在右子树中查找 `p` 或 `q`，得到结果 `right`。
3. **合并结果（关键判断）**：
    - **情况一**：`left != null && right != null`  
        说明 `p` 和 `q` 分别位于当前节点的**左右两侧**，那么当前节点 `root` 就是它们的**最近公共祖先**。
    - **情况二**：只有一侧非空（如 `left != null`）  
        说明 `p` 和 `q` 都在**同一侧子树中**，那么最近公共祖先一定在那一侧，直接返回该侧结果。
    - **情况三**：两侧都为空（理论上不会发生，因题目保证 p、q 存在）
### 为什么正确？
- 由于是**后序遍历**（先子树，后根），当回溯到某个节点时，我们已经知道左右子树是否包含 `p` 或 `q`。
- 一旦发现 `p` 和 `q` “分家”（分别在左右子树），这个“分家点”就是最近的公共祖先。
- 如果没分家，就继续把找到的节点（或子树的 LCA）向上传递。
### 复杂度分析：
- **时间复杂度**：O(n)，最坏遍历所有节点。
- **空间复杂度**：O(h)，h 为树高（递归栈深度）。
---
✅ 总结：  
这段代码通过一次简洁的递归，巧妙利用返回值传递“是否找到目标”和“LCA 是谁”的双重信息，高效解决了普通二叉树的最近公共祖先问题。

## 🧠 最终代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL || root == p || root == q){
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left != NULL && right != NULL){
            return root;
        }
        if(left != NULL){
            return left;
        }
        return right;
    }
};
```

# 三、代码演示

## Java代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left != null && right != null){
            return root;
        }
        if(left != null){
            return left;
        }
        return right;
    }
}
```



## Python代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root is p or root is q :
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right :
            return root
        if left :
            return left
        return right
```



## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL || root == p || root == q){
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left != NULL && right != NULL){
            return root;
        }
        if(left != NULL){
            return left;
        }
        return right;
    }
};
```

