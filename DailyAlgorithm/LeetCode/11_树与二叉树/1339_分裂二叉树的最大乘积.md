[1339. 分裂二叉树的最大乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/description/?envType=daily-question&envId=2026-01-07)

>标签：树  |  深度优先搜索  |  二叉树

# 一、题目描述

给你一棵二叉树，它的根为 `root` 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。

由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

 

**示例 1：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/1339_%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF_%E7%A4%BA%E4%BE%8B1.png)**

```
输入：root = [1,2,3,4,5,6]
输出：110
解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）
```

**示例 2：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/1339_%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF_%E7%A4%BA%E4%BE%8B2.png)

```
输入：root = [1,null,2,3,4,null,null,5,6]
输出：90
解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）
```

**示例 3：**

```
输入：root = [2,3,9,10,7,8,6,5,4,11,1]
输出：1025
```

**示例 4：**

```
输入：root = [1,1]
输出：1
```

 

**提示：**

- 每棵树最多有 `50000` 个节点，且至少有 `2` 个节点。
- 每个节点的值在 `[1, 10000]` 之间。



# 二、解题思路\解题过程

本道题内容转载[1339. 分裂二叉树的最大乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/solutions/3870465/liang-ci-dfshuo-zhe-ti-qian-bao-cun-zi-s-uo4x/?envType=daily-question&envId=2026-01-07)，[灵茶山艾府](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solutions/3869919/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-0gct/)。

写这类题目，我发现我还是对于树相关的代码不是很了解，以及Java（C++和Python也是）中的集合等内容语法还不是很了解，我后续需要加强对这方面的学习，下面是这道题的解题思路和代码：
`解题思路`：
采用两次DFS，也可以采用一次DFS，如下：

```
第一次 DFS：计算整棵树的点权和 total。
第二次 DFS：计算子树点权和 s，那么删除当前节点到其父节点的边后，另一部分的和就是——total−s，二者乘积为——s⋅(total−s)
用其更新答案的最大值。
由于本题保证点权是非负，我们无需判断当前节点是根节点的特殊情况（无父节点），此时上式为 0，不影响答案。
如果有负数点权，就需要跳过当前节点是根节点的情况。
```

```
也可以在第一次 DFS 时，把子树和保存到一个列表中，第二次只需遍历这个列表，见 Python3 的第一份代码。
```

`代码如下`：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private static final int MOD = 1000000007;

    public int maxProduct(TreeNode root) {
        List<Long> sumRoot = new ArrayList<>();
        long total = dfs(root, sumRoot);

        long maxValue = 0;
        for(long iValue : sumRoot){
            long value = iValue * (total - iValue);
            if(value > maxValue){
                maxValue = value;
            }
        }

        return (int)(maxValue % MOD);
    }

    private long dfs(TreeNode node, List<Long> sumRoot){
        if(node == null){
            return 0L;
        }
        long leftSum = dfs(node.left, sumRoot);
        long rightSum = dfs(node.right, sumRoot);
        long currentSum = node.val + leftSum + rightSum;
        sumRoot.add(currentSum);
        return currentSum;
    }
}
```

# 三、代码演示

## Java代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private static final int MOD = 1000000007;

    public int maxProduct(TreeNode root) {
        List<Long> sumRoot = new ArrayList<>();
        long total = dfs(root, sumRoot);

        long maxValue = 0;
        for(long iValue : sumRoot){
            long value = iValue * (total - iValue);
            if(value > maxValue){
                maxValue = value;
            }
        }

        return (int)(maxValue % MOD);
    }

    private long dfs(TreeNode node, List<Long> sumRoot){
        if(node == null){
            return 0L;
        }
        long leftSum = dfs(node.left, sumRoot);
        long rightSum = dfs(node.right, sumRoot);
        long currentSum = node.val + leftSum + rightSum;
        sumRoot.add(currentSum);
        return currentSum;
    }
}
```



## Python代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return 0
            sum_node = node.val + dfs(node.right) + dfs(node.left)
            sum_root.append(sum_node)
            return sum_node
        sum_root = []
        total_value = dfs(root)

        sum_value = max(s_value * (total_value - s_value) for s_value in sum_root)
        return sum_value % 1000000007
```

![1339_分裂二叉树的最大乘积_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/1339_%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF_Python.png)

## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    static const int MOD = 1000000007;

public:
    int maxProduct(TreeNode* root) {
        vector<long long> sumRoot;
        long long total = dfs(root, sumRoot);
        
        long long maxValue = 0;
        for (long long iValue : sumRoot) {
            long long value = iValue * (total - iValue);
            if (value > maxValue) {
                maxValue = value;
            }
        }
        
        return (int)(maxValue % MOD);
    }

private:
    long long dfs(TreeNode* node, vector<long long>& sumRoot) {
        if (node == nullptr) {
            return 0LL;
        }
        long long leftSum = dfs(node->left, sumRoot);
        long long rightSum = dfs(node->right, sumRoot);
        long long currentSum = (long long)node->val + leftSum + rightSum;
        sumRoot.push_back(currentSum);
        return currentSum;
    }
};
```

