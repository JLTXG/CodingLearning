本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1653. 使字符串平衡的最少删除次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/description/?envType=daily-question&envId=2026-02-07)

>标签：高级工程师  |  栈  |  字符串  |  动态规划

# 一、题目描述

## **问题概括**

给定一个仅包含字符 `'a'` 和 `'b'` 的字符串 `s`。你可以删除其中的任意字符（位置不必连续），目标是使最终的字符串满足“平衡”条件：即不存在任意一个 `'b'` 出现在某个 `'a'` 的左侧（换言之，所有 `'a'` 都应当在所有 `'b'` 之前）。请计算达成平衡所需的最少删除次数。

## **示例说明**

- **示例1**：`s = "aababbab"`。删除第2和第6个字符（下标从0开始）得到 `"aaabbb"`，或删除第3和第6个字符得到 `"aabbbb"`，均只需删除2次。
- **示例2**：`s = "bbaaaaabb"`。删除最前面两个字符得到 `"aaaaabb"`，删除次数为2。

## **数据范围**

- `1 <= s.length <= 10^5`
- `s[i]` 为 `'a'` 或 `'b'`



# 二、解题思路\解题过程

## 🧩 题目理解

### 题目要求：

给定一个只包含 `'a'` 和 `'b'` 的字符串 `s`。  
你需要**删除最少数量的字符**，使得剩下的字符串是 **“平衡”** 的。

> **“平衡”定义为**：字符串中 **所有的 `'a'` 都出现在所有的 `'b'` 之前**。  
> 即：结果字符串的形式必须是 `"aaa...bbb..."`（可以全 a、全 b，或空串）。

### 举个例子：

- 输入：`s = "aababbab"`
- 输出：`2`
- 解释：删除两个 `'b'`（比如第4个和第6个），得到 `"aaabbb"`，满足条件。

---

## ✅ 代码展示 + 详细注释

```python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        # 初始假设：把所有 'a' 都删掉，只保留 'b'
        # 此时需要删除的次数 = 字符串中 'a' 的总数
        result = tmp = s.count('a')
        
        # 遍历字符串中的每个字符，模拟“分割点”的右移
        for c in s:
            # 如果当前字符是 'a'：
            #   - 它在分割点左侧 → 应该保留（不需要删）
            #   - 所以之前多算了这个 'a'（以为要删），现在减 1
            # 如果当前字符是 'b'：
            #   - 它在分割点左侧 → 但 'b' 出现在 'a' 前面是不允许的！
            #   - 所以这个 'b' 必须被删除 → 删除次数 +1
            # 综合起来：tmp -= 1 if c == 'a' else -1
            # 等价于：tmp = tmp - 1 (if 'a') 或 tmp + 1 (if 'b')
            tmp -= 1 if c == 'a' else -1
            
            # 更新全局最小删除次数
            if tmp < result:
                result = tmp
        
        return result
```

---

## 🔍 核心思想解析

### 💡 思路：**枚举“分割点”**

我们希望最终字符串形如：`[a...a][b...b]`。  
可以想象在字符串中插入一个“分割线”，左边只留 `'a'`，右边只留 `'b'`。

- 分割点可以在最左（左边为空 → 全是 `'b'`）
- 也可以在最右（右边为空 → 全是 `'a'`）
- 中间任意位置：左边保留 `'a'`，右边保留 `'b'`

> 对于每个可能的分割点，我们需要删除：
>
> - **左边所有的 `'b'`**（因为左边只能有 `'a'`）
> - **右边所有的 `'a'`**（因为右边只能有 `'b'`）

所以总删除数 = `左边 'b' 的数量 + 右边 'a' 的数量`

---

### 🔄 如何高效计算？

设：

- `total_a = s.count('a')`
- 遍历时维护：
    - `left_b`：当前已遍历部分（左边）中 `'b'` 的数量
    - `right_a = total_a - left_a = total_a - (已遍历的 'a' 数量)`

但注意：`已遍历的 'a' 数量 = (当前索引+1) - left_b`，有点绕。

**巧妙转换**：

初始时（分割点在最左）：

- 左边为空 → `left_b = 0`
- 右边是整个字符串 → `right_a = total_a`
- 总删除数 = `0 + total_a = total_a`

当我们向右移动一个字符 `c`：

- 如果 `c == 'a'`：
    - 它从“右边”移到了“左边”
    - `right_a` 减 1 → 总删除数 **减 1**
- 如果 `c == 'b'`：
    - 它从“右边”移到了“左边”
    - 但 `'b'` 在左边是非法的 → 必须删除 → `left_b` 加 1 → 总删除数 **加 1**

所以可以用一个变量 `tmp` 动态维护当前分割点的删除次数：

- 初始 `tmp = total_a`
- 遇到 `'a'` → `tmp -= 1`
- 遇到 `'b'` → `tmp += 1`

这正是你代码中的：

```python
tmp -= 1 if c == 'a' else -1
# 等价于：
# if c == 'a': tmp -= 1
# else: tmp += 1
```

然后记录 `tmp` 的最小值，就是答案！

---

## 📊 举个例子走一遍

`s = "aababbab"`

- `total_a = 4` → `result = tmp = 4`

| 字符 | 操作     | tmp 值 | 说明                                                 |
| ---- | -------- | ------ | ---------------------------------------------------- |
| 'a'  | tmp -= 1 | 3      | 分割点在第1个'a'后：左边="a"（合法），右边需删3个'a' |
| 'a'  | tmp -= 1 | 2      | 左边="aa"，右边删2个'a'                              |
| 'b'  | tmp += 1 | 3      | 左边="aab" → 多了1个'b'要删，右边删2个'a' → 共3      |
| 'a'  | tmp -= 1 | 2      | 左边="aaba" → 1个'b'要删，右边删1个'a' → 共2         |
| 'b'  | tmp += 1 | 3      | ...                                                  |
| 'b'  | tmp += 1 | 4      | ...                                                  |
| 'a'  | tmp -= 1 | 3      | ...                                                  |
| 'b'  | tmp += 1 | 4      | ...                                                  |

最小 `tmp = 2` → 返回 `2` ✅

---

## 📌 笔记重点总结

### ✅ 核心思想

> **枚举所有可能的“a/b分割点”，动态维护“左边需删的 b 数 + 右边需删的 a 数”，取最小值。**

### ✅ 时间复杂度

- `O(n)`：只需遍历一次字符串
- `O(1)`：只用几个变量

### ✅ 关键技巧

- 初始状态设为“全删 a”（即分割点在最左）
- 遍历时根据字符类型更新删除次数：
    - `'a'` → 减少删除数（因为它可以合法留在左边）
    - `'b'` → 增加删除数（因为它在左边必须被删）

### ✅ 类似问题

- “使括号平衡的最少删除”
- “分割数组使左右满足某种性质”

---

## ✅ 一句话终极笔记

> **“平衡字符串 = 所有 a 在 b 前。枚举分割点，动态维护左边删 b、右边删 a 的总代价，取最小。”**

# 三、代码演示

## Java代码

```Java
class Solution {
    public int minimumDeletions(String s) {
        char[] arr = s.toCharArray();
        int tmp = 0;
        for (char c : arr) {
            if (c == 'a') {
                tmp++;
            }
        }
        int result = tmp;
        for (char c : arr) {
            tmp += (c - 'a') * 2 - 1;
            result = Math.min(result, tmp);
        }
        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        result = tmp = s.count('a')
        for c in s:
            tmp -= 1 if c == 'a' else -1
            if tmp < result:
                result = tmp
        return result
```

![1653_使字符串平衡的最少删除次数_Python]()

## C++代码

```C++
class Solution {
public:
    int minimumDeletions(string s) {
        int tmp = 0;
        for (auto c : s) {
            if (c == 'a') {
                tmp++;
            }
        }
        int result = tmp;
        for (auto c : s) {
            tmp += (c - 'a') * 2 - 1;
            result = min(result, tmp);
        }
        return result;
    }
};
```

