本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[67. 二进制求和 - 力扣（LeetCode）](https://leetcode.cn/problems/add-binary/description/?envType=daily-question&envId=2026-02-15)

>标签：位运算  |  数学  |  字符串  |  模拟

# 一、题目描述

## **问题概括**

给定两个二进制字符串 `a` 和 `b`，它们表示两个二进制数（只包含字符 `'0'` 和 `'1'`，且除 `"0"` 外没有前导零）。请计算这两个二进制数的和，并以二进制字符串的形式返回结果。

## **示例说明**

- 输入 `a = "11"`, `b = "1"`，输出 `"100"`（即二进制 11 + 1 = 100）。
- 输入 `a = "1010"`, `b = "1011"`，输出 `"10101"`（即二进制 1010 + 1011 = 10101）。

## **数据范围**

- 字符串长度范围：`1 <= len(a), len(b) <= 10^4`。



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string result;  // 存储结果（注意：先存低位，最后反转）
        
        // i 指向 a 的最低位（最右边），j 指向 b 的最低位
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;  // 当前进位，初始为 0

        // 循环条件：只要还有未处理的位，或者还有进位，就继续
        while (i >= 0 || j >= 0 || carry > 0) {
            int sum = carry;  // 当前位的总和 = 进位 + a[i] + b[j]

            // 如果 a 还有未处理的位，加上 a[i]（'0'→0, '1'→1）
            if (i >= 0) {
                sum += a[i] - '0';
                i--;  // 指针左移
            }

            // 如果 b 还有未处理的位，加上 b[j]
            if (j >= 0) {
                sum += b[j] - '0';
                j--;  // 指针左移
            }

            // 当前位的结果是 sum % 2（0 或 1）
            // 转为字符：+ '0' → '0' 或 '1'
            result.push_back((sum % 2) + '0');

            // 更新进位：sum / 2（二进制中，sum≥2 才有进位）
            carry = sum / 2;
        }

        // 由于是从低位到高位依次 push_back，结果是反的
        // 例如：计算 "11" + "1" → 先得到 "001"，需反转为 "100"
        reverse(result.begin(), result.end());
        return result;
    }
};
```

---

## 🧠 核心解题思想分析

### 🔍 问题目标：

给定两个**二进制字符串** `a` 和 `b`，返回它们的**和**（也以二进制字符串形式）。

> 例如：  
> `a = "11"`, `b = "1"` → 输出 `"100"`  
> （即 3 + 1 = 4）

---

### 💡 核心思想：**模拟竖式加法（从右到左）**

#### 1. **对齐低位**

- 二进制加法从**最低位（最右边）**开始；
- 使用两个指针 `i` 和 `j` 分别从 `a` 和 `b` 的末尾向前遍历。

#### 2. **处理不同长度**

- 若一个字符串更短，其高位视为 `0`；
- 通过 `if (i >= 0)` 判断是否还有有效位。

#### 3. **进位机制**

- 每一位计算：`sum = bit_a + bit_b + carry_in`
- 当前位结果：`sum % 2`
- 向高位进位：`carry_out = sum / 2`（在二进制中，只有 0、1、2、3 四种可能，进位为 0 或 1）

#### 4. **处理最终进位**

- 即使两个字符串都遍历完，若 `carry == 1`，仍需再加一位（如 `"1" + "1" = "10"`）

#### 5. **结果反转**

- 因为先计算的是低位，`push_back` 导致结果字符串是**倒序**的；
- 最后用 `reverse()` 得到正确顺序。

---

### 🔄 示例演示

输入：`a = "1010"`, `b = "1011"`

```
     1 0 1 0   (a)
   + 1 0 1 1   (b)
   ----------
    1 0 1 0 1
```

模拟过程（从右到左）：

| 步骤 | i    | j    | sum     | 当前位 | carry | result（未反转） |
| ---- | ---- | ---- | ------- | ------ | ----- | ---------------- |
| 1    | 3    | 3    | 0+1+0=1 | '1'    | 0     | "1"              |
| 2    | 2    | 2    | 1+1+0=2 | '0'    | 1     | "10"             |
| 3    | 1    | 1    | 0+0+1=1 | '1'    | 0     | "101"            |
| 4    | 0    | 0    | 1+1+0=2 | '0'    | 1     | "1010"           |
| 5    | -    | -    | carry=1 | '1'    | 0     | "10101"          |

反转后：`"10101"` ✅

---

### ⏱️ 复杂度分析：

- **时间复杂度**：O(max(m, n))  
    —— m、n 为两字符串长度，每个字符访问一次
- **空间复杂度**：O(1)（不计输出空间）  
    —— 只用常数个变量；`result` 是输出必需空间

> 💡 这是最优解！

---

## 📚 笔记总结

### 🧩 问题定义：

给定两个二进制字符串，返回它们的和（也是二进制字符串）。

### 💡 核心思想：

> **模拟竖式加法（从右到左） + 进位处理**

### ✅ 算法步骤：

1. 初始化指针 `i = a.size()-1`, `j = b.size()-1`, `carry = 0`；
2. 循环直到 `i<0 && j<0 && carry==0`；
3. 计算当前位总和：`sum = carry + (a[i] if i>=0) + (b[j] if j>=0)`；
4. 当前位结果：`sum % 2` → 转字符存入结果；
5. 更新进位：`carry = sum / 2`；
6. 指针左移（若未越界）；
7. 循环结束后，**反转结果字符串**。

### 🔑 关键技巧：

- **字符转数字**：`ch - '0'`
- **数字转字符**：`digit + '0'`
- **处理不同长度**：用 `if (i>=0)` 安全访问
- **不要忘记最终进位**（如 "1"+"1" → "10"）
- **结果需反转**（因低位先算）

### ⏱️ 复杂度：

- 时间：O(max(m, n))
- 空间：O(1)（忽略输出）

### 💡 延伸应用：

- 十进制字符串相加（LeetCode 415）
- 任意进制加法（修改 `% base` 和 `/ base`）

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder result = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;  // 进位

        // 从右向左逐位相加
        while (i >= 0 || j >= 0 || carry > 0) {
            int sum = carry;

            if (i >= 0) sum += a.charAt(i--) - '0';  // char 转 int
            if (j >= 0) sum += b.charAt(j--) - '0';

            result.append((char)((sum % 2) + '0'));  // 当前位转 char
            carry = sum / 2;  // 更新进位
        }

        // 结果是倒序的，需要反转
        return result.reverse().toString();
    }
}
```



## Python代码

```Python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        result = []
        i = len(a) - 1
        j = len(b) - 1
        carry = 0  # 进位

        # 从右向左逐位相加
        while i >= 0 or j >= 0 or carry > 0:
            sum_val = carry

            if i >= 0:
                sum_val += int(a[i])
                i -= 1
            if j >= 0:
                sum_val += int(b[j])
                j -= 1
            
            result.append(str(sum_val % 2))  # 当前位
            carry = sum_val // 2  # 更新进位

        # 结果是倒序的，需要反转
        return ''.join(reversed(result))
```



## C++代码

```C++
class Solution {
public:
    string addBinary(string a, string b) {
        string result;
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;  // 进位

        // 从右向左逐位相加
        while (i >= 0 || j >= 0 || carry > 0) {
            int sum = carry;

            if (i >= 0) sum += a[i--] - '0';  // char 转 int
            if (j >= 0) sum += b[j--] - '0';

            result.push_back((sum % 2) + '0');  // 当前位转 char
            carry = sum / 2;  // 更新进位
        }

        // 结果是倒序的，需要反转
        reverse(result.begin(), result.end());
        return result;
    }
};
```

![67_二进制求和_C++]()