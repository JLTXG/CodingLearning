本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：队列  |  数组  |  滑动窗口  |  单调队列

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums` 和一个正整数 `k`，定义一个长度为 `k` 的滑动窗口从数组最左端移动到最右端，每次向右滑动一个位置。请计算并返回每个滑动窗口中的最大值，将这些最大值按窗口出现的顺序存入数组并返回。

## **示例说明**

- **示例1**：`nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`，滑动窗口最大值依次为 `[3,3,5,5,6,7]`。
- **示例2**：`nums = [1]`, `k = 1`，只有一个窗口，最大值为 `[1]`。

## **数据范围**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`



# 二、解题思路\解题过程

## 📌 题目要求

给定一个整数数组 `nums` 和一个滑动窗口大小 `k`，
**返回每个窗口中的最大值**，窗口从左向右滑动。

> 示例：
> `nums = [1,3,-1,-3,5,3,6,7], k = 3`
> 输出：`[3,3,5,5,6,7]`

------

## 🔑 核心思想：**单调双端队列（Monotonic Deque）**

### ✅ 为什么不用暴力？

- 暴力：对每个窗口遍历找最大值 → 时间复杂度 **O(nk)**  
- 当 `n = 10⁵`, `k = 5×10⁴` 时，操作次数高达 **5×10⁹** → **超时！**

------

### ✅ 正确策略：用双端队列维护“可能成为最大值”的候选下标

#### 🧩 队列性质：

- 存储的是 **数组下标**（不是值），便于判断是否在窗口内；
- 对应的 `nums[下标]` **从队首到队尾严格单调递减**；
- **队首始终是当前窗口的最大值的下标**。

------

## 🛠️ 算法步骤（每一步都关键！）

对每个下标 `i`（从 0 到 n-1）：

1. **移除过期元素**  
    - 如果队首下标 `< i - k + 1`（即已滑出窗口左边），则 `pollFirst()`。
2. **维护单调性（核心！）**  
    - 从队尾开始，**移除所有 `nums[下标] <= nums[i]` 的元素**。  
    - **原因**：`nums[i]` 更大（或相等）且“活得更久”（位置更靠右），旧元素永远没机会当最大值。
3. **当前下标入队**  
    - `offerLast(i)`
4. **记录结果（窗口形成后）**  
    - 当 `i >= k - 1` 时，窗口 `[i-k+1, i]` 已形成，
        将 `nums[deque.peekFirst()]` 加入结果。

------

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
    - 每个下标最多入队、出队各一次 → 总操作 ≤ 2n。
- 空间复杂度：`O(k)`
    - 队列中最多存 `k` 个下标。

------

## 💡 关键理解点（必记！）

| 问题                                   | 答案                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 为什么存下标而不是值？                 | 为了判断元素是否还在窗口内（通过下标范围）                   |
| 为什么可以删除 `<= nums[i]` 的旧元素？ | 它们既不大于 `nums[i]`，又比 `nums[i]` 先离开窗口 → 永远不可能成为最大值 |
| 为什么队列单调递减？                   | 保证队首始终是当前最大值，且后续更新高效                     |

------

## ✅ 一句话总结

> 使用**单调递减双端队列**维护滑动窗口中的候选最大值下标，通过**淘汰“又小又老”的元素**，实现 **O(n) 时间**高效求解。

------



# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();  // 存储下标
        List<Integer> result = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            // 1. 移除队首：如果队首下标已经不在当前窗口 [i - k + 1, i] 中
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // 2. 维护单调递减：从队尾移除所有 <= nums[i] 的元素（它们不可能成为最大值）
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }

            // 3. 当前下标入队
            deque.offerLast(i);

            // 4. 当窗口形成（i >= k - 1），记录最大值（队首）
            if (i >= k - 1) {
                result.add(nums[deque.peekFirst()]);
            }
        }
        
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

![239_滑动窗口最大值_Java]()

## Python代码

```Python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        dq = deque()  # 存储下标
        result = []

        for i in range(len(nums)):
            # 1. 移除队首：如果下标已不在窗口 [i - k + 1, i] 内
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            
            # 2. 维护单调递减：从队尾移除所有 <= nums[i] 的元素
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()

            # 3. 当前下标入队
            dq.append(i)

            # 4. 窗口形成后（i - k + 1），记录最大值
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result
```



## C++代码

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;  // 存储下标
        vector<int> result;

        for (int i = 0; i < nums.size(); i++) {
            // 1. 移除队首：如果下标已不在当前窗口 [i - k + 1, i] 内
            if (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }

            // 2. 维护单调递减：从队尾移除所有 <= nums[i] 的元素
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }

            // 3. 当前下标入队
            dq.push_back(i);

            // 4. 窗口形成后（i >= k - 1），记录最大值
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }

        return result;
    }
};
```

