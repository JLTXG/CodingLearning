æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[3719. æœ€é•¿å¹³è¡¡å­æ•°ç»„ I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-balanced-subarray-i/description/?envType=daily-question&envId=2026-02-10)

>æ ‡ç­¾ï¼šé«˜çº§å·¥ç¨‹å¸ˆ  |  çº¿æ®µæ ‘  |  æ•°ç»„  |  å“ˆå¸Œè¡¨  |  åˆ†æ²»  |  å‰ç¼€å’Œ

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå¯¹äºä¸€ä¸ªè¿ç»­éç©ºçš„å­æ•°ç»„ï¼Œå¦‚æœå…¶ä¸­åŒ…å«çš„**äº’ä¸ç›¸åŒçš„å¶æ•°**çš„ä¸ªæ•°ç­‰äº**äº’ä¸ç›¸åŒçš„å¥‡æ•°**çš„ä¸ªæ•°ï¼Œåˆ™ç§°è¯¥å­æ•°ç»„æ˜¯**å¹³è¡¡çš„**ã€‚è¯·æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­**æœ€é•¿å¹³è¡¡å­æ•°ç»„**çš„é•¿åº¦ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼š`nums = [2,5,4,3]`ï¼Œæ•´ä¸ªæ•°ç»„åŒ…å«ä¸¤ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2 å’Œ 4ï¼‰å’Œä¸¤ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ5 å’Œ 3ï¼‰ï¼Œå› æ­¤æœ€é•¿å¹³è¡¡å­æ•°ç»„é•¿åº¦ä¸º 4ã€‚
- **ç¤ºä¾‹2**ï¼š`nums = [3,2,2,5,4]`ï¼Œæ•´ä¸ªæ•°ç»„åŒ…å«ä¸¤ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2 å’Œ 4ï¼‰å’Œä¸¤ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ3 å’Œ 5ï¼‰ï¼Œé•¿åº¦ä¸º 5ã€‚
- **ç¤ºä¾‹3**ï¼š`nums = [1,2,3,2]`ï¼Œå­æ•°ç»„ `[2,3,2]` åŒ…å«ä¸€ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2ï¼‰å’Œä¸€ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ3ï¼‰ï¼Œé•¿åº¦ä¸º 3ã€‚

## **æ•°æ®èŒƒå›´**

- æ•°ç»„é•¿åº¦ `n` æ»¡è¶³ `1 â‰¤ n â‰¤ 1500`ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ»¡è¶³ `1 â‰¤ nums[i] â‰¤ 10^5`ã€‚



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… ç¬¬ä¸€éƒ¨åˆ†ï¼šå½“å‰ä»£ç æ³¨é‡Š

```java
// æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼šæ”¯æŒåŒºé—´åŠ ã€æŸ¥è¯¢æŸå€¼é¦–æ¬¡å‡ºç°ä½ç½®
class LazySegmentTree {
    private static final class Node {
        int min;   // å½“å‰åŒºé—´æœ€å°å€¼
        int max;   // å½“å‰åŒºé—´æœ€å¤§å€¼
        int todo;  // æ‡’æ ‡è®°ï¼ˆå¾…ä¸‹ä¼ çš„å¢é‡ï¼‰
    }

    // å°†æ‡’æ ‡è®° todo åº”ç”¨åˆ° node èŠ‚ç‚¹
    private void apply(int node, int todo) {
        Node cur = tree[node];
        cur.min += todo;
        cur.max += todo;
        cur.todo += todo; // ç´¯åŠ æ‡’æ ‡è®°ï¼ˆå› ä¸ºå¯èƒ½å¤šæ¬¡æ›´æ–°ï¼‰
    }

    private final int n;
    private final Node[] tree;

    // æ„é€ å‡½æ•°ï¼šç»´æŠ¤é•¿åº¦ä¸º n çš„æ•°ç»„ï¼ˆä¸‹æ ‡ 0 ~ n-1ï¼‰
    public LazySegmentTree(int n) {
        this.n = n;
        // åˆ†é…è¶³å¤Ÿç©ºé—´ï¼š2 << ceil(log2(n))ï¼Œç¡®ä¿æ˜¯æ»¡äºŒå‰æ ‘
        // ä¾‹å¦‚ n=5 â†’ n-1=4 (100) â†’ leadingZeros=29 â†’ 32-29=3 â†’ 2<<3 = 16
        tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];
        Arrays.setAll(tree, _ -> new Node());
    }

    // åŒºé—´æ›´æ–°ï¼šå¯¹ [ql, qr] æ¯ä¸ªå…ƒç´ åŠ  f
    public void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    // æŸ¥è¯¢ï¼šåœ¨ [ql, qr] ä¸­ç¬¬ä¸€ä¸ªå€¼ç­‰äº target çš„ä¸‹æ ‡ï¼Œä¸å­˜åœ¨è¿”å› -1
    public int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }

    // ä¸‹ä¼ æ‡’æ ‡è®°åˆ°å·¦å³å­èŠ‚ç‚¹
    private void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);       // å·¦å„¿å­
        apply(node * 2 + 1, todo);   // å³å„¿å­
        tree[node].todo = 0;         // æ¸…ç©ºå½“å‰èŠ‚ç‚¹æ‡’æ ‡è®°
    }

    // åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯åˆ°å½“å‰èŠ‚ç‚¹
    private void maintain(int node) {
        tree[node].min = Math.min(tree[node * 2].min, tree[node * 2 + 1].min);
        tree[node].max = Math.max(tree[node * 2].max, tree[node * 2 + 1].max);
    }

    // é€’å½’åŒºé—´æ›´æ–°
    private void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) { // å®Œå…¨è¦†ç›–
            apply(node, f);
            return;
        }
        spread(node); // ä¸‹ä¼ æ‡’æ ‡è®°
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node); // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¿¡æ¯
    }

    // é€’å½’æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äº target çš„ä½ç½®
    private int findFirst(int node, int l, int r, int ql, int qr, int target) {
        // å‰ªæï¼šåŒºé—´ä¸äº¤ æˆ– target ä¸åœ¨ [min, max] èŒƒå›´å†…
        if (l > qr || r < ql || target < tree[node].min || target > tree[node].max) {
            return -1;
        }
        if (l == r) { // å¶å­èŠ‚ç‚¹ï¼Œå¿…ç„¶æ˜¯ç­”æ¡ˆ
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        // ä¼˜å…ˆæŸ¥å·¦å­æ ‘ï¼ˆä¿è¯â€œç¬¬ä¸€ä¸ªâ€ï¼‰
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }
}

class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        // çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€å’Œæ•°ç»„ sum[0..n]ï¼Œå…± n+1 ä¸ªå…ƒç´ 
        LazySegmentTree t = new LazySegmentTree(n + 1);

        // last[x] = x ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆ1-indexedï¼‰
        Map<Integer, Integer> last = new HashMap<>();
        int ans = 0;
        int curSum = 0; // å½“å‰å‰ç¼€å’Œï¼ˆä» sum[0]=0 å¼€å§‹ï¼‰

        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            // å°†å¥‡æ•°æ˜ å°„ä¸º +1ï¼Œå¶æ•°æ˜ å°„ä¸º -1
            int v = (x % 2 == 1) ? 1 : -1;

            Integer j = last.get(x);
            if (j == null) {
                // é¦–æ¬¡é‡åˆ° xï¼šä»ä½ç½® i å¼€å§‹ï¼Œæ‰€æœ‰åç»­å‰ç¼€å’Œéƒ½è¦ +v
                curSum += v;
                t.update(i, n, v); // sum[i..n] += v
            } else {
                // å†æ¬¡é‡åˆ° xï¼šæ’¤é”€ä¸Šä¸€æ¬¡å¯¹ [j, i-1] çš„ +v
                t.update(j, i - 1, -v);
            }
            last.put(x, i);

            // å…³é”®ä¼˜åŒ–ï¼šåªåœ¨ [0, i-1-ans] èŒƒå›´å†…æŸ¥æ‰¾
            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l;
            }
        }
        return ans;
    }
}
```

> âš ï¸ **é‡è¦æé†’**ï¼šè¿™æ®µä»£ç æ˜¯ä¸º **ã€Œæœ€é•¿å¹³è¡¡å­æ•°ç»„ IIã€**ï¼ˆæœ‰æ•°å­—é¢‘æ¬¡é™åˆ¶ï¼‰è®¾è®¡çš„ã€‚
> è€Œ **æœ¬é¢˜ï¼ˆIï¼‰æ²¡æœ‰é¢‘æ¬¡é™åˆ¶**ï¼Œæ‰€ä»¥è¿™ä¸ªè§£æ³•**è™½ç„¶èƒ½è¿‡ï¼Œä½†ä¸¥é‡è¿‡åº¦è®¾è®¡**ï¼

------

## âœ… ç¬¬äºŒéƒ¨åˆ†ï¼šæœ¬é¢˜ï¼ˆIï¼‰çš„æ­£ç¡®è§£æ³•

### ğŸ” é¢˜ç›®è¦æ±‚ï¼ˆIï¼‰ï¼š

æ‰¾æœ€é•¿å­æ•°ç»„ï¼Œä½¿å¾— **å¥‡æ•°ä¸ªæ•° = å¶æ•°ä¸ªæ•°**ã€‚

> æ²¡æœ‰ä»»ä½•å…¶ä»–é™åˆ¶ï¼åŒä¸€ä¸ªæ•°å­—å¯ä»¥å‡ºç°ä»»æ„å¤šæ¬¡ã€‚

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š**å‰ç¼€å’Œ + å“ˆå¸Œè¡¨**

- å®šä¹‰ï¼š`sum[i] = (å¥‡æ•°ä¸ªæ•° - å¶æ•°ä¸ªæ•°)` ä» `0` åˆ° `i-1`
- æ˜ å°„ï¼šå¥‡æ•° â†’ `+1`ï¼Œå¶æ•° â†’ `-1`
- è‹¥ `sum[r+1] == sum[l]`ï¼Œåˆ™å­æ•°ç»„ `[l, r]` æ˜¯å¹³è¡¡çš„ï¼ˆå’Œä¸º 0ï¼‰
- ç”¨å“ˆå¸Œè¡¨è®°å½•**æ¯ä¸ªå‰ç¼€å’Œç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®**ï¼Œä»¥è·å¾—æœ€é•¿å­æ•°ç»„

### ğŸŒ° ä¾‹å­ï¼š

```
nums = [1, 2, 3, 4]
æ˜ å°„ï¼š[+1, -1, +1, -1]
å‰ç¼€å’Œï¼š[0, 1, 0, 1, 0]

sum=0 å‡ºç°åœ¨ -1, 1, 3 â†’ æœ€é•¿ï¼š3 - (-1) = 4 â†’ [1,2,3,4]
```

------

## ğŸ“š ç¬¬ä¸‰éƒ¨åˆ†ï¼šç¬”è®°æ€»ç»“ï¼ˆé’ˆå¯¹æœ¬é¢˜ Iï¼‰

### ğŸ§© é—®é¢˜å®šä¹‰ï¼š

æ‰¾æœ€é•¿è¿ç»­å­æ•°ç»„ï¼Œå…¶ä¸­ **å¥‡æ•°ä¸ªæ•° = å¶æ•°ä¸ªæ•°**ã€‚

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š

> **å‰ç¼€å’Œ + å“ˆå¸Œè¡¨è®°å½•é¦–æ¬¡å‡ºç°ä½ç½®**

#### æ­¥éª¤ï¼š

1. å°†å¥‡æ•°è§†ä¸º `+1`ï¼Œå¶æ•°è§†ä¸º `-1`ï¼›
2. è®¡ç®—å‰ç¼€å’Œ `sum`ï¼›
3. è‹¥ `sum` ä¹‹å‰å‡ºç°è¿‡ï¼Œåˆ™ `[first[sum]+1, i]` æ˜¯å¹³è¡¡å­æ•°ç»„ï¼›
4. ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ª `sum` **ç¬¬ä¸€æ¬¡**å‡ºç°çš„ä¸‹æ ‡ï¼ˆä»¥æœ€å¤§åŒ–é•¿åº¦ï¼‰ã€‚

### â±ï¸ å¤æ‚åº¦ï¼š

- **æ—¶é—´**ï¼šO(n)
- **ç©ºé—´**ï¼šO(n)ï¼ˆå“ˆå¸Œè¡¨ï¼‰

### âœ… å…³é”®æŠ€å·§ï¼š

- åˆå§‹åŒ– `map.put(0, -1)` å¤„ç†ä»å¼€å¤´å¼€å§‹çš„å¹³è¡¡å­æ•°ç»„ï¼›
- **åªå­˜ç¬¬ä¸€æ¬¡å‡ºç°ä½ç½®**ï¼Œæ‰èƒ½å¾—åˆ°æœ€é•¿å­æ•°ç»„ã€‚

### âŒ å¸¸è§è¯¯åŒºï¼š

- è¯•å›¾ç”¨æ»‘åŠ¨çª—å£ï¼ˆæ— æ³•åˆ¤æ–­ä½•æ—¶æ”¶ç¼©ï¼‰ï¼›
- ç”¨çº¿æ®µæ ‘/å¤æ‚æ•°æ®ç»“æ„ï¼ˆæœ¬é¢˜ä¸éœ€è¦ï¼ï¼‰ã€‚

------

## ğŸ“Œ æ€»ç»“

| é—®é¢˜ç‰ˆæœ¬       | è§£æ³•                      | å¤æ‚åº¦     |
| -------------- | ------------------------- | ---------- |
| **Iï¼ˆæœ¬é¢˜ï¼‰**  | å‰ç¼€å’Œ + å“ˆå¸Œè¡¨           | O(n)       |
| **IIï¼ˆè¿›é˜¶ï¼‰** | æ‡’æ ‡è®°çº¿æ®µæ ‘ + åŠ¨æ€å‰ç¼€å’Œ | O(n log n) |

> âœ… å¯¹äº **æœ¬é¢˜ï¼ˆIï¼‰**ï¼Œè¯·ä½¿ç”¨ **ç®€æ´çš„å‰ç¼€å’Œè§£æ³•**ï¼Œä¸è¦ç”¨çº¿æ®µæ ‘ï¼

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
// æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼šæ”¯æŒåŒºé—´åŠ ã€æŸ¥è¯¢æŸå€¼é¦–æ¬¡å‡ºç°ä½ç½®
class LazySegmentTree {
    private static final class Node {
        int min;   // å½“å‰åŒºé—´æœ€å°å€¼
        int max;   // å½“å‰åŒºé—´æœ€å¤§å€¼
        int todo;  // æ‡’æ ‡è®°ï¼ˆå¾…ä¸‹ä¼ çš„å¢é‡ï¼‰
    }

    // å°†æ‡’æ ‡è®° todo åº”ç”¨åˆ° node èŠ‚ç‚¹
    private void apply(int node, int todo) {
        Node cur = tree[node];
        cur.min += todo;
        cur.max += todo;
        cur.todo += todo; // ç´¯åŠ æ‡’æ ‡è®°ï¼ˆå› ä¸ºå¯èƒ½å¤šæ¬¡æ›´æ–°ï¼‰
    }

    private final int n;
    private final Node[] tree;

    // æ„é€ å‡½æ•°ï¼šç»´æŠ¤é•¿åº¦ä¸º n çš„æ•°ç»„ï¼ˆä¸‹æ ‡ 0 ~ n-1ï¼‰
    public LazySegmentTree(int n) {
        this.n = n;
        // åˆ†é…è¶³å¤Ÿç©ºé—´ï¼š2 << ceil(log2(n))ï¼Œç¡®ä¿æ˜¯æ»¡äºŒå‰æ ‘
        tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];
        Arrays.setAll(tree, _ -> new Node());
    }

    // åŒºé—´æ›´æ–°ï¼šå¯¹ [ql, qr] æ¯ä¸ªå…ƒç´ åŠ  f
    public void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    // æŸ¥è¯¢ï¼šåœ¨ [ql, qr] ä¸­ç¬¬ä¸€ä¸ªå€¼ç­‰äº target çš„ä¸‹æ ‡ï¼Œä¸å­˜åœ¨è¿”å› -1
    public int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }

    // ä¸‹ä¼ æ‡’æ ‡è®°åˆ°å·¦å³å­èŠ‚ç‚¹
    private void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);       // å·¦å„¿å­
        apply(node * 2 + 1, todo);   // å³å„¿å­
        tree[node].todo = 0;         // æ¸…ç©ºå½“å‰èŠ‚ç‚¹æ‡’æ ‡è®°
    }

    // åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯åˆ°å½“å‰èŠ‚ç‚¹
    private void maintain(int node) {
        tree[node].min = Math.min(tree[node * 2].min, tree[node * 2 + 1].min);
        tree[node].max = Math.max(tree[node * 2].max, tree[node * 2 + 1].max);
    }

    // é€’å½’åŒºé—´æ›´æ–°
    private void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) { // å®Œå…¨è¦†ç›–
            apply(node, f);
            return;
        }
        spread(node); // ä¸‹ä¼ æ‡’æ ‡è®°
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node); // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¿¡æ¯
    }

    // é€’å½’æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äº target çš„ä½ç½®
    private int findFirst(int node, int l, int r, int ql, int qr, int target) {
        // å‰ªæï¼šåŒºé—´ä¸äº¤ æˆ– target ä¸åœ¨ [min, max] èŒƒå›´å†…
        if (l > qr || r < ql || target < tree[node].min || target > tree[node].max) {
            return -1;
        }
        if (l == r) { // å¶å­èŠ‚ç‚¹ï¼Œå¿…ç„¶æ˜¯ç­”æ¡ˆ
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        // ä¼˜å…ˆæŸ¥å·¦å­æ ‘ï¼ˆä¿è¯â€œç¬¬ä¸€ä¸ªâ€ï¼‰
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }
}

class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        // çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€å’Œæ•°ç»„ sum[0..n]ï¼Œå…± n+1 ä¸ªå…ƒç´ 
        LazySegmentTree t = new LazySegmentTree(n + 1);

        // last[x] = x ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆ1-indexedï¼‰
        Map<Integer, Integer> last = new HashMap<>();
        int ans = 0;
        int curSum = 0; // å½“å‰å‰ç¼€å’Œï¼ˆä» sum[0]=0 å¼€å§‹ï¼‰

        // i ä» 1 åˆ° nï¼Œå¯¹åº” nums[i-1]
        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            // å°†å¥‡æ•°æ˜ å°„ä¸º +1ï¼Œå¶æ•°æ˜ å°„ä¸º -1
            int v = (x % 2 == 1) ? 1 : -1;

            Integer j = last.get(x);
            if (j == null) {
                // é¦–æ¬¡é‡åˆ° xï¼šä»ä½ç½® i å¼€å§‹ï¼Œæ‰€æœ‰åç»­å‰ç¼€å’Œéƒ½è¦ +v
                curSum += v;
                t.update(i, n, v); // sum[i..n] += v
            } else {
                // å†æ¬¡é‡åˆ° xï¼šæ’¤é”€ä¸Šä¸€æ¬¡å¯¹ [j, i-1] çš„ +vï¼ˆå› ä¸ºç°åœ¨ x å‡ºç°ä¸¤æ¬¡ï¼Œä¸­é—´éƒ¨åˆ†ä¸èƒ½å†è´¡çŒ®ï¼‰
                t.update(j, i - 1, -v);
                // æ³¨æ„ï¼šç¬¬ä¸‰æ¬¡åŠä»¥åå‡ºç°æ—¶ï¼Œä¼šç»§ç»­æ’¤é”€ä¹‹å‰çš„è´¡çŒ®ï¼Œç¡®ä¿åªæœ‰æœ€è¿‘ä¸¤æ¬¡æœ‰æ•ˆ
            }
            last.put(x, i); // æ›´æ–° x çš„æœ€æ–°ä½ç½®

            // å…³é”®ä¼˜åŒ–ï¼šåªåœ¨ [0, i-1-ans] èŒƒå›´å†…æŸ¥æ‰¾
            // å› ä¸ºæˆ‘ä»¬è¦æ‰¾æ›´é•¿çš„å­æ•°ç»„ï¼Œæ‰€ä»¥ l å¿…é¡» â‰¤ i-1-ansï¼Œå¦åˆ™é•¿åº¦ â‰¤ ans
            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l; // å­æ•°ç»„ [l, i-1] é•¿åº¦ä¸º i - l
            }
        }
        return ans;
    }
}
```

![3719_æœ€é•¿å¹³è¡¡å­æ•°ç»„ I_Java]()

## Pythonä»£ç 

```python
class LazySegmentTree:
    class Node:
        __slots__ = ('min_val', 'max_val', 'todo')
        def __init__(self):
            self.min_val = 0
            self.max_val = 0
            self.todo = 0

    def __init__(self, n: int):
        self.n = n
        # è®¡ç®—æ ‘å¤§å°ï¼š2 << ceil(log2(n))
        if n <= 1:
            size = 2
        else:
            import sys
            bits = n - 1
            leading_zeros = (bits).bit_length()
            size = 2 << (32 - leading_zeros) if sys.maxsize > 2**32 else 2 << (64 - leading_zeros)
            # æ›´ç®€å•ä¸”å®‰å…¨çš„æ–¹å¼ï¼šç›´æ¥ç”¨ 4 * n
            size = 4 * n
        self.tree = [self.Node() for _ in range(size)]

    def _apply(self, node: int, todo: int):
        cur = self.tree[node]
        cur.min_val += todo
        cur.max_val += todo
        cur.todo += todo

    def _spread(self, node: int):
        todo = self.tree[node].todo
        if todo == 0:
            return
        self._apply(node * 2, todo)
        self._apply(node * 2 + 1, todo)
        self.tree[node].todo = 0

    def _maintain(self, node: int):
        left = self.tree[node * 2]
        right = self.tree[node * 2 + 1]
        self.tree[node].min_val = min(left.min_val, right.min_val)
        self.tree[node].max_val = max(left.max_val, right.max_val)

    def _update(self, node: int, l: int, r: int, ql: int, qr: int, f: int):
        if ql <= l and r <= qr:
            self._apply(node, f)
            return
        self._spread(node)
        m = (l + r) // 2
        if ql <= m:
            self._update(node * 2, l, m, ql, qr, f)
        if qr > m:
            self._update(node * 2 + 1, m + 1, r, ql, qr, f)
        self._maintain(node)

    def update(self, ql: int, qr: int, f: int):
        self._update(1, 0, self.n - 1, ql, qr, f)

    def _find_first(self, node: int, l: int, r: int, ql: int, qr: int, target: int) -> int:
        if l > qr or r < ql or target < self.tree[node].min_val or target > self.tree[node].max_val:
            return -1
        if l == r:
            return l
        self._spread(node)
        m = (l + r) // 2
        idx = self._find_first(node * 2, l, m, ql, qr, target)
        if idx < 0:
            idx = self._find_first(node * 2 + 1, m + 1, r, ql, qr, target)
        return idx

    def find_first(self, ql: int, qr: int, target: int) -> int:
        return self._find_first(1, 0, self.n - 1, ql, qr, target)


class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        t = LazySegmentTree(n + 1)

        last: Dict[int, int] = {}
        ans = 0
        cur_sum = 0

        for i in range(1, n + 1):
            x = nums[i - 1]
            v = 1 if x % 2 == 1 else -1
            j = last.get(x)
            if j is None:
                cur_sum += v
                t.update(i, n, v)
            else:
                t.update(j, i - 1, -v)
            last[x] = i

            l = t.find_first(0, i - 1 - ans, cur_sum)
            if l >= 0:
                ans = i - l

        return ans  
```



## C++ä»£ç 

```C++
class LazySegmentTree {
private:
    struct Node {
        int min_val = 0;
        int max_val = 0;
        int todo = 0;
    };

    void apply(int node, int todo) {
        tree[node].min_val += todo;
        tree[node].max_val += todo;
        tree[node].todo += todo;
    }

    int n;
    vector<Node> tree;

    void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);
        apply(node * 2 + 1, todo);
        tree[node].todo = 0;
    }

    void maintain(int node) {
        tree[node].min_val = min(tree[node * 2].min_val, tree[node * 2 + 1].min_val);
        tree[node].max_val = max(tree[node * 2].max_val, tree[node * 2 + 1].max_val);
    }

    void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) {
            apply(node, f);
            return;
        }
        spread(node);
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node);
    }

    int findFirst(int node, int l, int r, int ql, int qr, int target) {
        if (l > qr || r < ql || target < tree[node].min_val || target > tree[node].max_val) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }

public:
    LazySegmentTree(int n) : n(n) {
        int size = 2 << (32 - __builtin_clz(n - 1));
        tree.resize(size);
    }

    void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }
};

class Solution {
public:
    int longestBalanced(vector<int>& nums) {
        int n = nums.size();
        LazySegmentTree t(n + 1);

        unordered_map<int, int> last;
        int ans = 0;
        int curSum = 0;

        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            int v = (x % 2 == 1) ? 1 : -1;
            auto it = last.find(x);
            if (it == last.end()) {
                curSum += v;
                t.update(i, n, v);
            } else {
                t.update(it->second, i - 1, -v);
            }
            last[x] = i;

            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l;
            }
        }
        return ans;
    }
};
```

