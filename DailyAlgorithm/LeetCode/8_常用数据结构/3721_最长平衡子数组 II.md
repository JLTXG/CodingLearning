æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[3721. æœ€é•¿å¹³è¡¡å­æ•°ç»„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-balanced-subarray-ii/description/?envType=daily-question&envId=2026-02-11)

>æ ‡ç­¾ï¼šé«˜çº§å·¥ç¨‹å¸ˆ  |  çº¿æ®µæ ‘  |  æ•°ç»„  |  å“ˆå¸Œè¡¨  |  åˆ†æ²»  |  å‰ç¼€å’Œ

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå¯¹äºä¸€ä¸ªè¿ç»­éç©ºçš„å­æ•°ç»„ï¼Œå¦‚æœå…¶ä¸­åŒ…å«çš„**ä¸åŒå¶æ•°å€¼**çš„æ•°é‡ç­‰äº**ä¸åŒå¥‡æ•°å€¼**çš„æ•°é‡ï¼Œåˆ™ç§°è¯¥å­æ•°ç»„æ˜¯â€œå¹³è¡¡çš„â€ã€‚è¯·æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­**æœ€é•¿å¹³è¡¡å­æ•°ç»„**çš„é•¿åº¦ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼š`nums = [2,5,4,3]`ï¼Œæ•´ä¸ªæ•°ç»„åŒ…å«ä¸¤ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2 å’Œ 4ï¼‰å’Œä¸¤ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ5 å’Œ 3ï¼‰ï¼Œå› æ­¤æœ€é•¿å¹³è¡¡å­æ•°ç»„é•¿åº¦ä¸º 4ã€‚
- **ç¤ºä¾‹2**ï¼š`nums = [3,2,2,5,4]`ï¼Œæ•´ä¸ªæ•°ç»„åŒ…å«ä¸¤ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2 å’Œ 4ï¼‰å’Œä¸¤ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ3 å’Œ 5ï¼‰ï¼Œé•¿åº¦ä¸º 5ã€‚
- **ç¤ºä¾‹3**ï¼š`nums = [1,2,3,2]`ï¼Œå­æ•°ç»„ `[2,3,2]` åŒ…å«ä¸€ä¸ªä¸åŒçš„å¶æ•°ï¼ˆ2ï¼‰å’Œä¸€ä¸ªä¸åŒçš„å¥‡æ•°ï¼ˆ3ï¼‰ï¼Œé•¿åº¦ä¸º 3ã€‚

## **æ•°æ®èŒƒå›´**

- æ•°ç»„é•¿åº¦ `n` æ»¡è¶³ `1 â‰¤ n â‰¤ 10^5`ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ»¡è¶³ `1 â‰¤ nums[i] â‰¤ 10^5`ã€‚



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„å®Œæ•´ä»£ç 

### ğŸ§© å…ˆç†è§£é¢˜æ„

> **â€œå¹³è¡¡å­æ•°ç»„â€å®šä¹‰**ï¼šå­æ•°ç»„ä¸­ **å¥‡æ•°ä¸ªæ•° = å¶æ•°ä¸ªæ•°**ã€‚
> å³ï¼šè‹¥æŠŠå¥‡æ•°çœ‹ä½œ `+1`ï¼Œå¶æ•°çœ‹ä½œ `-1`ï¼Œåˆ™å­æ•°ç»„çš„**å’Œä¸º 0**ã€‚

> **ä½†æœ¬é¢˜æœ‰é¢å¤–é™åˆ¶**ï¼šå­æ•°ç»„ä¸­**æ¯ä¸ªæ•°å­—æœ€å¤šå‡ºç°ä¸¤æ¬¡**ï¼
> æ¢å¥è¯è¯´ï¼šå­æ•°ç»„ä¸­ä¸èƒ½æœ‰æŸä¸ªæ•°å­—å‡ºç° **3 æ¬¡æˆ–ä»¥ä¸Š**ã€‚

æ‰€ä»¥é—®é¢˜è½¬åŒ–ä¸ºï¼š
**æ‰¾æœ€é•¿çš„å­æ•°ç»„ `[l, r]`ï¼Œä½¿å¾—ï¼š**

1. å­æ•°ç»„çš„â€œå¥‡å¶å’Œâ€ä¸º 0ï¼ˆå³ `prefix[r+1] == prefix[l]`ï¼‰ï¼›
2. å­æ•°ç»„ä¸­ä»»æ„æ•°å­—å‡ºç°æ¬¡æ•° â‰¤ 2ã€‚

------

### ğŸ“ æ³¨é‡Šç‰ˆä»£ç 

```java
// æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼šæ”¯æŒåŒºé—´åŠ ã€æŸ¥è¯¢æŸå€¼é¦–æ¬¡å‡ºç°ä½ç½®
class LazySegmentTree {
    private static final class Node {
        int min;   // å½“å‰åŒºé—´æœ€å°å€¼
        int max;   // å½“å‰åŒºé—´æœ€å¤§å€¼
        int todo;  // æ‡’æ ‡è®°ï¼ˆå¾…ä¸‹ä¼ çš„å¢é‡ï¼‰
    }

    // å°†æ‡’æ ‡è®° todo åº”ç”¨åˆ° node èŠ‚ç‚¹
    private void apply(int node, int todo) {
        Node cur = tree[node];
        cur.min += todo;
        cur.max += todo;
        cur.todo += todo; // ç´¯åŠ æ‡’æ ‡è®°ï¼ˆå› ä¸ºå¯èƒ½å¤šæ¬¡æ›´æ–°ï¼‰
    }

    private final int n;
    private final Node[] tree;

    // æ„é€ å‡½æ•°ï¼šç»´æŠ¤é•¿åº¦ä¸º n çš„æ•°ç»„ï¼ˆä¸‹æ ‡ 0 ~ n-1ï¼‰
    public LazySegmentTree(int n) {
        this.n = n;
        // åˆ†é…è¶³å¤Ÿç©ºé—´ï¼š2 << ceil(log2(n))ï¼Œç¡®ä¿æ˜¯æ»¡äºŒå‰æ ‘
        tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];
        Arrays.setAll(tree, _ -> new Node());
    }

    // åŒºé—´æ›´æ–°ï¼šå¯¹ [ql, qr] æ¯ä¸ªå…ƒç´ åŠ  f
    public void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    // æŸ¥è¯¢ï¼šåœ¨ [ql, qr] ä¸­ç¬¬ä¸€ä¸ªå€¼ç­‰äº target çš„ä¸‹æ ‡ï¼Œä¸å­˜åœ¨è¿”å› -1
    public int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }

    // ä¸‹ä¼ æ‡’æ ‡è®°åˆ°å·¦å³å­èŠ‚ç‚¹
    private void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);       // å·¦å„¿å­
        apply(node * 2 + 1, todo);   // å³å„¿å­
        tree[node].todo = 0;         // æ¸…ç©ºå½“å‰èŠ‚ç‚¹æ‡’æ ‡è®°
    }

    // åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯åˆ°å½“å‰èŠ‚ç‚¹
    private void maintain(int node) {
        tree[node].min = Math.min(tree[node * 2].min, tree[node * 2 + 1].min);
        tree[node].max = Math.max(tree[node * 2].max, tree[node * 2 + 1].max);
    }

    // é€’å½’åŒºé—´æ›´æ–°
    private void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) { // å®Œå…¨è¦†ç›–
            apply(node, f);
            return;
        }
        spread(node); // ä¸‹ä¼ æ‡’æ ‡è®°
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node); // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¿¡æ¯
    }

    // é€’å½’æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äº target çš„ä½ç½®
    private int findFirst(int node, int l, int r, int ql, int qr, int target) {
        // å‰ªæï¼šåŒºé—´ä¸äº¤ æˆ– target ä¸åœ¨ [min, max] èŒƒå›´å†…
        if (l > qr || r < ql || target < tree[node].min || target > tree[node].max) {
            return -1;
        }
        if (l == r) { // å¶å­èŠ‚ç‚¹ï¼Œå¿…ç„¶æ˜¯ç­”æ¡ˆ
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        // ä¼˜å…ˆæŸ¥å·¦å­æ ‘ï¼ˆä¿è¯â€œç¬¬ä¸€ä¸ªâ€ï¼‰
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }
}

class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        // çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€å’Œæ•°ç»„ sum[0..n]ï¼Œå…± n+1 ä¸ªå…ƒç´ 
        LazySegmentTree t = new LazySegmentTree(n + 1);

        // last[x] = x ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆ1-indexedï¼‰
        Map<Integer, Integer> last = new HashMap<>();
        int ans = 0;
        int curSum = 0; // å½“å‰å‰ç¼€å’Œï¼ˆä» sum[0]=0 å¼€å§‹ï¼‰

        // i ä» 1 åˆ° nï¼Œå¯¹åº” nums[i-1]
        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            // å°†å¥‡æ•°æ˜ å°„ä¸º +1ï¼Œå¶æ•°æ˜ å°„ä¸º -1
            int v = (x % 2 == 1) ? 1 : -1;

            Integer j = last.get(x);
            if (j == null) {
                // é¦–æ¬¡é‡åˆ° xï¼šä»ä½ç½® i å¼€å§‹ï¼Œæ‰€æœ‰åç»­å‰ç¼€å’Œéƒ½è¦ +v
                curSum += v;
                t.update(i, n, v); // sum[i..n] += v
            } else {
                // å†æ¬¡é‡åˆ° xï¼šæ’¤é”€ä¸Šä¸€æ¬¡å¯¹ [j, i-1] çš„ +vï¼ˆå› ä¸ºç°åœ¨ x å‡ºç°ä¸¤æ¬¡ï¼Œä¸­é—´éƒ¨åˆ†ä¸èƒ½å†è´¡çŒ®ï¼‰
                t.update(j, i - 1, -v);
                // æ³¨æ„ï¼šç¬¬ä¸‰æ¬¡åŠä»¥åå‡ºç°æ—¶ï¼Œä¼šç»§ç»­æ’¤é”€ä¹‹å‰çš„è´¡çŒ®ï¼Œç¡®ä¿åªæœ‰æœ€è¿‘ä¸¤æ¬¡æœ‰æ•ˆ
            }
            last.put(x, i); // æ›´æ–° x çš„æœ€æ–°ä½ç½®

            // å…³é”®ä¼˜åŒ–ï¼šåªåœ¨ [0, i-1-ans] èŒƒå›´å†…æŸ¥æ‰¾
            // å› ä¸ºæˆ‘ä»¬è¦æ‰¾æ›´é•¿çš„å­æ•°ç»„ï¼Œæ‰€ä»¥ l å¿…é¡» â‰¤ i-1-ansï¼Œå¦åˆ™é•¿åº¦ â‰¤ ans
            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l; // å­æ•°ç»„ [l, i-1] é•¿åº¦ä¸º i - l
            }
        }
        return ans;
    }
}
```

------

## ğŸ§  æ ¸å¿ƒè§£é¢˜æ€æƒ³æ·±åº¦è§£æ

### ğŸ”‘ æ ¸å¿ƒæ´å¯Ÿ 1ï¼š**â€œæœ‰æ•ˆå‰ç¼€å’Œâ€çš„åŠ¨æ€ç»´æŠ¤**

- æ­£å¸¸æƒ…å†µä¸‹ï¼Œè‹¥ `sum[r+1] == sum[l]`ï¼Œåˆ™ `[l, r]` æ˜¯å¹³è¡¡å­æ•°ç»„ã€‚
- ä½†æœ¬é¢˜è¦æ±‚ï¼šå­æ•°ç»„ä¸­æ¯ä¸ªæ•°å­—æœ€å¤šå‡ºç° **2 æ¬¡**ã€‚
- æ‰€ä»¥ï¼Œ**ä¸èƒ½ç®€å•ç”¨é™æ€å‰ç¼€å’Œ**ï¼Œå› ä¸ºå½“æŸä¸ªæ•°å­—å‡ºç°ç¬¬ 3 æ¬¡æ—¶ï¼Œä¹‹å‰çš„éƒ¨åˆ†å‰ç¼€å’Œå°±â€œå¤±æ•ˆâ€äº†ã€‚

> ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼š**åŠ¨æ€ç»´æŠ¤ä¸€ä¸ªâ€œæœ‰æ•ˆå‰ç¼€å’Œâ€æ•°ç»„ `sum`**ï¼Œå…¶ä¸­ï¼š
>
> - `sum[i]` è¡¨ç¤ºä»å¼€å¤´åˆ°ä½ç½® `i-1` çš„â€œæœ‰æ•ˆå¥‡å¶å’Œâ€ï¼›
> - å½“æŸä¸ªæ•°å­— `x` ç¬¬ä¸‰æ¬¡å‡ºç°æ—¶ï¼Œè¦**æ’¤é”€å®ƒç¬¬äºŒæ¬¡å‡ºç°æ—¶å¯¹ä¸­é—´åŒºé—´çš„è´¡çŒ®**ã€‚

### ğŸ”‘ æ ¸å¿ƒæ´å¯Ÿ 2ï¼š**æ‡’æ ‡è®°çº¿æ®µæ ‘çš„ä½œç”¨**

çº¿æ®µæ ‘åœ¨è¿™é‡Œç»´æŠ¤çš„æ˜¯ **åŠ¨æ€å‰ç¼€å’Œæ•°ç»„ `sum[0..n]`**ï¼Œæ”¯æŒï¼š

- **åŒºé—´åŠ **ï¼šå½“æ–°æ•°å­—åŠ å…¥æˆ–æ—§è´¡çŒ®è¢«æ’¤é”€æ—¶ï¼Œæ‰¹é‡æ›´æ–° `sum`ï¼›
- **æŒ‰å€¼æŸ¥è¯¢**ï¼šå¿«é€Ÿæ‰¾åˆ° `sum[l] == curSum` çš„æœ€å° `l`ï¼ˆå³æœ€è¿œçš„èµ·ç‚¹ï¼‰ã€‚

> ä¸ºä»€ä¹ˆéœ€è¦çº¿æ®µæ ‘ï¼Ÿ
> å› ä¸ºå‰ç¼€å’Œåœ¨ä¸æ–­å˜åŒ–ï¼ˆæ’¤é”€æ“ä½œï¼‰ï¼Œæ— æ³•ç”¨æ™®é€šå“ˆå¸Œè¡¨è®°å½•ã€‚

### ğŸ”‘ æ ¸å¿ƒæ´å¯Ÿ 3ï¼š**è´ªå¿ƒä¼˜åŒ–æœç´¢èŒƒå›´**

```java
int l = t.findFirst(0, i - 1 - ans, curSum);
```

- æˆ‘ä»¬åªå…³å¿ƒèƒ½**è®©ç­”æ¡ˆå˜å¤§**çš„ `l`ï¼›
- å½“å‰æœ€é•¿æ˜¯ `ans`ï¼Œæ‰€ä»¥æ–°å­æ•°ç»„é•¿åº¦å¿…é¡» > `ans` â‡’ `i - l > ans` â‡’ `l < i - ans`ï¼›
- å› æ­¤åªéœ€åœ¨ `[0, i-1-ans]` ä¸­æŸ¥æ‰¾ï¼Œå¤§å¹…å‡å°‘æŸ¥è¯¢èŒƒå›´ã€‚

------

## ğŸ“š ç¬”è®°æ€»ç»“

### ğŸ§© é—®é¢˜å®šä¹‰ï¼š

æ‰¾æœ€é•¿å­æ•°ç»„ï¼Œæ»¡è¶³ï¼š

1. å¥‡æ•°ä¸ªæ•° = å¶æ•°ä¸ªæ•°ï¼ˆå³â€œå¥‡å¶å’Œâ€ä¸º 0ï¼‰ï¼›
2. ä»»æ„æ•°å­—å‡ºç°æ¬¡æ•° â‰¤ 2ã€‚

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š

> **åŠ¨æ€å‰ç¼€å’Œ + æ‡’æ ‡è®°çº¿æ®µæ ‘ + è´ªå¿ƒå‰ªæ**

#### æ­¥éª¤åˆ†è§£ï¼š

1. **æ˜ å°„**ï¼šå¥‡æ•° â†’ `+1`ï¼Œå¶æ•° â†’ `-1`ï¼›
2. åŠ¨æ€ç»´æŠ¤å‰ç¼€å’Œ `sum`ï¼š
    - é¦–æ¬¡è§ `x`ï¼šä»å½“å‰ä½ç½®å¼€å§‹ï¼Œæ‰€æœ‰åç»­ `sum` åŠ  `v`ï¼›
    - å†æ¬¡è§ `x`ï¼šæ’¤é”€ä¸Šä¸€æ¬¡å¯¹ `[last[x], i-1]` çš„åŠ æ³•ï¼ˆå› ä¸ºç°åœ¨ `x` å‡ºç°ä¸¤æ¬¡ï¼Œä¸­é—´éƒ¨åˆ†ä»æœ‰æ•ˆï¼‰ï¼›
    - ç¬¬ä¸‰æ¬¡è§ `x`ï¼šä¼šå†æ¬¡æ’¤é”€ï¼Œç¡®ä¿åªæœ‰æœ€è¿‘ä¸¤æ¬¡è´¡çŒ®æœ‰æ•ˆï¼›
3. çº¿æ®µæ ‘æ”¯æŒï¼š
    - åŒºé—´åŠ ï¼ˆ`update`ï¼‰ï¼›
    - æŸ¥è¯¢æŸå€¼é¦–æ¬¡å‡ºç°ä½ç½®ï¼ˆ`findFirst`ï¼‰ï¼›
4. **è´ªå¿ƒä¼˜åŒ–**ï¼šåªåœ¨ `[0, i-1-ans]` ä¸­æŸ¥æ‰¾ï¼Œä¿è¯æ–°ç­”æ¡ˆæ›´ä¼˜ã€‚

### â±ï¸ å¤æ‚åº¦ï¼š

- æ—¶é—´ï¼šO(n log n) â€”â€” æ¯æ¬¡æ›´æ–°/æŸ¥è¯¢ O(log n)
- ç©ºé—´ï¼šO(n) â€”â€” çº¿æ®µæ ‘ç©ºé—´

### ğŸ”‘ å…³é”®æŠ€å·§ï¼š

- **æ‡’æ ‡è®°çº¿æ®µæ ‘ç»´æŠ¤åŠ¨æ€æ•°ç»„**ï¼›
- **é€šè¿‡æ’¤é”€æ“ä½œå®ç°â€œæœ€å¤šä¸¤æ¬¡â€çº¦æŸ**ï¼›
- **åˆ©ç”¨â€œç­”æ¡ˆå•è°ƒä¸å‡â€è¿›è¡Œæœç´¢å‰ªæ**ã€‚

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
// æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼šæ”¯æŒåŒºé—´åŠ ã€æŸ¥è¯¢æŸå€¼é¦–æ¬¡å‡ºç°ä½ç½®
class LazySegmentTree {
    private static final class Node {
        int min;   // å½“å‰åŒºé—´æœ€å°å€¼
        int max;   // å½“å‰åŒºé—´æœ€å¤§å€¼
        int todo;  // æ‡’æ ‡è®°ï¼ˆå¾…ä¸‹ä¼ çš„å¢é‡ï¼‰
    }

    // å°†æ‡’æ ‡è®° todo åº”ç”¨åˆ° node èŠ‚ç‚¹
    private void apply(int node, int todo) {
        Node cur = tree[node];
        cur.min += todo;
        cur.max += todo;
        cur.todo += todo; // ç´¯åŠ æ‡’æ ‡è®°ï¼ˆå› ä¸ºå¯èƒ½å¤šæ¬¡æ›´æ–°ï¼‰
    }

    private final int n;
    private final Node[] tree;

    // æ„é€ å‡½æ•°ï¼šç»´æŠ¤é•¿åº¦ä¸º n çš„æ•°ç»„ï¼ˆä¸‹æ ‡ 0 ~ n-1ï¼‰
    public LazySegmentTree(int n) {
        this.n = n;
        // åˆ†é…è¶³å¤Ÿç©ºé—´ï¼š2 << ceil(log2(n))ï¼Œç¡®ä¿æ˜¯æ»¡äºŒå‰æ ‘
        tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];
        Arrays.setAll(tree, _ -> new Node());
    }

    // åŒºé—´æ›´æ–°ï¼šå¯¹ [ql, qr] æ¯ä¸ªå…ƒç´ åŠ  f
    public void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    // æŸ¥è¯¢ï¼šåœ¨ [ql, qr] ä¸­ç¬¬ä¸€ä¸ªå€¼ç­‰äº target çš„ä¸‹æ ‡ï¼Œä¸å­˜åœ¨è¿”å› -1
    public int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }

    // ä¸‹ä¼ æ‡’æ ‡è®°åˆ°å·¦å³å­èŠ‚ç‚¹
    private void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);       // å·¦å„¿å­
        apply(node * 2 + 1, todo);   // å³å„¿å­
        tree[node].todo = 0;         // æ¸…ç©ºå½“å‰èŠ‚ç‚¹æ‡’æ ‡è®°
    }

    // åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯åˆ°å½“å‰èŠ‚ç‚¹
    private void maintain(int node) {
        tree[node].min = Math.min(tree[node * 2].min, tree[node * 2 + 1].min);
        tree[node].max = Math.max(tree[node * 2].max, tree[node * 2 + 1].max);
    }

    // é€’å½’åŒºé—´æ›´æ–°
    private void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) { // å®Œå…¨è¦†ç›–
            apply(node, f);
            return;
        }
        spread(node); // ä¸‹ä¼ æ‡’æ ‡è®°
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node); // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¿¡æ¯
    }

    // é€’å½’æŸ¥æ‰¾ç¬¬ä¸€ä¸ªç­‰äº target çš„ä½ç½®
    private int findFirst(int node, int l, int r, int ql, int qr, int target) {
        // å‰ªæï¼šåŒºé—´ä¸äº¤ æˆ– target ä¸åœ¨ [min, max] èŒƒå›´å†…
        if (l > qr || r < ql || target < tree[node].min || target > tree[node].max) {
            return -1;
        }
        if (l == r) { // å¶å­èŠ‚ç‚¹ï¼Œå¿…ç„¶æ˜¯ç­”æ¡ˆ
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        // ä¼˜å…ˆæŸ¥å·¦å­æ ‘ï¼ˆä¿è¯â€œç¬¬ä¸€ä¸ªâ€ï¼‰
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }
}

class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        // çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€å’Œæ•°ç»„ sum[0..n]ï¼Œå…± n+1 ä¸ªå…ƒç´ 
        LazySegmentTree t = new LazySegmentTree(n + 1);

        // last[x] = x ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆ1-indexedï¼‰
        Map<Integer, Integer> last = new HashMap<>();
        int ans = 0;
        int curSum = 0; // å½“å‰å‰ç¼€å’Œï¼ˆä» sum[0]=0 å¼€å§‹ï¼‰

        // i ä» 1 åˆ° nï¼Œå¯¹åº” nums[i-1]
        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            // å°†å¥‡æ•°æ˜ å°„ä¸º +1ï¼Œå¶æ•°æ˜ å°„ä¸º -1
            int v = (x % 2 == 1) ? 1 : -1;

            Integer j = last.get(x);
            if (j == null) {
                // é¦–æ¬¡é‡åˆ° xï¼šä»ä½ç½® i å¼€å§‹ï¼Œæ‰€æœ‰åç»­å‰ç¼€å’Œéƒ½è¦ +v
                curSum += v;
                t.update(i, n, v); // sum[i..n] += v
            } else {
                // å†æ¬¡é‡åˆ° xï¼šæ’¤é”€ä¸Šä¸€æ¬¡å¯¹ [j, i-1] çš„ +vï¼ˆå› ä¸ºç°åœ¨ x å‡ºç°ä¸¤æ¬¡ï¼Œä¸­é—´éƒ¨åˆ†ä¸èƒ½å†è´¡çŒ®ï¼‰
                t.update(j, i - 1, -v);
                // æ³¨æ„ï¼šç¬¬ä¸‰æ¬¡åŠä»¥åå‡ºç°æ—¶ï¼Œä¼šç»§ç»­æ’¤é”€ä¹‹å‰çš„è´¡çŒ®ï¼Œç¡®ä¿åªæœ‰æœ€è¿‘ä¸¤æ¬¡æœ‰æ•ˆ
            }
            last.put(x, i); // æ›´æ–° x çš„æœ€æ–°ä½ç½®

            // å…³é”®ä¼˜åŒ–ï¼šåªåœ¨ [0, i-1-ans] èŒƒå›´å†…æŸ¥æ‰¾
            // å› ä¸ºæˆ‘ä»¬è¦æ‰¾æ›´é•¿çš„å­æ•°ç»„ï¼Œæ‰€ä»¥ l å¿…é¡» â‰¤ i-1-ansï¼Œå¦åˆ™é•¿åº¦ â‰¤ ans
            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l; // å­æ•°ç»„ [l, i-1] é•¿åº¦ä¸º i - l
            }
        }
        return ans;
    }
}
```



## Pythonä»£ç 

```python
class LazySegmentTree:
    class Node:
        __slots__ = ('min_val', 'max_val', 'todo')
        def __init__(self):
            self.min_val = 0
            self.max_val = 0
            self.todo = 0

    def __init__(self, n: int):
        self.n = n
        # è®¡ç®—æ ‘å¤§å°ï¼š2 << ceil(log2(n))
        if n <= 1:
            size = 2
        else:
            import sys
            bits = n - 1
            leading_zeros = (bits).bit_length()
            size = 2 << (32 - leading_zeros) if sys.maxsize > 2**32 else 2 << (64 - leading_zeros)
            # æ›´ç®€å•ä¸”å®‰å…¨çš„æ–¹å¼ï¼šç›´æ¥ç”¨ 4 * n
            size = 4 * n
        self.tree = [self.Node() for _ in range(size)]

    def _apply(self, node: int, todo: int):
        cur = self.tree[node]
        cur.min_val += todo
        cur.max_val += todo
        cur.todo += todo

    def _spread(self, node: int):
        todo = self.tree[node].todo
        if todo == 0:
            return
        self._apply(node * 2, todo)
        self._apply(node * 2 + 1, todo)
        self.tree[node].todo = 0

    def _maintain(self, node: int):
        left = self.tree[node * 2]
        right = self.tree[node * 2 + 1]
        self.tree[node].min_val = min(left.min_val, right.min_val)
        self.tree[node].max_val = max(left.max_val, right.max_val)

    def _update(self, node: int, l: int, r: int, ql: int, qr: int, f: int):
        if ql <= l and r <= qr:
            self._apply(node, f)
            return
        self._spread(node)
        m = (l + r) // 2
        if ql <= m:
            self._update(node * 2, l, m, ql, qr, f)
        if qr > m:
            self._update(node * 2 + 1, m + 1, r, ql, qr, f)
        self._maintain(node)

    def update(self, ql: int, qr: int, f: int):
        self._update(1, 0, self.n - 1, ql, qr, f)

    def _find_first(self, node: int, l: int, r: int, ql: int, qr: int, target: int) -> int:
        if l > qr or r < ql or target < self.tree[node].min_val or target > self.tree[node].max_val:
            return -1
        if l == r:
            return l
        self._spread(node)
        m = (l + r) // 2
        idx = self._find_first(node * 2, l, m, ql, qr, target)
        if idx < 0:
            idx = self._find_first(node * 2 + 1, m + 1, r, ql, qr, target)
        return idx

    def find_first(self, ql: int, qr: int, target: int) -> int:
        return self._find_first(1, 0, self.n - 1, ql, qr, target)


class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        n = len(nums)
        t = LazySegmentTree(n + 1)

        last: Dict[int, int] = {}
        ans = 0
        cur_sum = 0

        for i in range(1, n + 1):
            x = nums[i - 1]
            v = 1 if x % 2 == 1 else -1
            j = last.get(x)
            if j is None:
                cur_sum += v
                t.update(i, n, v)
            else:
                t.update(j, i - 1, -v)
            last[x] = i

            l = t.find_first(0, i - 1 - ans, cur_sum)
            if l >= 0:
                ans = i - l

        return ans   
```



## C++ä»£ç 

```C++
class LazySegmentTree {
private:
    struct Node {
        int min_val = 0;
        int max_val = 0;
        int todo = 0;
    };

    void apply(int node, int todo) {
        tree[node].min_val += todo;
        tree[node].max_val += todo;
        tree[node].todo += todo;
    }

    int n;
    vector<Node> tree;

    void spread(int node) {
        int todo = tree[node].todo;
        if (todo == 0) return;
        apply(node * 2, todo);
        apply(node * 2 + 1, todo);
        tree[node].todo = 0;
    }

    void maintain(int node) {
        tree[node].min_val = min(tree[node * 2].min_val, tree[node * 2 + 1].min_val);
        tree[node].max_val = max(tree[node * 2].max_val, tree[node * 2 + 1].max_val);
    }

    void update(int node, int l, int r, int ql, int qr, int f) {
        if (ql <= l && r <= qr) {
            apply(node, f);
            return;
        }
        spread(node);
        int m = (l + r) / 2;
        if (ql <= m) {
            update(node * 2, l, m, ql, qr, f);
        }
        if (qr > m) {
            update(node * 2 + 1, m + 1, r, ql, qr, f);
        }
        maintain(node);
    }

    int findFirst(int node, int l, int r, int ql, int qr, int target) {
        if (l > qr || r < ql || target < tree[node].min_val || target > tree[node].max_val) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        spread(node);
        int m = (l + r) / 2;
        int idx = findFirst(node * 2, l, m, ql, qr, target);
        if (idx < 0) {
            idx = findFirst(node * 2 + 1, m + 1, r, ql, qr, target);
        }
        return idx;
    }

public:
    LazySegmentTree(int n) : n(n) {
        int size = 2 << (32 - __builtin_clz(n - 1));
        tree.resize(size);
    }

    void update(int ql, int qr, int f) {
        update(1, 0, n - 1, ql, qr, f);
    }

    int findFirst(int ql, int qr, int target) {
        return findFirst(1, 0, n - 1, ql, qr, target);
    }
};

class Solution {
public:
    int longestBalanced(vector<int>& nums) {
        int n = nums.size();
        LazySegmentTree t(n + 1);

        unordered_map<int, int> last;
        int ans = 0;
        int curSum = 0;

        for (int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            int v = (x % 2 == 1) ? 1 : -1;
            auto it = last.find(x);
            if (it == last.end()) {
                curSum += v;
                t.update(i, n, v);
            } else {
                t.update(it->second, i - 1, -v);
            }
            last[x] = i;

            int l = t.findFirst(0, i - 1 - ans, curSum);
            if (l >= 0) {
                ans = i - l;
            }
        }
        return ans;
    }
};
```

![3721_æœ€é•¿å¹³è¡¡å­æ•°ç»„ II_C++]()
