本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/description/)

>标签：数组  |  哈希表  |  分治  |  计数  |  排序

# 一、题目描述

## **问题概括**

给定一个大小为 `n` 的整数数组 `nums`，数组中总存在一个 **多数元素**，其定义是在数组中的出现次数**严格大于** `⌊ n/2 ⌋`（即超过数组长度的一半）。你需要找出并返回这个元素。

题目保证输入数组非空，且一定满足存在这样的多数元素。

## **示例说明**

- **示例1**：`nums = [3,2,3]`，元素 `3` 出现 2 次，数组长度 `n=3`，满足 `2 > ⌊3/2⌋ = 1`，因此返回 `3`。
- **示例2**：`nums = [2,2,1,1,1,2,2]`，元素 `2` 出现 4 次，数组长度 `n=7`，满足 `4 > ⌊7/2⌋ = 3`，因此返回 `2`。

## **数据范围与进阶要求**

- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`
- **进阶挑战**：尝试设计一个时间复杂度为 **O(n)**、空间复杂度为 **O(1)** 的算法来解决此问题。



# 二、解题思路\解题过程

这道题也是简单题，我的第一想法是采用Python来解题，使用了Python中的内置函数“count”，结果超出时间限制了，代码如下：
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n = len(nums)
        for i in nums:
            if nums.count(i) * 2 > n :
                return i
```
后面我一想，还可以继续改进，因为数组nums中肯定是有很多重复的元素，但只有唯一一个元素是符合重复元素的条件的，若从首元素一直遍历下去的话，有些重复元素就显得很浪费时间了，所以，先将nums数组转化为set集合，集合有一个特性——就是去重，这样去重后的nums_set在进行遍历的话，就比遍历数组nums数组省时多了，最终也AC了，代码如下：
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums_set = set(nums)
        n = len(nums)
        for i in nums_set:
            if nums.count(i) * 2 > n :
                return i
```
后面我又参考了其他的题解，代码和思路如下：

思路：

原链接：[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/solutions/3744717/on-mo-er-tou-piao-fa-yan-jin-zheng-ming-ww1zv/)）：
用「擂台赛」打比方：
1. 擂主登场：nums[0] 成为初始擂主，生命值为 1。
2. 挑战者出现：遍历后续元素，作为挑战者。
3. 比武：如果挑战者与擂主属于同一门派（值相同），那么擂主生命值加 1，否则擂主生命值减 1。
4. 擂主更迭：如果比武后，擂主生命值降为 0（同归于尽），那么下一个挑战者成为新的擂主，生命值为 1。
5. 最后在擂台上的那人，便是武林盟主（严格众数）。

为什么这样做是对的？
设出现次数最多的元素的出现次数为 a，其余元素的出现次数之和为 b = n − a。题目保证 a > b。

代码如下：
```java
class Solution {
    public int majorityElement(int[] nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int majorityElement(int[] nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
}
```



## Python代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums_set = set(nums)
        n = len(nums)
        for i in nums_set:
            if nums.count(i) * 2 > n :
                return i
```

![169_多数元素_力扣_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E6%95%B0%E7%BB%84/Images/169_%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0_Python.png)

## C++代码

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
};
```

![169_多数元素_力扣_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/7_%E6%95%B0%E7%BB%84/Images/169_%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0_C++.png)
