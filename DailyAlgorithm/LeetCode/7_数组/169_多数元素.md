[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/description/)

>标签：数组  |  哈希表  |  分治  |  计数  |  排序

# 一、题目描述

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`
- 输入保证数组中一定有一个多数元素。

 

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。



# 二、解题思路\解题过程

这道题也是简单题，我的第一想法是采用Python来解题，使用了Python中的内置函数“count”，结果超出时间限制了，代码如下：
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n = len(nums)
        for i in nums:
            if nums.count(i) * 2 > n :
                return i
```
后面我一想，还可以继续改进，因为数组nums中肯定是有很多重复的元素，但只有唯一一个元素是符合重复元素的条件的，若从首元素一直遍历下去的话，有些重复元素就显得很浪费时间了，所以，先将nums数组转化为set集合，集合有一个特性——就是去重，这样去重后的nums_set在进行遍历的话，就比遍历数组nums数组省时多了，最终也AC了，代码如下：
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums_set = set(nums)
        n = len(nums)
        for i in nums_set:
            if nums.count(i) * 2 > n :
                return i
```
后面我又参考了其他的题解，代码和思路如下：

思路：

原链接：[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/solutions/3744717/on-mo-er-tou-piao-fa-yan-jin-zheng-ming-ww1zv/)）：
用「擂台赛」打比方：
1. 擂主登场：nums[0] 成为初始擂主，生命值为 1。
2. 挑战者出现：遍历后续元素，作为挑战者。
3. 比武：如果挑战者与擂主属于同一门派（值相同），那么擂主生命值加 1，否则擂主生命值减 1。
4. 擂主更迭：如果比武后，擂主生命值降为 0（同归于尽），那么下一个挑战者成为新的擂主，生命值为 1。
5. 最后在擂台上的那人，便是武林盟主（严格众数）。

为什么这样做是对的？
设出现次数最多的元素的出现次数为 a，其余元素的出现次数之和为 b = n − a。题目保证 a > b。

代码如下：
```java
class Solution {
    public int majorityElement(int[] nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int majorityElement(int[] nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
}
```



## Python代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums_set = set(nums)
        n = len(nums)
        for i in nums_set:
            if nums.count(i) * 2 > n :
                return i
```



## C++代码

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int blood = 0, mode = 0;
        for(int i : nums){
            if(blood == 0){
                mode = i;
                blood = 1;
            } else {
                blood += i == mode ? 1 : -1;
            }
        }
        return mode;
    }
};
```

