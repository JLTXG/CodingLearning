[1470. 重新排列数组 - 力扣（LeetCode）](https://leetcode.cn/problems/shuffle-the-array/description/?envType=study-plan-v2&envId=primers-list)

>标签：数组

# 一、题目描述

给你一个数组 `nums` ，数组中有 `2n` 个元素，按 `[x1,x2,...,xn,y1,y2,...,yn]` 的格式排列。

请你将数组按 `[x1,y1,x2,y2,...,xn,yn]` 格式重新排列，返回重排后的数组。

 

**示例 1：**

```
输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
```

**示例 2：**

```
输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
```

**示例 3：**

```
输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
```

 

**提示：**

- `1 <= n <= 500`
- `nums.length == 2n`
- `1 <= nums[i] <= 10^3`



# 二、解题思路\解题过程

这道题也是一道简单的编程题目，直接采用模拟思路来写就好了，没有什么技术含量，只需要关注数组的索引是否超出范围就好了，代码如下：
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        int flag = 0;
        vector<int> arr(2 * n);
        for (int i = 0, j = n; i < n && j < 2 * n; i++, j++) {
            arr[flag] = nums[i];
            arr[flag + 1] = nums[j];
            flag += 2;
        }
        return arr;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int flag = 0;
        int[] arr = new int[2 * n];
        for (int i = 0, j = n; i < n && j < 2 * n; i++, j++) {
            arr[flag] = nums[i];
            arr[flag + 1] = nums[j];
            flag += 2;
        }
        return arr;
    }
}
```



## Python代码

```Python
class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        flag, arr = 0, [0] * 2 * n
        for i in range(n):
            arr[flag] = nums[i]
            arr[flag + 1] = nums[i + n]
            flag += 2
        return arr
```



## C++代码

```C++
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        int flag = 0;
        vector<int> arr(2 * n);
        for (int i = 0, j = n; i < n && j < 2 * n; i++, j++) {
            arr[flag] = nums[i];
            arr[flag + 1] = nums[j];
            flag += 2;
        }
        return arr;
    }
};
```

![1470_重新排列数组_C++]()