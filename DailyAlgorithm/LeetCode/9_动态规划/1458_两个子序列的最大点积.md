[1458. 两个子序列的最大点积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/description/?envType=daily-question&envId=2026-01-08)

>标签：数组  |  动态规划

# 一、题目描述

给你两个数组 `nums1` 和 `nums2` 。

请你返回 `nums1` 和 `nums2` 中两个长度相同的 **非空** 子序列的最大点积。

数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，`[2,3,5]` 是 `[1,2,3,4,5]` 的一个子序列而 `[1,5,3]` 不是。

 

**示例 1：**

```
输入：nums1 = [2,1,-2,5], nums2 = [3,0,-6]
输出：18
解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。
它们的点积为 (2*3 + (-2)*(-6)) = 18 。
```

**示例 2：**

```
输入：nums1 = [3,-2], nums2 = [2,-6,7]
输出：21
解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。
它们的点积为 (3*7) = 21 。
```

**示例 3：**

```
输入：nums1 = [-1,-1], nums2 = [1,1]
输出：-1
解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。
它们的点积为 -1 。
```

 

**提示：**

- `1 <= nums1.length, nums2.length <= 500`
- `-1000 <= nums1[i], nums2[i] <= 1000`

**点积：**

```bash
定义 a = [a1, a2,…, an] 和 b = [b1, b2,…, bn] 的点积为：



这里的 Σ 指示总和符号。
```



# 二、解题思路\解题过程

本道题内容转载[1458. 两个子序列的最大点积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solutions/3869919/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-0gct/?envType=daily-question&envId=2026-01-08)，[灵茶山艾府](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solutions/3869919/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-0gct/)。

这道题的题目文字描述内容不是很长，题意理解起来也很容易，但是其难度是“困难”，也就是分别剔除题目给的两个数组中的某些数值（也可以不剔除）——使得这两个数组中的数的个数是一样的，还需要保证两个数组中剩下的数进行“点积”得到的值是最大的！（注意：如果对题目给的两个数组进行了剔除数值的操作，得保证剔除数值后的序列不改变数字间的相对顺序）

> 动态规划有`选或不选`和`枚举选哪个`两种基本思考方式。子序列相邻无关一般是`选或不选`，子序列相邻相关（例如`LIS`问题）一般是`枚举选哪个`。本题用到的是`选或不选`

这是一道“动态规划”相关的题目，我参考了灵神的思路（[1458. 两个子序列的最大点积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solutions/3869919/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-0gct/?envType=daily-question&envId=2026-01-08)），具体解题思路如下所示：

## 第一步：寻找子问题

为方便描述，下文把 `nums1` 和 `nums2` 简称为 `a` 和 `b`。

在示例 1 中，我们要解决的问题（原问题）是：

- 从 a = [2,1,−2,5] 和 b = [3,0,−6] 中选两个长度相等的非空子序列 c 和 d，计算 c 和 d 的点积的最大值。

⚠注意：选出的子序列必须是非空的。

考虑从右往左选数字，用「选或不选」分类讨论：

- 选 a[3] 和 b[2]，需要解决的子问题为：从 a=[2,1,−2] 和 b=[3,0] 中选两个长度相等的子序列，计算两个子序列点积的最大值。由于我们选了元素，所以子序列可以为空。但这样思考的话，子问题就和原问题不相似了。为了保证子问题和原问题相似，我们可以再细分为两种情况：
	- 选 a[3] 和 b[2]，且前面不再选数字。这意味着点积就是 a[3]⋅b[2]。
	- 选 a[3] 和 b[2]，且前面还要选数字。需要解决的子问题为：从 a=[2,1,−2] 和 b=[3,0] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值。

- 不选 a[3]，需要解决的子问题为：从 a=[2,1,−2] 和 b=[3,0,−6] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值。
- 不选 b[2]，需要解决的子问题为：从 a=[2,1,−2,5] 和 b=[3,0] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值。

## 第二步：状态定义与状态转移方程

根据上面的讨论，定义状态为 dfs(i,j)，表示从 a 的前缀 [0,i] 和 b 的前缀 [0,j] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值。

接下来，思考如何从一个状态转移到另一个状态。

用「选或不选」分类讨论：

- 选 a[i] 和 b[j]，且前面不再选数字。这意味着点积就是 a[i]⋅b[j]。
- 选 a[i] 和 b[j]，且前面还要选数字。需要解决的子问题为：从 a 的前缀 [0,i−1] 和 b 的前缀 [0,j−1] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值，即 dfs(i−1,j−1)。再加上 a[i]⋅b[j]，就得到了 dfs(i,j)。
- 前两种情况可以合并为：max(dfs(i−1,j−1),0)+a[i]⋅b[j]。
- 不选 a[i]，需要解决的子问题为：从 a 的前缀 [0,i−1] 和 b 的前缀 [0,j] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值，即 dfs(i−1,j)。
- 不选 b[j]，需要解决的子问题为：从 a 的前缀 [0,i] 和 b 的前缀 [0,j−1] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值，即 dfs(i,j−1)。

这四种情况取最大值，就得到了 dfs(i,j)，即

     `dfs(i,j)=max{max(dfs(i−1,j−1),0)+a[i]⋅b[j],dfs(i−1,j),dfs(i,j−1)}`

`递归边界`：`dfs(−1,j)=dfs(i,−1)=−∞`。此时其中一个数组没有元素，无法选出非空子序列，不合法。用 −∞ 表示不合法的状态，从而保证 max 不会取到不合法的状态。

`递归入口`：`dfs(n−1,m−1)`，这是原问题，也是答案。其中 n 是 a 的长度，m 是 b 的长度。

## 第三步：递归搜索+保存递归返回值 = 记忆化搜索

考虑到整个递归过程中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：

- 如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。
- 如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。

⚠注意：`memo` 数组的**初始值**一定不能等于要记忆化的值！例如初始值设置为 0，并且要记忆化的 dfs(i,j) 也等于 0，那就没法判断 0 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。一般把初始值设置为 −1，但本题子序列点积可能是负数，可以初始化为 ∞。

> Python 用户可以无视上面这段，直接用 @cache 装饰器。

## 第四步：1:1 翻译成递推

我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。

具体来说，`f[i+1][j+1]` 的定义和 dfs(i,j) 的定义是一样的，都表示从 a 的前缀 [0,i] 和 b 的前缀 [0,j] 中选两个长度相等的非空子序列，计算两个子序列点积的最大值。这里 +1 是为了把 dfs(−1,j) 和 dfs(i,−1) 也翻译过来，这样我们可以把 `f[0][j]` 和 `f[i][0]` 作为初始值。

相应的递推式（状态转移方程）也和 dfs 一样：

`f[i+1][j+1]=max{max(f[i][j],0)+a[i]⋅b[j],f[i][j+1],f[i+1][j]}`

初始值：f 第一行和第一列初始化成 −∞，翻译自递归边界 `dfs(−1,j)=dfs(i,−1)=−∞`。

答案为 `f[n][m]`，翻译自递归入口 dfs(n−1,m−1)。

最终代码如下：
```java
class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;

        int[][] flag = new int[n + 1][m + 1];
        for(int[] tmp : flag){
            Arrays.fill(tmp, Integer.MIN_VALUE);
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                flag[i + 1][j + 1] = Math.max(
                    Math.max(flag[i][j], 0) + nums1[i] * nums2[j],
                    Math.max(flag[i][j + 1], flag[i + 1][j])
                );
            }
        }
        return flag[n][m];
    }
}
```

# 三、代码演示

## Java代码

```java
class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;

        int[][] flag = new int[n + 1][m + 1];
        for(int[] tmp : flag){
            Arrays.fill(tmp, Integer.MIN_VALUE);
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                flag[i + 1][j + 1] = Math.max(
                    Math.max(flag[i][j], 0) + nums1[i] * nums2[j],
                    Math.max(flag[i][j + 1], flag[i + 1][j])
                );
            }
        }
        return flag[n][m];
    }
}
```



## Python代码

```python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)

        flag = [[float('-inf')] * (m + 1) for _ in range(n + 1)]

        for i in range(n):
            for j in range(m):
                product = nums1[i] * nums2[j]
                #  选择配对 nums1[i] 和 nums2[j]
                #  可以接在之前的子序列后，或从当前开始（如果之前是负的就舍弃，用 0）
                take = max(flag[i][j], 0) + product
                #  不匹配：从上方（跳过 nums1[i]）或左方（跳过 nums2[j]）转移
                not_take = max(flag[i][j + 1], flag[i + 1][j])
                flag[i + 1][j + 1] = max(take, not_take)

        return flag[n][m]
```



## C++代码

```C++
class Solution {
public:
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        int n = size(nums1), m = size(nums2);

        vector<vector<int>> flag(n + 1, vector<int>(m + 1, INT_MIN));

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                int product = nums1[i] * nums2[j];
                //  选择：是否将 nums1[i] 和 nums2[j] 配对
                int take = max(flag[i][j], 0) + product;
                //  不选当前配对：从上方或左方转移
                int notTake = max(flag[i][j + 1], flag[i + 1][j]);
                flag[i + 1][j + 1] = max(take, notTake);
            }
        }
        return flag[n][m];
    }
};
```

