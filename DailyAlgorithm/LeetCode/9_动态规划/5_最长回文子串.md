[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=problem-list-v2&envId=dynamic-programming)

>标签：双指针  |  字符串  |  动态规划

# 一、题目描述

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成



# 二、解题思路\解题过程

这道题是上一道题目“[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/description/?envType=problem-list-v2&envId=dynamic-programming)”的延伸，思路还是一样，采用“动态规划”的思路，具体的思路可以直接参考上一道题目的笔记思路，只需要修改统计部分的代码即可

“[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/description/?envType=problem-list-v2&envId=dynamic-programming)”题目的思路如下，这道题你可以借鉴：

![647_回文子串_思路——参考](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/647_%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2_%E6%80%9D%E8%B7%AF.jpg)



# 三、代码演示

## Java代码

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length(), flag = 0, s_i = 0, s_j = 0;
        boolean[][] dp = new boolean[n][n];
        for(int i = n - 1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j - i <= 1){
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]){
                        dp[i][j] = true;
                    }
                }
                if(dp[i][j] == true && (j - i + 1) > flag){
                    flag = flag > (j - i + 1) ? flag : (j - i + 1);
                    s_i = i;
                    s_j = j;
                }
            }
        }
        String newStr = "";
        for(int i = s_i; i <= s_j; i++){
            newStr += s.charAt(i);
        }
        return newStr;
    }
}
```



## Python代码

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n, flag, s_i, s_j = len(s), 0, 0, 0
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(i, n, 1):
                if s[i] == s[j] :
                    if j - i <= 1 :
                        dp[i][j] = 1
                    elif dp[i + 1][j - 1] == 1 :
                        dp[i][j] = 1
                if dp[i][j] == 1 and (j - i + 1) > flag :
                    flag = j - i + 1
                    s_i = i
                    s_j = j
        new_str = ""
        for i in range(s_i, s_j + 1):
            new_str += s[i]
        return new_str
```



## C++代码

```C++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size(), flag = 0, s_i = 0, s_j = 0;
        vector<vector<bool>> dp(s.size() + 1, vector<bool>(s.size() + 1, false));
        for(int i = n - 1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]){
                    if(j - i <= 1){
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]){
                        dp[i][j] = true;
                    }
                }
                if(dp[i][j] == true && (j - i + 1) > flag){
                    flag = flag > (j - i + 1) ? flag : (j - i + 1);
                    s_i = i;
                    s_j = j;
                }
            }
        }
        string newStr = "";
        for(int i = s_i; i <= s_j; i++){
            newStr += s[i];
        }
        return newStr;
    }
};
```

![5_最长回文子串_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/9_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Images/5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2_C++.png)