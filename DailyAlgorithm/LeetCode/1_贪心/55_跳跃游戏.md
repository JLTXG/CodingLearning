[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/?envType=problem-list-v2&envId=greedy)

>标签：贪心  |  数组  |  动态规划

# 一、题目描述

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`



# 二、解题思路\解题过程

这道题目是上一道题目的简单版本，只需要判断是否能不能跳转到终点即可，不需要记录跳转了多少次！
我们需要定义两个变量，一个`cover`表明从一开始往后遍历所能覆盖到的最大的下标值，一个`n`用以记录题目给的数组的长度。最开始，如果题目给的数组的长度为`1`，那么就可以直接返回`true`了，如果不为`1`，我们就需要去遍历整个数组，但是，需要注意的是，数组截止遍历的条件不在是`i < n`，而是`i <= cover`，这样我们才循环里设置判断`if(cover >= n - 1)`，如果`cover >= n - 1`，即可返回`true`，否则就继续循环下去，直到跳出循环，跳出循环之后即可返回`false`，因为`cover`是我们可以覆盖到的最大下标值，既然在循环里面没有达到`cover >= n - 1`的情况，那么就说明无法到达终点！
但是，这里需要有一个注意的地方，`if(cover >= n - 1)`的判断得在“更新`cover`值”的前面，因为`cover`的值可能大于`n - 1`，所以，当`cover`在大于`n - 1`的情况下，必须先进入`if`判断，否则后续更新`cover`的值的时候，会显示“超出数组序列下标”！
代码如下：

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int cover = 0, n = nums.length;
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public boolean canJump(int[] nums) {
        int cover = 0, n = nums.length;
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
}
```



## Python代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        i, cover, n = 0, 0, len(nums)
        if n == 1 :
            return True
        while i <= cover :
            if cover >= n - 1:
                return True
            cover = cover if cover > (i + nums[i]) else (i + nums[i])
            i += 1
        return False
```

注意，如果要用Python来写这道题目的话，千万要注意`range`的用法！
> **`range()` 在循环开始时就确定了迭代次数，不会动态变化！**
> 需要动态边界时，请用 `while`。

## C++代码

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0, n = size(nums);
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
};
```

