本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流。

原题链接：[3075. 幸福值最大化的选择方案 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-happiness-of-selected-children/?envType=daily-question&envId=2025-12-25)

>标签：贪心  |  数组  |  排序

# 一、题目描述

## **问题概括**

你面前有 `n` 个孩子，他们的幸福值记录在一个数组 `happiness` 中。你需要进行 `k` 轮选择，每轮选出一名尚未被选中的孩子。

**选择机制有一个关键规则**：每当你在某一轮选中一个孩子后，所有**还未被选中**的孩子的幸福值都会减少 `1`。不过，幸福值最低只会减少到 `0`，不会变为负数。

你的目标是制定一个选择策略，使得最终选中的这 `k` 个孩子的幸福值**总和最大**。

## **示例说明**

- **示例1**：孩子的幸福值为 `[1, 2, 3]`，需要选 `2` 人。最优策略是：先选幸福值 `3` 的孩子（总和+3），其余孩子幸福值减1后变为 `[0, 1]`；再选幸福值 `1` 的孩子（总和+1）。最终最大总和为 `4`。
- **示例2**：幸福值均为 `[1, 1, 1, 1]`，需要选 `2` 人。无论先选哪个，选中后其余人的幸福值都会降至 `0`。因此，最大总和只能是 `1 + 0 = 1`。
- **示例3**：幸福值为 `[2, 3, 4, 5]`，只需选 `1` 人。显然直接选最高的 `5`，总和就是 `5`。

## **数据范围**

- 孩子数量 `n` 最多为 `200,000`。
- 每个孩子的初始幸福值在 `1` 到 `100,000,000` 之间。
- 需要选择的人数 `k` 是一个不超过 `n` 的正整数。



# 二、解题思路\解题过程

第一个出错“解答错误”，是因为，我用的是Java来写的代码，没考虑到数据类型的长度问题，用了int来记录数据，结果超了，导致输出的是负数，后面将记录值的数据类型改成了long，就又通过了刚刚那些报错的案例；

第一次修改代码如下：

```java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        int n = happiness.length - 1, happy = 0;
        Arrays.sort(happiness);
        while(k > 0){
            happy += happiness[n];
            n--;
            for(int i = 0; i <= n; i++){
                if(happiness[i] > 0){
                    happiness[i]--;
                }
            }
            k--;
        }
        return happy;
    }
}
```

但是，紧接着，第二个错误“超出时间限制”，然后我仔细看了代码，代码中有两个循环，我觉得可以对内层循环进行改进：如下，我已经将数组排序了，而且我是从后往前进行检索的，所以，当数组中的某个值为0的话，那么前面的值也为0，那么这样的话，我就可以直接跳过剩下的循环了，然后我提交了代码，发现刚刚的“超出时间限制”已经解决了，又通过了4个测试案例，但是，还有2个测试案例没有通过；

第二次修改代码如下：

```java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        long happy = 0;
        int n = happiness.length - 1;
        Arrays.sort(happiness);
        while(k > 0){
            happy += happiness[n];
            n--;
            for(int i = n; i >= 0; i--){
                if(happiness[i] > 0){
                    happiness[i]--;
                }
                if(happiness[i] == 0){
                    break;
                }
            }
            k--;
        }
        return happy;
    }
}
```

OK，第三次修改，终于成功了，我知道第二次为什么还会有测试案例不通过了，因为第二次的修改其实**指标不治本**，如果数组中的小数值和大数值之间的大小差距比较大的话，第二次修改是有意义的，因为这样第二次修改的代码就会减少一部分的循环，减少了对应的时间开销，但是，当数组中的数值差距不是很大的时候，这个时候，第二次修改的代码就有点鸡肋了，因为还是会几乎全部循环一遍，这样的话，时间开销是几乎没有什么大的变化的；

所以，接下来，第三次修改，我就开始找规律了，我发现，每次选数组中最大的值（剔除上一轮选中的数值），选中的值都会减去“轮数 - 1”的值：比如，第一轮选中的值，就会减去“1 - 1 = 0”，也就是减去0，然后在被幸福值happy加上；然后，第二轮选中的值，就会减去“2 - 1 = 1”，也就是减去1，然后在被幸福值haappy加上……接下来就是以此类推下去，需要注意的是，如果选中的值减去“轮数 - 1”的值之后等于0了，那么这个时候，就说明，后面的值即使选上了，最后加上的也是0，那么这个时候就可以break了，这样又可以减少循环的时间开销了；整体代码如下：

```java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        long happy = 0;
        int n = happiness.length - 1, flag = 0;
        Arrays.sort(happiness);
        while(flag < k){
            if(happiness[n] - flag > 0){
                happy += happiness[n] - flag;
            } else {
                break;
            }
            n--;
            flag++;
        }
        return happy;
    }
}
```

![3075_幸福值最大化的选择方案_力扣_解题过程.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3075_%E5%B9%B8%E7%A6%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88_%E5%8A%9B%E6%89%A3_%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B.jpg)

# 三、代码演示

## Java代码

```java
class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        long happy = 0;
        int n = happiness.length - 1, flag = 0;
        Arrays.sort(happiness);
        while(flag < k){
            if(happiness[n] - flag > 0){
                happy += happiness[n] - flag;
            } else {
                break;
            }
            n--;
            flag++;
        }
        return happy;
    }
}
```

![3075_幸福值最大化的选择方案_力扣_Java.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3075_%E5%B9%B8%E7%A6%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88_%E5%8A%9B%E6%89%A3_Java.png)

## Python代码

```python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happinessed = sorted(happiness)
        flag, happy, n = 0, 0, len(happiness) - 1
        while flag < k :
            if happinessed[n] - flag > 0 :
                happy += happinessed[n] - flag
            else:
                break
            n -= 1
            flag += 1
        return happy
        
```

![3075_幸福值最大化的选择方案_力扣_Python.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3075_%E5%B9%B8%E7%A6%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88_%E5%8A%9B%E6%89%A3_Python.png)

## C++代码

```c++
class Solution {
public:
    long long maximumHappinessSum(vector<int>& happiness, int k) {
        sort(happiness.begin(), happiness.end());
        long long happy = 0;
        int n = size(happiness) - 1, flag = 0;
        while(flag < k){
            if(happiness[n] - flag > 0){
                happy += happiness[n] - flag;
            } else {
                break;
            }
            n--;
            flag++;
        }
        return happy;
    }
};
```

![3075_幸福值最大化的选择方案_力扣_C++.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3075_%E5%B9%B8%E7%A6%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88_%E5%8A%9B%E6%89%A3_C++.png)

