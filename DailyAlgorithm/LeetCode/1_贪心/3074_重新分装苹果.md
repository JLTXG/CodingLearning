[3074. 重新分装苹果 - 力扣（LeetCode）](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/?envType=daily-question&envId=2025-12-24)

>标签：贪心  |  数组  |  排序

# 一、题目描述
给你一个长度为 `n` 的数组 `apple` 和另一个长度为 `m` 的数组 `capacity` 。

一共有 `n` 个包裹，其中第 `i` 个包裹中装着 `apple[i]` 个苹果。同时，还有 `m` 个箱子，第 `i` 个箱子的容量为 `capacity[i]` 个苹果。

请你选择一些箱子来将这 `n` 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 **最小** 数量。

**注意**，同一个包裹中的苹果可以分装到不同的箱子中。

 

**示例 1：**

```
输入：apple = [1,3,2], capacity = [4,3,1,5,2]
输出：2
解释：使用容量为 4 和 5 的箱子。
总容量大于或等于苹果的总数，所以可以完成重新分装。
```

**示例 2：**

```
输入：apple = [5,5,5], capacity = [2,4,2,7]
输出：4
解释：需要使用所有箱子。
```

 

**提示：**

- `1 <= n == apple.length <= 50`
- `1 <= m == capacity.length <= 50`
- `1 <= apple[i], capacity[i] <= 50`
- 输入数据保证可以将包裹中的苹果重新分装到箱子中。

# 二、解题思路

这道题初步理解下来，还是很好看懂的，尤其是最后一句话“同一个包裹中的苹果可以分装到不同的箱子中”，也就是说，我们只需要关注包裹中的苹果总数，然后，题目要求需要选择的箱子的数量**最小**；在苹果总数确定的前提下，要求所选的箱子数量最小，我们就可以采用**贪心**思想，先对苹果总数进行求和，然后给箱子（数组capacity）进行排序（升序、降序都行），然后只要从最大的箱子开始，依次递减累加箱子的容量，顺便记录箱子个数，每次累加之后和苹果总数相比，如果苹果总数小于等于累加后的箱子容量，那么这个时候就可以返回记录的箱子个数了！

# 三、代码演示

## Java代码

```java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int n = 0, i = 0, summ = 0;
        for(int j = 0; j < apple.length; j++){
            n += apple[j];
        }
        Arrays.sort(capacity);
        for(int j = capacity.length - 1; j >= 0; j--){
            summ += capacity[j];
            i++;
            if(n <= summ){
                break;
            }
        }
        return i;
    }
}
```

![3074_重新分装苹果_力扣_Java.png](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_Java.png?raw=true)

## Python代码

```python
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        i, summ, n =0, 0, sum(apple)
        capacityed = sorted(capacity, reverse=True)
        for cap in capacityed:
            summ += cap
            i += 1
            if n <= summ:
                break
        return i
        
```

![3074_重新分装苹果_力扣_python.png](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_python.png?raw=true)

## C++代码

```c++
class Solution {
public:
    int minimumBoxes(vector<int>& apple, vector<int>& capacity) {
        int i = 0, m = size(capacity), summ = 0;
        int n = accumulate(apple.begin(), apple.end(), 0);
        sort(capacity.begin(), capacity.end(), greater<int>());
        for(int j = 0; j < m; j++){
            summ += capacity[j];
            i++;
            if(n <= summ){
                break;
            }
        }
        return i;
    }
};
```

![3074_重新分装苹果_力扣_C++.png](https://github.com/JLTXG/CodingLearning/blob/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_C++.png?raw=true)
