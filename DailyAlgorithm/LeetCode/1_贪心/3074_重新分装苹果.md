原题网址：[3074. 重新分装苹果 - 力扣（LeetCode）](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/?envType=daily-question&envId=2025-12-24)

>标签：贪心  |  数组  |  排序

# 一、题目描述
## 问题重述

你有若干袋苹果，每袋中有一定数量的苹果。同时，你面前有一系列空箱子，每个箱子都有其最大装载能力。

现在，你需要将所有袋子里的苹果全部取出，并重新装入这些箱子中。装箱时需满足以下规则：

- 苹果可以任意拆分（即一袋苹果可以分到多个箱子中）；
- 每个箱子所装苹果总数不能超过它的容量；
- 目标是**使用尽可能少的箱子**完成全部苹果的装箱。

给定两个数组：

- `apple`：表示每袋苹果的数量；
- `capacity`：表示每个箱子的最大容量。

请计算**最少需要使用多少个箱子**才能装下所有苹果。

> **保证**：题目给出的数据一定存在可行的装箱方案。

------

## **📌 示例说明**

**示例 1**

- 袋中苹果：`[1, 3, 2]` → 总共 6 个苹果
- 箱子容量：`[4, 3, 1, 5, 2]`
- 最优选择：容量为 5 和 4 的两个箱子（总容量 9 ≥ 6）
- 答案：`2`

**示例 2**

- 袋中苹果：`[5, 5, 5]` → 共 15 个
- 箱子容量：`[2, 4, 2, 7]` → 所有箱子加起来刚好 15
- 必须全部使用
- 答案：`4`

------

### **💡 解题关键点（提示）**

- 因为苹果可以任意拆分，问题本质是：**从箱子中选出最少数量，使其总容量 ≥ 苹果总数**。
- 贪心策略：优先选容量最大的箱子，直到满足需求。



# 二、解题思路

这道题初步理解下来，还是很好看懂的，尤其是最后一句话“同一个包裹中的苹果可以分装到不同的箱子中”，也就是说，我们只需要关注包裹中的苹果总数，然后，题目要求需要选择的箱子的数量**最小**；在苹果总数确定的前提下，要求所选的箱子数量最小，我们就可以采用**贪心**思想，先对苹果总数进行求和，然后给箱子（数组capacity）进行排序（升序、降序都行），然后只要从最大的箱子开始，依次递减累加箱子的容量，顺便记录箱子个数，每次累加之后和苹果总数相比，如果苹果总数小于等于累加后的箱子容量，那么这个时候就可以返回记录的箱子个数了！

# 三、代码演示

## Java代码

```java
class Solution {
    public int minimumBoxes(int[] apple, int[] capacity) {
        int n = 0, i = 0, summ = 0;
        for(int j = 0; j < apple.length; j++){
            n += apple[j];
        }
        Arrays.sort(capacity);
        for(int j = capacity.length - 1; j >= 0; j--){
            summ += capacity[j];
            i++;
            if(n <= summ){
                break;
            }
        }
        return i;
    }
}
```

![3074_重新分装苹果_力扣_Java.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_Java.png)

## Python代码

```python
class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        i, summ, n =0, 0, sum(apple)
        capacityed = sorted(capacity, reverse=True)
        for cap in capacityed:
            summ += cap
            i += 1
            if n <= summ:
                break
        return i
        
```

![3074_重新分装苹果_力扣_python.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_python.png)

## C++代码

```c++
class Solution {
public:
    int minimumBoxes(vector<int>& apple, vector<int>& capacity) {
        int i = 0, m = size(capacity), summ = 0;
        int n = accumulate(apple.begin(), apple.end(), 0);
        sort(capacity.begin(), capacity.end(), greater<int>());
        for(int j = 0; j < m; j++){
            summ += capacity[j];
            i++;
            if(n <= summ){
                break;
            }
        }
        return i;
    }
};
```

![3074_重新分装苹果_力扣_C++.png](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E8%B4%AA%E5%BF%83/Images/3074_%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C_%E5%8A%9B%E6%89%A3_C++.png)

