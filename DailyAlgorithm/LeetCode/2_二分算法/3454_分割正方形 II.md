本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3454. 分割正方形 II - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-ii/description/?envType=daily-question&envId=2026-01-14)

>标签：线段树  |  数组  |  二分查找  |  扫描线

# 一、题目描述

## 问题概括

给定一个二维整数数组 `squares`，其中每个元素 `squares[i] = [xi, yi, li]` 表示一个与 x 轴平行的正方形，其左下角坐标为 `(xi, yi)`，边长为 `li`。正方形之间可能存在重叠区域，但在计算面积时，重叠部分只被统计一次。

需要找到一条水平线（即 y 为常数的直线），使得该线上方所有正方形的合并面积等于该线下方所有正方形的合并面积。目标是返回满足条件的最小 y 坐标值。允许答案与实际答案的误差在 `10^-5` 以内。



## **示例说明**

- 示例1：输入 `squares = [[0,0,1],[2,2,1]]`，输出 `1.00000`。水平线 `y = 1` 将面积平分，上方和下方各有一平方单位。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/3454_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20II_%E7%A4%BA%E4%BE%8B1.png)

- 示例2：输入 `squares = [[0,0,2],[1,1,1]]`，输出 `1.00000`。由于正方形重叠，水平线 `y = 1` 将合并面积平分。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/3454_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20II_%E7%A4%BA%E4%BE%8B2.png)

问题要求设计算法，在给定约束下高效地找到所需的最小 y 坐标。



## **注意**

- 输入中正方形的数量范围是 `1` 到 `5 * 10^4`。
- 坐标 `xi` 和 `yi` 是非负整数，边长 `li` 是正整数。
- 所有正方形的总面积不超过 `10^15`。



# 二、解题思路\解题过程

这道题是昨天那道题([3453. 分割正方形 I - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-i/?envType=daily-question&envId=2026-01-14))的进阶版，今天这道题与昨天那道题的区别在于，今天的这道题目的要求中，“重叠区域”被改为`只统计一次`，所有正方形的面积也从之前的`不超过10^12`变成了`不超过10^15`，然后题目提供的示例也有所变化，难度也从`中等`提升到了`困难`，其他的基本上没什么变化！
## 思路展示

这是典型的 **“矩形面积并” + “前缀面积查询”** 问题，标准解法就是：

### ✅ 扫描线（Sweep Line）

- 将每个正方形拆成两个**水平事件**：
    - 下边界：`(y, x, x+side, +1)` → 开始覆盖
    - 上边界：`(y+side, x, x+side, -1)` → 结束覆盖
- 按 y 坐标排序所有事件，从下往上扫描。

### ✅ 线段树维护 x 方向的覆盖状态

- 由于 x 坐标可能很大，先**离散化**所有 x 坐标（收集所有 left 和 right）；
- 线段树维护的是：**当前扫描线高度下，x 轴上被至少一个矩形覆盖的总长度**；
- 这个长度 × 当前事件到下一个事件的 y 差 = 新增的并集面积。

但本题的线段树不是普通的“区间覆盖长度”，而是更巧妙地设计为：

> **维护“未被覆盖的最小覆盖次数对应的长度”**，从而能快速判断“是否有未被覆盖的部分”。

## 代码展示

```java
class SegmentTree {
    private final int n;  // 离散化后区间的数量（即 xs.length - 1）
    private final int[] minCoverLen;  // 每个节点对应区间中，被覆盖次数等于 minCover 的那些子段的总长度
    private final int[] minCover;  // 每个节点对应区间的最小覆盖次数
    private final int[] todo;  // 懒标记：表示该节点子树中所有 minCover 需要统一增加的值（可正可负）

    public SegmentTree(int[] xs) {
        n = xs.length - 1;  // xs 有 m 个坐标点，则有 m - 1 个连续区间（如 [x0, x1], [x1, x2], ...）
        // 计算线段树数组大小：取大于等于 2*n 的最小 2 的幂（标准线段树开 4 倍空间也可，此处更紧凑）
        int size = 2 << (32 - Integer.numberOfLeadingZeros(n - 1));
        minCoverLen = new int[size];
        minCover = new int[size];
        todo = new int[size];
        build(xs, 1, 0, n - 1);  // 从根节点 1 开始建树，区间 [0, n - 1]
    }

    // 对离散化后的区间 [l, r] 执行覆盖次数变化 v （+1 表示进入矩形，-1 表示离开）
    public void update(int l, int r, int v) {
        update(1, 0, n - 1, l, r, v);
    }

    // 获取当前整个 x 轴上“未被任何矩形覆盖”的总长度
    public int getUncoveredLength() {
        // 如果全局最小覆盖次数为 0，说明有未被覆盖的部分，返回这些部分的总长度；
        // 否则（minCover[1] > 0），说明全部被覆盖，未覆盖长度为 0。
        return minCover[1] == 0 ? minCoverLen[1] : 0;
    }

    // 根据左右子节点信息，向上更新当前节点的信息
    private void maintain(int o) {
        int left = o * 2, right = o * 2 + 1;
        // 当前区间的最小覆盖次数
        int mn = Math.min(minCover[left], minCover[right]);
        minCover[o] = mn;
        // 只累加那些“覆盖次数等于 mn”的子区间的长度
        minCoverLen[o] = (minCover[left] == mn ? minCoverLen[left] : 0) + (minCover[right] == mn ? minCoverLen[right] : 0);
    }

    // 对节点 o 应用增量 v（不递归下传懒标记）
    private void do_(int o, int v) {
        minCover[o] += v;  // 覆盖次数整体偏移
        todo[o] += v;
    }

    // 下传懒标记到左右子节点
    private void spread(int o) {
        if (todo[o] != 0) {
            do_(o * 2, todo[o]);
            do_(o * 2 + 1, todo[o]);
            todo[o] = 0;  // 清空当前节点的懒标记
        }
    }

    // 建树：初始化叶子节点的长度（即相邻 x 坐标之差）
    private void build(int[] xs, int o, int l, int r) {
        if (l == r) {
            // 叶子节点对应区间 [xs[l], xs[l+1])，长度为 xs[l+1] - xs[l]
            minCoverLen[o] = xs[l + 1] - xs[l];
            // minCover[o] 默认为 0（未被覆盖），无需显式赋值（int 数组默认 0）
            return;
        }
        int m = (l + r) / 2;
        build(xs, o * 2, l, m);
        build(xs, o * 2 + 1, m + 1, r);
        maintain(o);           // 自底向上合并信息
    }

    // 区间更新：在 [ql, qr] 范围内对覆盖次数加 v
    private void update(int o, int l, int r, int ql, int qr, int v) {
        if (ql <= l && r <= qr) {
            do_(o, v);         // 完全覆盖，直接打懒标记
            return;
        }
        spread(o);             // 下传懒标记，保证子节点信息最新
        int m = (l + r) / 2;
        if (ql <= m) {
            update(o * 2, l, m, ql, qr, v);
        }
        if (m < qr) {          // 注意：区间是 [l, r] 对应 [xs[l], xs[r+1])，所以右半开
            update(o * 2 + 1, m + 1, r, ql, qr, v);
        }
        maintain(o);           // 更新当前节点信息
    }
}

// 主解法类
class Solution {
    // 事件：表示在 y 高度处，[lx, rx) 区间开始（delta=1）或结束（delta=-1）被覆盖
    private record Event(int y, int lx, int rx, int delta) {}

    // 记录：扫描到某事件后，累计面积 和 当前覆盖长度
    private record Record(long area, int sumLen) {}

    public double separateSquares(int[][] squares) {
        int n = squares.length * 2;               // 每个正方形产生两个事件
        int[] xs = new int[n];                    // 存储所有 x 坐标（用于离散化）
        Event[] events = new Event[n];
        n = 0;

        // 构造事件和 x 坐标列表
        for (int[] sq : squares) {
            int lx = sq[0];
            int y = sq[1];
            int side = sq[2];
            int rx = lx + side;
            xs[n] = lx;
            xs[n + 1] = rx;
            events[n++] = new Event(y, lx, rx, 1);        // 下边界：进入
            events[n++] = new Event(y + side, lx, rx, -1); // 上边界：离开
        }

        // 对 x 坐标排序并去重（Arrays.sort 后隐式去重靠 binarySearch 正确性，但实际未显式去重！）
        // 注意：此处未去重，但后续 binarySearch 仍能工作，因为重复坐标不影响区间划分（长度为0）
        Arrays.sort(xs);

        // 初始化线段树（基于离散化后的 x 坐标）
        SegmentTree t = new SegmentTree(xs);

        // 按 y 坐标从小到大排序事件（扫描线从下往上）
        Arrays.sort(events, (a, b) -> a.y - b.y);

        // records[i] 记录处理完第 i 个事件后、但在计算第 i 个 strip 面积前的状态
        Record records[] = new Record[n - 1];
        long totArea = 0;  // 总并集面积

        // 扫描线主循环：处理每一对相邻事件之间的水平条带
        for (int i = 0; i < n - 1; i++) {
            Event e = events[i];

            // 将 [e.lx, e.rx) 映射到离散化后的索引区间 [l, r]
            int l = Arrays.binarySearch(xs, e.lx);
            // 注意：rx 对应的是 xs[r+1]，所以 r = index(rx) - 1
            int r = Arrays.binarySearch(xs, e.rx) - 1;

            // 更新线段树：将 [l, r] 区间覆盖次数 += e.delta
            t.update(l, r, e.delta);

            // 当前被至少一个矩形覆盖的 x 轴总长度 = 总跨度 - 未被覆盖长度
            int sumLen = xs[n - 1] - xs[0] - t.getUncoveredLength();

            // 记录当前累计面积（尚未加上当前 strip 的面积）
            records[i] = new Record(totArea, sumLen);

            // 计算当前 strip（从 events[i].y 到 events[i+1].y）新增的面积
            long dy = events[i + 1].y - e.y;
            totArea += (long) sumLen * dy;
        }

        // 寻找最后一个累计面积 < totArea / 2 的位置
        int i = 0;
        while (i < n - 1 && records[i].area * 2 < totArea) {
            i++;
        }
        i--;  // 回退到满足 area < total/2 的最后一个索引

        // 在第 i 个 strip 内进行线性插值，求出精确的分割线 y 坐标
        // 公式：h = y_i + (total/2 - area_i) / sumLen_i
        // 等价于：h = events[i].y + (totArea - 2 * records[i].area) / (2.0 * records[i].sumLen)
        return events[i].y + (totArea - records[i].area * 2) / (records[i].sumLen * 2.0);
        
    }
}
```

## 知识补充
### **1、扫描线方法**

“扫描线方法”（Sweep Line Algorithm）是计算几何和算法设计中一种非常经典且强大的技术，主要用于高效处理涉及大量几何对象（如线段、矩形、点等）的交集、覆盖、面积、周长等问题。其核心思想是**将二维（或更高维）问题转化为一维动态维护问题**，通过模拟一条“扫描线”在平面上移动，同时维护当前状态的数据结构，从而逐步解决问题。

---

#### 一、基本思想

想象有一条垂直（或水平）的直线从左到右（或从上到下）“扫描”整个平面。当扫描线移动时，它会遇到各种事件（如线段的起点、终点、交点等）。我们只在这些**关键事件点**更新数据结构并执行计算，而不是对整个空间进行暴力遍历。

> **关键点**：
>
> - 将连续的空间问题离散化为事件序列；
> - 利用数据结构（如平衡树、优先队列、线段树等）动态维护当前扫描线所“看到”的状态。

---

#### 二、典型应用场景

1. **矩形面积并（Union Area of Rectangles）**

- 问题：给定若干轴对齐矩形，求它们覆盖的总面积。
- 扫描线思路：
    - 使用垂直扫描线从左到右移动；
    - 每个矩形拆分为两个事件：左边界（+高度区间）和右边界（-高度区间）；
    - 维护当前 x 位置下 y 方向被覆盖的总长度；
    - 面积 = Σ（当前覆盖长度 × 与下一个事件的 x 距离）。

> 常配合**线段树 + 离散化 + 懒标记**实现。

---

2. **线段交点检测（Line Segment Intersection）**

- 问题：判断一组线段中是否存在交点，或找出所有交点。
- 扫描线思路（Bentley–Ottmann 算法）：
    - 垂直扫描线从左到右；
    - 事件包括：线段端点、交点（动态发现）；
    - 用平衡二叉搜索树维护当前与扫描线相交的线段（按 y 坐标排序）；
    - 当两条线段在树中相邻时，检查它们是否相交，并将新交点加入事件队列。

> 时间复杂度可优于暴力 O(n²)。

---

3. **最大重叠区间数 / 最多同时活动任务数**

- 问题：给定多个时间区间 [start, end)，求最多有多少区间同时重叠。
- 扫描线简化版：
    - 将每个区间拆为两个事件：(start, +1), (end, -1)；
    - 按时间排序后顺序处理，维护当前计数器；
    - 最大值即为答案。

> 这是扫描线在一维上的应用，常用于日程安排、会议室问题等。

---

4. **周长并、轮廓线（Perimeter of Union of Rectangles）**

- 类似面积并，但需分别计算水平边和垂直边的贡献；
- 扫描线过程中记录 y 覆盖区间的“变化量”，用于计算垂直边长度。

---

#### 三、算法组成要素

1. **事件（Events）**
   
    - 定义扫描线在哪些位置需要停下来处理；
    - 通常包括几何对象的边界、端点、交点等。
2. **事件队列（Event Queue）**
   
    - 通常用优先队列（最小堆）或排序数组实现；
    - 按扫描方向（如 x 坐标）排序。
3. **状态结构（Status Structure）**
   
    - 动态维护当前扫描线“穿过”的对象；
    - 常用数据结构：平衡 BST、线段树、有序集合（如 C++ `set`、Python `SortedList`）。
4. **处理逻辑**
   
    - 在每个事件点更新状态；
    - 根据状态计算局部结果（如覆盖长度、交点等）。

---

#### 四、优缺点

**优点：**

- 将高维问题降维处理，降低复杂度；
- 避免暴力枚举，效率高（常为 O(n log n)）；
- 思路清晰，模块化强。

**缺点：**

- 实现较复杂，尤其涉及浮点坐标或动态交点；
- 对数据结构要求高；
- 不适用于任意方向的几何对象（除非旋转坐标系）。

---

#### 五、总结

> **扫描线方法 = 事件驱动 + 动态维护 + 降维处理**

它不仅是计算几何的基石算法之一，也在区间调度、图形渲染、VLSI 设计等领域广泛应用。掌握扫描线的关键在于：

- 正确定义“事件”；
- 选择合适的数据结构维护“当前状态”；
- 精确计算每个事件之间的“贡献”。



# 三、代码演示

## Java代码

```Java
class SegmentTree {
    private final int n;  // 离散化后区间的数量（即 xs.length - 1）
    private final int[] minCoverLen;  // 每个节点对应区间中，被覆盖次数等于 minCover 的那些子段的总长度
    private final int[] minCover;  // 每个节点对应区间的最小覆盖次数
    private final int[] todo;  // 懒标记：表示该节点子树中所有 minCover 需要统一增加的值（可正可负）

    public SegmentTree(int[] xs) {
        n = xs.length - 1;  // xs 有 m 个坐标点，则有 m - 1 个连续区间（如 [x0, x1], [x1, x2], ...）
        // 计算线段树数组大小：取大于等于 2*n 的最小 2 的幂（标准线段树开 4 倍空间也可，此处更紧凑）
        int size = 2 << (32 - Integer.numberOfLeadingZeros(n - 1));
        minCoverLen = new int[size];
        minCover = new int[size];
        todo = new int[size];
        build(xs, 1, 0, n - 1);  // 从根节点 1 开始建树，区间 [0, n - 1]
    }

    // 对离散化后的区间 [l, r] 执行覆盖次数变化 v （+1 表示进入矩形，-1 表示离开）
    public void update(int l, int r, int v) {
        update(1, 0, n - 1, l, r, v);
    }

    // 获取当前整个 x 轴上“未被任何矩形覆盖”的总长度
    public int getUncoveredLength() {
        // 如果全局最小覆盖次数为 0，说明有未被覆盖的部分，返回这些部分的总长度；
        // 否则（minCover[1] > 0），说明全部被覆盖，未覆盖长度为 0。
        return minCover[1] == 0 ? minCoverLen[1] : 0;
    }

    // 根据左右子节点信息，向上更新当前节点的信息
    private void maintain(int o) {
        int left = o * 2, right = o * 2 + 1;
        // 当前区间的最小覆盖次数
        int mn = Math.min(minCover[left], minCover[right]);
        minCover[o] = mn;
        // 只累加那些“覆盖次数等于 mn”的子区间的长度
        minCoverLen[o] = (minCover[left] == mn ? minCoverLen[left] : 0) + (minCover[right] == mn ? minCoverLen[right] : 0);
    }

    // 对节点 o 应用增量 v（不递归下传懒标记）
    private void do_(int o, int v) {
        minCover[o] += v;  // 覆盖次数整体偏移
        todo[o] += v;
    }

    // 下传懒标记到左右子节点
    private void spread(int o) {
        if (todo[o] != 0) {
            do_(o * 2, todo[o]);
            do_(o * 2 + 1, todo[o]);
            todo[o] = 0;  // 清空当前节点的懒标记
        }
    }

    // 建树：初始化叶子节点的长度（即相邻 x 坐标之差）
    private void build(int[] xs, int o, int l, int r) {
        if (l == r) {
            // 叶子节点对应区间 [xs[l], xs[l+1])，长度为 xs[l+1] - xs[l]
            minCoverLen[o] = xs[l + 1] - xs[l];
            // minCover[o] 默认为 0（未被覆盖），无需显式赋值（int 数组默认 0）
            return;
        }
        int m = (l + r) / 2;
        build(xs, o * 2, l, m);
        build(xs, o * 2 + 1, m + 1, r);
        maintain(o);           // 自底向上合并信息
    }

    // 区间更新：在 [ql, qr] 范围内对覆盖次数加 v
    private void update(int o, int l, int r, int ql, int qr, int v) {
        if (ql <= l && r <= qr) {
            do_(o, v);         // 完全覆盖，直接打懒标记
            return;
        }
        spread(o);             // 下传懒标记，保证子节点信息最新
        int m = (l + r) / 2;
        if (ql <= m) {
            update(o * 2, l, m, ql, qr, v);
        }
        if (m < qr) {          // 注意：区间是 [l, r] 对应 [xs[l], xs[r+1])，所以右半开
            update(o * 2 + 1, m + 1, r, ql, qr, v);
        }
        maintain(o);           // 更新当前节点信息
    }
}

// 主解法类
class Solution {
    // 事件：表示在 y 高度处，[lx, rx) 区间开始（delta=1）或结束（delta=-1）被覆盖
    private record Event(int y, int lx, int rx, int delta) {}

    // 记录：扫描到某事件后，累计面积 和 当前覆盖长度
    private record Record(long area, int sumLen) {}

    public double separateSquares(int[][] squares) {
        int n = squares.length * 2;               // 每个正方形产生两个事件
        int[] xs = new int[n];                    // 存储所有 x 坐标（用于离散化）
        Event[] events = new Event[n];
        n = 0;

        // 构造事件和 x 坐标列表
        for (int[] sq : squares) {
            int lx = sq[0];
            int y = sq[1];
            int side = sq[2];
            int rx = lx + side;
            xs[n] = lx;
            xs[n + 1] = rx;
            events[n++] = new Event(y, lx, rx, 1);        // 下边界：进入
            events[n++] = new Event(y + side, lx, rx, -1); // 上边界：离开
        }

        // 对 x 坐标排序并去重（Arrays.sort 后隐式去重靠 binarySearch 正确性，但实际未显式去重！）
        // 注意：此处未去重，但后续 binarySearch 仍能工作，因为重复坐标不影响区间划分（长度为0）
        Arrays.sort(xs);

        // 初始化线段树（基于离散化后的 x 坐标）
        SegmentTree t = new SegmentTree(xs);

        // 按 y 坐标从小到大排序事件（扫描线从下往上）
        Arrays.sort(events, (a, b) -> a.y - b.y);

        // records[i] 记录处理完第 i 个事件后、但在计算第 i 个 strip 面积前的状态
        Record records[] = new Record[n - 1];
        long totArea = 0;  // 总并集面积

        // 扫描线主循环：处理每一对相邻事件之间的水平条带
        for (int i = 0; i < n - 1; i++) {
            Event e = events[i];

            // 将 [e.lx, e.rx) 映射到离散化后的索引区间 [l, r]
            int l = Arrays.binarySearch(xs, e.lx);
            // 注意：rx 对应的是 xs[r+1]，所以 r = index(rx) - 1
            int r = Arrays.binarySearch(xs, e.rx) - 1;

            // 更新线段树：将 [l, r] 区间覆盖次数 += e.delta
            t.update(l, r, e.delta);

            // 当前被至少一个矩形覆盖的 x 轴总长度 = 总跨度 - 未被覆盖长度
            int sumLen = xs[n - 1] - xs[0] - t.getUncoveredLength();

            // 记录当前累计面积（尚未加上当前 strip 的面积）
            records[i] = new Record(totArea, sumLen);

            // 计算当前 strip（从 events[i].y 到 events[i+1].y）新增的面积
            long dy = events[i + 1].y - e.y;
            totArea += (long) sumLen * dy;
        }

        // 寻找最后一个累计面积 < totArea / 2 的位置
        int i = 0;
        while (i < n - 1 && records[i].area * 2 < totArea) {
            i++;
        }
        i--;  // 回退到满足 area < total/2 的最后一个索引

        // 在第 i 个 strip 内进行线性插值，求出精确的分割线 y 坐标
        // 公式：h = y_i + (total/2 - area_i) / sumLen_i
        // 等价于：h = events[i].y + (totArea - 2 * records[i].area) / (2.0 * records[i].sumLen)
        return events[i].y + (totArea - records[i].area * 2) / (records[i].sumLen * 2.0);
        
    }
}
```



## Python代码

```Python
class SegmentTree:
    def __init__(self, xs: List[int]):
        self.n = len(xs) - 1
        if self.n <= 0:
            # 处理边界情况（如无有效区间）
            self.min_cover_len = []
            self.min_cover = []
            self.todo = []
            return
        
        # 计算线段树大小：2 * 2^ceil(log2(n))
        size = 2 << (self.n - 1).bit_length()
        self.min_cover_len = [0] * size
        self.min_cover = [0] * size
        self.todo = [0] * size
        self.xs = xs
        self._build(1, 0, self.n - 1)
    
    def _build(self, o: int, l: int, r: int):
        if l == r:
            self.min_cover_len[o] = self.xs[l + 1] - self.xs[l]
            return
        m = (l + r) // 2
        self._build(o * 2, l, m)
        self._build(o * 2 + 1, m + 1, r)
        self._maintain(o)
    
    def _maintain(self, o: int):
        left, right = o * 2, o * 2 + 1
        mn = min(self.min_cover[left], self.min_cover[right])
        self.min_cover[o] = mn
        self.min_cover_len[o] = (
            (self.min_cover_len[left] if self.min_cover[left] == mn else 0) +
            (self.min_cover_len[right] if self.min_cover[right] == mn else 0)
        )
    
    def _do(self, o: int, v: int):
        self.min_cover[o] += v
        self.todo[o] += v
    
    def _spread(self, o: int):
        if self.todo[o] != 0:
            self._do(o * 2, self.todo[o])
            self._do(o * 2 + 1, self.todo[o])
            self.todo[o] = 0
    
    def update(self, l: int, r: int, v: int):
        if self.n <= 0:
            return
        self._update(1, 0, self.n - 1, l, r, v)
    
    def _update(self, o: int, l: int, r: int, ql: int, qr: int, v: int):
        if ql <= l and r <= qr:
            self._do(o, v)
            return
        self._spread(o)
        m = (l + r) // 2
        if ql <= m:
            self._update(o * 2, l, m, ql, qr, v)
        if m < qr:
            self._update(o * 2 + 1, m + 1, r, ql, qr, v)
        self._maintain(o)
    
    def get_uncovered_length(self) -> int:
        if self.n <= 0:
            return 0
        return self.min_cover_len[1] if self.min_cover[1] == 0 else 0


class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        events = []
        xs = []
        
        for x, y, side in squares:
            lx, rx = x, x + side
            xs.extend([lx, rx])
            events.append((y, lx, rx, 1))          # 下边界
            events.append((y + side, lx, rx, -1))  # 上边界
        
        xs = sorted(set(xs))  # 离散化 + 去重
        events.sort(key=lambda e: e[0])  # 按 y 排序
        
        n = len(events)
        seg_tree = SegmentTree(xs)
        records = []  # (cumulative_area, current_covered_length)
        total_area = 0
        
        for i in range(n - 1):
            y, lx, rx, delta = events[i]
            
            # 离散化索引
            l = bisect.bisect_left(xs, lx)
            r = bisect.bisect_left(xs, rx) - 1
            
            if l <= r:
                seg_tree.update(l, r, delta)
            
            total_span = xs[-1] - xs[0]
            uncovered = seg_tree.get_uncovered_length()
            covered_len = total_span - uncovered
            
            records.append((total_area, covered_len))
            dy = events[i + 1][0] - y
            total_area += covered_len * dy
        
        # 找到最后一个 area < total_area / 2 的位置
        i = 0
        while i < len(records) and records[i][0] * 2 < total_area:
            i += 1
        i -= 1
        
        # 线性插值
        prev_area, sum_len = records[i]
        need = (total_area - 2 * prev_area) / (2.0 * sum_len)
        return events[i][0] + need
```



## C++代码

```C++
class SegmentTree {
private:
    int n;
    vector<int> minCoverLen;  // 区间内被覆盖次数等于 minCover 的底边长度之和
    vector<int> minCover;     // 区间内最小覆盖次数
    vector<int> todo;         // 懒标记：子树需统一增加的覆盖次数

    void maintain(int o) {
        int left = o * 2, right = o * 2 + 1;
        int mn = min(minCover[left], minCover[right]);
        minCover[o] = mn;
        minCoverLen[o] = (minCover[left] == mn ? minCoverLen[left] : 0) +
                         (minCover[right] == mn ? minCoverLen[right] : 0);
    }

    void do_(int o, int v) {
        minCover[o] += v;
        todo[o] += v;
    }

    void spread(int o) {
        if (todo[o] != 0) {
            do_(o * 2, todo[o]);
            do_(o * 2 + 1, todo[o]);
            todo[o] = 0;
        }
    }

    void build(const vector<int>& xs, int o, int l, int r) {
        if (l == r) {
            minCoverLen[o] = xs[l + 1] - xs[l];
            return;
        }
        int m = (l + r) / 2;
        build(xs, o * 2, l, m);
        build(xs, o * 2 + 1, m + 1, r);
        maintain(o);
    }

    void update(int o, int l, int r, int ql, int qr, int v) {
        if (ql <= l && r <= qr) {
            do_(o, v);
            return;
        }
        spread(o);
        int m = (l + r) / 2;
        if (ql <= m) update(o * 2, l, m, ql, qr, v);
        if (m < qr) update(o * 2 + 1, m + 1, r, ql, qr, v);
        maintain(o);
    }

public:
    SegmentTree(const vector<int>& xs) {
        n = (int)xs.size() - 1;
        if (n <= 0) return;
        int size = 2;
        if (n > 1) {
            size = 2 << (32 - __builtin_clz(n - 1)); // 相当于 2 * 2^ceil(log2(n))
        }
        minCoverLen.assign(size, 0);
        minCover.assign(size, 0);
        todo.assign(size, 0);
        build(xs, 1, 0, n - 1);
    }

    void update(int l, int r, int v) {
        if (n <= 0) return;
        update(1, 0, n - 1, l, r, v);
    }

    int getUncoveredLength() const {
        return minCover[1] == 0 ? minCoverLen[1] : 0;
    }
};

struct Event {
    int y, lx, rx, delta;
    Event(int y, int lx, int rx, int delta) : y(y), lx(lx), rx(rx), delta(delta) {}
    bool operator<(const Event& other) const {
        return y < other.y;
    }
};

struct Record {
    long long area;
    int sumLen;
    Record(long long a, int s) : area(a), sumLen(s) {}
};

class Solution {
public:
    double separateSquares(vector<vector<int>>& squares) {
        int m = squares.size();
        int n = m * 2;
        vector<int> xs(n);
        vector<Event> events;
        events.reserve(n);

        for (auto& sq : squares) {
            int lx = sq[0], y = sq[1], side = sq[2];
            int rx = lx + side;
            xs.push_back(lx);
            xs.push_back(rx);
            events.emplace_back(y, lx, rx, 1);
            events.emplace_back(y + side, lx, rx, -1);
        }

        sort(xs.begin(), xs.end());
        // 可选：去重（虽然不去重也能工作）
        xs.erase(unique(xs.begin(), xs.end()), xs.end());

        n = (int)events.size(); // 更新 n 为实际事件数
        sort(events.begin(), events.end());

        SegmentTree segTree(xs);
        vector<Record> records;
        records.reserve(n - 1);
        long long totArea = 0;

        for (int i = 0; i < n - 1; ++i) {
            const Event& e = events[i];

            // 离散化：找到 [lx, rx) 对应的索引区间 [l, r]
            int l = (int)(lower_bound(xs.begin(), xs.end(), e.lx) - xs.begin());
            int r = (int)(lower_bound(xs.begin(), xs.end(), e.rx) - xs.begin()) - 1;

            if (l <= r) {
                segTree.update(l, r, e.delta);
            }

            int totalSpan = xs.back() - xs.front();
            int uncovered = segTree.getUncoveredLength();
            int sumLen = totalSpan - uncovered;

            records.emplace_back(totArea, sumLen);
            long long dy = events[i + 1].y - e.y;
            totArea += (long long)sumLen * dy;
        }

        // 找最后一个 area < totArea / 2 的位置
        int i = 0;
        while (i < (int)records.size() && records[i].area * 2 < totArea) {
            ++i;
        }
        --i;

        // 插值计算分割线 y 坐标
        double need = (double)(totArea - 2 * records[i].area) / (2.0 * records[i].sumLen);
        return events[i].y + need;
    }
};
```

![3454_分割正方形 II_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/3454_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20II_C++.png)