本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3453. 分割正方形 I - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13)

>标签：数组  |  二分查找

# 一、题目描述

## **问题概括**

给定一组与 x 轴平行的正方形，每个正方形由左下角坐标 `(xi, yi)` 和边长 `li` 描述（即正方形覆盖从 `xi` 到 `xi+li`、`yi` 到 `yi+li` 的区域）。这些正方形可能存在重叠，且重叠区域的面积在计算时需要被重复计入。

你需要找到一条水平线 `y = c`，使得位于该线上方（严格大于 `c`）的所有正方形部分的面积之和，等于位于该线下方（严格小于 `c`）的所有正方形部分的面积之和。如果存在多条满足条件的水平线，请返回**最小的** `c` 值。

由于计算可能涉及浮点数，只要你的答案与真实答案的绝对误差不超过 `10^-5`，即被视为正确。

##  **示例核心说明**

- **示例1**：两个正方形 `[[0,0,1],[2,2,1]]`，水平线 `y = 1` 将总面积平分为上下各 `1` 个单位，且 `1` 是最小的这样的 `y`，因此输出 `1.00000`。

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/3453_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20I_%E7%A4%BA%E4%BE%8B1.png)

- **示例2**：两个正方形 `[[0,0,2],[1,1,1]]`，计算可得满足面积相等的最小 `y` 约为 `1.16667`。

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/3453_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20I_%E7%A4%BA%E4%BE%8B2.png)

## **数据范围**

- 正方形数量：`1 <= squares.length <= 5 * 10^4`
- 坐标和边长：`0 <= xi, yi <= 10^9`，`1 <= li <= 10^9`
- 所有正方形的总面积不超过 `10^12`



# 二、解题思路\解题过程

这道题用二分的思想求解，具体详细的思路可以参考灵神的题解——[3453. 分割正方形 I - 力扣（LeetCode）](https://leetcode.cn/problems/separate-squares-i/solutions/3076424/zheng-shu-er-fen-pythonjavacgo-by-endles-8yn5/?envType=daily-question&envId=2026-01-13)，我对这部分题解进行了手写+熟悉，具体如下图所示：

![3453_分割正方形 I_二分思路](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/3453_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20I_%E4%BA%8C%E5%88%86%E6%80%9D%E8%B7%AF.jpg)

代码如下：
```java
class Solution {
    public double separateSquares(int[][] squares) {
        long totArea = 0;
        int maxY = 0;
        for (int[] sq : squares) {
            int l = sq[2];
            // 计算所有正方形的总面积
            totArea += (long) l * l;
            // 所有正方形的最高 y 坐标（上边界）
            maxY = Math.max(maxY, sq[1] + l);
        }

        double left = 0;
        double right = maxY;
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半 → 可以尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半 → 需要更大的 y
                left = mid;
            }
        }
        // 区间中点误差更小
        return (left + right) / 2;
    }

    private boolean check(int[][] squares, double y, long totArea) {
        double area = 0;
        for (int[] sq : squares) {
            double yi = sq[1];
            // 只有底部在 y 以下的正方形才贡献面积
            if (yi < y) {
                double l = sq[2];
                // 计算该正方形在 y 以下的部分高度：
                // - 如果 y >= yi + l → 整个正方形在线下 → 高度 = l
                // - 否则 → 高度 = y - yi
                area += l * Math.min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public double separateSquares(int[][] squares) {
        long totArea = 0;
        int maxY = 0;
        for (int[] sq : squares) {
            int l = sq[2];
            // 计算所有正方形的总面积
            totArea += (long) l * l;
            // 所有正方形的最高 y 坐标（上边界）
            maxY = Math.max(maxY, sq[1] + l);
        }

        double left = 0;
        double right = maxY;
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半 → 可以尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半 → 需要更大的 y
                left = mid;
            }
        }
        // 区间中点误差更小
        return (left + right) / 2;
    }

    private boolean check(int[][] squares, double y, long totArea) {
        double area = 0;
        for (int[] sq : squares) {
            double yi = sq[1];
            // 只有底部在 y 以下的正方形才贡献面积
            if (yi < y) {
                double l = sq[2];
                // 计算该正方形在 y 以下的部分高度：
                // - 如果 y >= yi + l → 整个正方形在线下 → 高度 = l
                // - 否则 → 高度 = y - yi
                area += l * Math.min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
}
```



## Python代码

```Python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        tot_area = 0
        max_y = 0
        for x, y, l in squares:
            tot_area += l * l
            max_y = max(max_y, y + l)
        
        left = 0.0
        right = float(max_y)

        # 固定 47 次迭代，保证精度
        for _ in range(47):
            mid = (left + right) / 2.0
            if self._check(squares, mid, tot_area):
                # 线下面积 >= 一半，尝试更小的 y
                right = mid
            else:
                # 线下面积 < 一半，需要更大的 y
                left = mid
        
        return (left + right) / 2.0

    def _check(self, squares, y, tot_area):
        area = 0.0
        for x, yi, l in squares:
            if yi < y :
                # 正方形在 y 以下的部分高度：min(y - yi, l)
                area += l * min(y - yi, l)
        return area >= tot_area / 2.0
```



## C++代码

```C++
class Solution {
public:
    double separateSquares(vector<vector<int>>& squares) {
        long long totArea = 0;
        int maxY = 0;
        for (const auto& sq : squares) {
            int l = sq[2];
            // 防止溢出
            totArea += static_cast<long long>(l) * l;
            maxY = max(maxY, sq[1] + l);
        }

        double left = 0.0;
        double right = static_cast<double>(maxY);

        // 固定 47 次迭代，确保精度
        for (int i = 0; i < 47; i++) {
            double mid = (left + right) / 2.0;
            if (check(squares, mid, totArea)) {
                // 线下面积 >= 一半，尝试更小的 y
                right = mid;
            } else {
                // 线下面积 <  一半，需要更大的 y
                left = mid;
            }
        }
        return (left + right) / 2.0;
    }

private:
    bool check(const vector<vector<int>> & squares, double y, long long totArea) {
        double area = 0.0;
        for (const auto& sq : squares) {
            double yi = sq[1];
            if (yi < y) {
                double l = sq[2];
                // 计算正方形在 y 以下的部分高度
                area += l * min(y - yi, l);
            }
        }
        return area >= totArea / 2.0;
    }
};
```

![3453_分割正方形 I_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/4_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/Images/3453_%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2%20I_C++.png)