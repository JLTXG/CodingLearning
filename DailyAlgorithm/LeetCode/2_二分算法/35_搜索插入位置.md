本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  二分查找

# 一、题目描述

## **问题概括**

给定一个**无重复元素**的**升序**整数数组 `nums` 和一个目标值 `target`。要求使用时间复杂度为 **O(log n)** 的算法，找到 `target` 在数组中的索引。如果 `target` 存在于数组中，则返回其下标；如果不存在，则返回它按升序插入数组时应处的位置索引。

## **示例说明**

- **示例1**：`nums = [1,3,5,6]`, `target = 5`。`5` 存在于数组中，下标为 `2`，返回 `2`。
- **示例2**：`nums = [1,3,5,6]`, `target = 2`。`2` 不存在，按顺序应插入在 `1` 和 `3` 之间，对应下标 `1`，返回 `1`。
- **示例3**：`nums = [1,3,5,6]`, `target = 7`。`7` 不存在，应插入在数组末尾，对应下标 `4`，返回 `4`。

## **数据范围**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `-10^4 <= target <= 10^4`
- `nums` 为无重复元素的升序数组

## **算法要求**

必须实现时间复杂度为 **O(log n)** 的解法，通常通过二分查找完成。



# 二、解题思路\解题过程

这是一道简单的题目，也是热题100中的一道，可以直接模拟解题，也可以采用二分查找来解题，思路都很简单，直接上代码！

# 三、代码演示

## Java代码

```Java
// 模拟解题
class Solution {
    public int searchInsert(int[] nums, int target) {
        int result = 0, n = nums.length, flag = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] == target) {
                return i;
            }
            if (nums[i] > target && flag == 0) {
                result = i;
                flag = 1;
            }
        }
        if (flag == 0) {
            result = n;
        }
        return result;
    }
}

// 二分查找
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int result = n, left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target <= nums[mid]) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return result;
    }
}
```



## Python代码

```Python
# 模拟解题
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        result, n, flag = 0, len(nums), 0
        for i in range(n):
            if nums[i] == target:
                return i
            if nums[i] > target and flag == 0:
                result = i
                flag = 1
        if flag == 0:
            result = n
        return result

# 二分查找
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        n = len(nums)
        result, left, right = n, 0, n - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                result = mid
                right = mid - 1
        return result
```



## C++代码

```C++
// 模拟解题
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int result = 0, n = nums.size(), flag = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] == target) {
                return i;
            }
            if (nums[i] > target && flag == 0) {
                result = i;
                flag = 1;
            }
        }
        if (flag == 0) {
            result = n;
        }
        return result;
    }
};

// 二分查找
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int result = n, left = 0, right = n - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return result;
    }
};
```

![35_搜索插入位置_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/35_%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE_C++.png)