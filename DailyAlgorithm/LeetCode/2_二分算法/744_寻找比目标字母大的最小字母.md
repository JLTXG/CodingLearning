本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/?envType=daily-question&envId=2026-01-31)

>标签：数组  |  二分查找

# 一、题目描述

## **问题概括**

给定一个按字典序非递减排序的小写字母字符数组 `letters`（数组中至少包含两个不同的字符）以及一个小写字母目标字符 `target`。请找出 `letters` 中按字典序大于 `target` 的最小字符。如果数组中不存在这样的字符，则返回 `letters` 的第一个字符（即循环查找）。

## **示例说明**

- **示例1**：`letters = ['c','f','j']`, `target = 'a'`，大于 `'a'` 的最小字符是 `'c'`。
- **示例2**：`letters = ['c','f','j']`, `target = 'c'`，大于 `'c'` 的最小字符是 `'f'`。
- **示例3**：`letters = ['x','x','y','y']`, `target = 'z'`，没有字符大于 `'z'`，返回第一个字符 `'x'`。

## **数据范围**

- `2 <= letters.length <= 10^4`
- `letters[i]` 和 `target` 均为小写字母



# 二、解题思路\解题过程

这是今天的每日一题，是一道简单的编程题目，可以直接模拟解题，也可以采用二分查找来解题，思路都很简单，直接上代码！

# 三、代码演示

## Java代码

```Java
// 模拟解题
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        for (char letter : letters) {
            if (letter > target) {
                return letter;
            }
        }
        return letters[0];
    }
}

// 二分查找
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int n = letters.length;
        int left = -1, right = n;
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (letters[mid] > target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right < n ? letters[right] : letters[0];
    }
}
```



## Python代码

```Python
# 模拟解题
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        for letter in letters:
            if letter > target:
                return letter
        return letters[0]

# 二分查找
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        left, right = -1, n
        while left + 1 < right:
            mid = left + (right - left) // 2
            if letters[mid] > target:
                right = mid
            else:
                left = mid
        return letters[right] if right < n else letters[0]
```



## C++代码

```C++
// 模拟解题
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        for (auto letter : letters) {
            if (letter > target) {
                return letter;
            }
        }
        return letters[0];
    }
};

// 二分查找
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int n = letters.size();
        int left = -1, right = n;
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (letters[mid] > target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right < n ? letters[right] : letters[0];
    }
};
```

![744_寻找比目标字母大的最小字母_C++]()