本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  二分查找  |  分治  |  矩阵

# 一、题目描述

## **问题概括**

给定一个 m 行 n 列的整数矩阵 `matrix`，该矩阵具有以下特性：

- 每行的元素从左到右按升序排列。
- 每列的元素从上到下按升序排列。

请设计一个高效的算法，判断给定的目标值 `target` 是否存在于矩阵中。如果存在，返回 `true`；否则返回 `false`。

## **数据范围**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- `-10^9 <= target <= 10^9`



# 二、解题思路\解题过程

## ✅ 第一段代码：我的写法（先筛行 + 行内二分）

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 获取矩阵的行数 n 和列数 m
        n, m = len(matrix), len(matrix[0])
        flag = []  # 用于记录可能包含 target 的行索引

        # 第一步：遍历每一行，检查 target 是否在该行的值域范围内
        for i in range(n):
            # 如果 target 在 [该行首元素, 该行尾元素] 之间，则该行可能包含 target
            if matrix[i][0] <= target <= matrix[i][m - 1]:
                flag.append(i)

        # 第二步：对每一个“候选行”进行标准二分查找
        for num in flag:
            left, right = 0, m - 1  # 二分查找的左右边界（闭区间）
            while left <= right:
                mid = left + (right - left) // 2  # 防止溢出的中点计算
                if matrix[num][mid] > target:
                    right = mid - 1   # target 在左半部分
                elif matrix[num][mid] < target:
                    left = mid + 1    # target 在右半部分
                else:
                    return True       # 找到 target，直接返回 True
        return False  # 所有候选行都查完仍未找到
```

## ✨ 第二段代码：灵神的写法（Z 字形搜索）

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        i, j = 0, n - 1  # 从右上角开始（第0行，最后一列）

        # 只要还在矩阵范围内就继续搜索
        while i < m and j >= 0:
            if matrix[i][j] == target:
                return True  # 找到目标值

            # 关键决策：
            if matrix[i][j] < target:
                # 当前值太小 → 由于当前是所在行的最大值，
                # 整行都不可能有 target → 向下移动（进入更大的行）
                i += 1
            else:
                # 当前值太大 → 由于当前是所在列的最小值，
                # 整列都不可能有 target → 向左移动（进入更小的列）
                j -= 1

        return False  # 越界仍未找到
```

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length, m = matrix[0].length;
        List<Integer> flag = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] <= target && target <= matrix[i][m - 1]) {
                flag.add(i);
            }
        }
        for (int num : flag) {
            int left = 0, right = m - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (matrix[num][mid] > target) {
                    right = mid - 1;
                } else if (matrix[num][mid] < target) {
                    left = mid + 1;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
}

// 优化版代码
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length, m = matrix[0].length;
        int i = 0, j = m - 1;
        while (i < n && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
```

![240_搜索二维矩阵 II_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/240_%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II_Java.png)

## Python代码

```Python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n, m = len(matrix), len(matrix[0])
        flag = []
        for i in range(n):
            if matrix[i][0] <= target and target <= matrix[i][m - 1]:
                flag.append(i)
        for num in flag:
            left, right = 0, m - 1
            while left <= right:
                mid = left + (right - left) // 2
                if matrix[num][mid] > target:
                    right = mid - 1
                elif matrix[num][mid] < target:
                    left = mid + 1
                else:
                    return True
        return False

# 优化版代码
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n, m = len(matrix), len(matrix[0])
        i, j = 0, m - 1
        while i < n and j >= 0:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                i += 1
            else:
                j -= 1
        return False
```



## C++代码

```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        vector<int> flag;
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] <= target && target <= matrix[i][m - 1]) {
                flag.push_back(i);
            }
        }
        for (int num : flag) {
            int left = 0, right = m - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (matrix[num][mid] > target) {
                    right = mid - 1;
                } else if (matrix[num][mid] < target) {
                    left = mid + 1;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
};

// 优化版代码
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int i = 0, j = m - 1;
        while (i < n && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
};
```

