本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1351. 统计有序矩阵中的负数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/?envType=daily-question&envId=2025-12-27)

>标签：数组  |  二分查找  |  矩阵

# 一、题目描述

## **问题概括**

给定一个 `m` 行 `n` 列的整数矩阵 `grid`。这个矩阵具有一个重要的特性：**无论是逐行查看还是逐列查看，其中的元素值都以非严格递减的顺序排列**（即从左到右、从上到下，每个位置的数值都小于或等于其左侧和上方的数值）。

你的任务是，利用矩阵的这一有序特性，统计并返回矩阵中所有**负数**元素的总个数。

## **示例说明**

- **示例1**：给定的 `4x4` 矩阵中，共有 8 个负数，因此返回 `8`。
- **示例2**：给定的 `2x2` 矩阵中不包含任何负数，因此返回 `0`。

## **数据范围与进阶要求**

- 矩阵的行数 `m` 和列数 `n` 均在 `1` 到 `100` 之间。
- 矩阵中的每个元素值在 `-100` 到 `100` 之间。
- **进阶挑战**：请尝试设计一个时间复杂度为 **O(n + m)** 的算法，而不是简单的 **O(m \* n)** 遍历。



# 二、解题思路\解题过程

今天是一道简单的题目，就是给定一个二维数组，去里面找有多少个负数，然后返回最终的负数个数，挺简单的今天的题目，不知道是不是因为昨天来了一道困难题，今天就出了一道简单题，不过，虽然一遍就过了，但是，第一次提交的Java代码的“执行用时”和“消耗内存”都不是很理想，代码如下：
```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] < 0){
                    flag++;
                }
            }
        }
        return flag;
    }
}
```
后面我想着，既然每一行都是非递增的，那么，我直接在循环每一行的时候，直接倒序遍历，这样遇到大于等于0的，那么就说明前面的就没有必要遍历了，直接跳出里面的这一行循环，直接进行下一行的循环，然后我提交了代码，发现虽然“执行时间”和“消耗内存”都有所优化，但是，优化不大，然后我去看了题解，可以采用“二分查找”的方法，我修改了代码，如下：
```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            //  需要排除正行都是非负数的情况
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
}
```
很明显，在使用了“二分查找”的思想之后，整个代码的“执行用时”已经击败了100%的用户，但是“消耗内存”还是没什么提升！然后，我用了Python来提交代码，同样采用的是“二分查找”的思想，然后一提交，发现“执行用时”击败100%的用户，“消耗内存”击败了96.83%。

同样，我采用了C++写了一遍题目，“执行用时”一样，但是，我发现C++的“消耗内存”竟然比Java的要好很多。



# 三、代码演示

## Java代码

```java
class Solution {
    public int countNegatives(int[][] grid) {
        int flag = 0, m = grid.length, n = grid[0].length;
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            //  需要排除正行都是非负数的情况
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
}
```

![1351_统计有序矩阵中的负数_力扣_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_Java.png)

## Python代码

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        flag, m, n = 0, len(grid), len(grid[0])
        for i in range(m):
            l, r = 0, n - 1
            while l < r :
                mid = (l + r) // 2
                if grid[i][mid] < 0 :
                    r = mid
                else :
                    l = mid + 1
            if grid[i][r] < 0 :
                flag += n - r
        return flag
```

![1351_统计有序矩阵中的负数_力扣_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_Python.png)

## C++代码

```C++
class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int flag = 0, m = size(grid), n = size(grid[0]);
        for(int i = 0; i < m; i++){
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r) / 2;
                if(grid[i][mid] < 0){
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            if(grid[i][r] < 0){
                flag += n - r;
            }
        }
        return flag;
    }
};
```

![1351_统计有序矩阵中的负数_力扣_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/2_%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/Images/1351_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0_%E5%8A%9B%E6%89%A3_C++.png)

