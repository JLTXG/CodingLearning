本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3714. 最长的平衡子串 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-balanced-substring-ii/description/?envType=daily-question&envId=2026-02-13)

>标签：资深工程师  |  哈希表  |  字符串  |  前缀和

# 一、题目描述

## **问题概括**

给定一个仅由小写英文字母 `'a'`、`'b'` 和 `'c'` 组成的字符串 `s`。一个连续非空的子串被称为**平衡子串**，当且仅当该子串中所有**不同字符**出现的次数都相等。请找出 `s` 中最长的平衡子串的长度，并返回该长度。

## **示例说明**

- **示例1**：`s = "abbac"`，最长平衡子串为 `"abba"`，其中 `'a'` 和 `'b'` 各出现 2 次，长度为 4。
- **示例2**：`s = "aabcc"`，最长平衡子串为 `"abc"`，其中 `'a'`、`'b'`、`'c'` 各出现 1 次，长度为 3。
- **示例3**：`s = "aba"`，最长平衡子串为 `"ab"` 或 `"ba"`，其中 `'a'` 和 `'b'` 各出现 1 次，长度为 2。

## **数据范围**

- `1 <= s.length <= 10^5`
- `s` 仅包含字符 `'a'`、`'b'` 和 `'c'`。



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```java
class Solution {
    public int longestBalanced(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        int ans = 0;

        // ========================
        // 情况1：只含1种字符（如 "aaaa"）
        // 这类子串天然满足“所有字符频次相等”
        // ========================
        for (int i = 0; i < n; ) {
            int start = i;
            // 向右扩展，直到字符改变
            for (i++; i < n && s[i] == s[i - 1]; i++) ;
            // 更新最长连续相同字符长度
            ans = Math.max(ans, i - start);
        }

        // ========================
        // 情况2：只含2种字符（如 "aabb", "abab"）
        // 枚举所有可能的两字符组合（题目限定只有 'a','b','c'）
        // ========================
        ans = Math.max(ans, f(s, 'a', 'b'));
        ans = Math.max(ans, f(s, 'a', 'c'));
        ans = Math.max(ans, f(s, 'b', 'c'));

        // ========================
        // 情况3：恰好含3种字符（'a','b','c'），且频次相等
        // 利用前缀和差值编码 + 哈希表找相同状态
        // ========================
        // 把 (diff1, diff2) 编码为一个 long：
        //   diff1 = cnt[a] - cnt[b]
        //   diff2 = cnt[b] - cnt[c]
        // 用 (diff1 + n) << 20 | (diff2 + n) 避免负数 & 冲突
        Map<Long, Integer> pos = new HashMap<>();
        // 初始状态：所有计数为0 → diff1=0, diff2=0
        // 对应位置设为 -1（虚拟起点）
        pos.put((long) n << 20 | n, -1);

        int[] cnt = new int[3]; // cnt[0]=a, cnt[1]=b, cnt[2]=c

        for (int i = 0; i < n; i++) {
            // 更新当前字符的计数
            cnt[s[i] - 'a']++;

            // 计算两个差值，并偏移 +n 避免负数
            long p = (long) (cnt[0] - cnt[1] + n) << 20 | (cnt[1] - cnt[2] + n);

            if (pos.containsKey(p)) {
                // 状态 p 之前出现过 → 中间子串满足 cnt[a]==cnt[b]==cnt[c]
                ans = Math.max(ans, i - pos.get(p));
            } else {
                pos.put(p, i); // 只记录首次出现位置（保证最长）
            }
        }

        return ans;
    }

    // 辅助函数：计算只含字符 x 和 y 的最长平衡子串
    private int f(char[] s, char x, char y) {
        int n = s.length;
        int ans = 0;

        // 枚举每个起始位置 i
        for (int i = 0; i < n; i++) {
            // 如果当前字符不是 x 或 y，跳过
            if (s[i] != x && s[i] != y) continue;

            // 哈希表记录前缀和 d = (#x - #y) 首次出现的位置
            Map<Integer, Integer> pos = new HashMap<>();
            // 初始状态：d=0 出现在 i-1（虚拟位置）
            pos.put(0, i - 1);

            int d = 0; // 当前 x 与 y 的数量差

            // 向右扩展，只包含 x 或 y
            for (; i < n && (s[i] == x || s[i] == y); i++) {
                d += (s[i] == x) ? 1 : -1;

                if (pos.containsKey(d)) {
                    // d 相同 ⇒ 中间子串 #x == #y
                    ans = Math.max(ans, i - pos.get(d));
                } else {
                    pos.put(d, i);
                }
            }
            i--; // 因为外层 for 会 i++，需回退
        }
        return ans;
    }
}
```

---

## 🧠 核心解题思想分析

### 🔍 问题约束

- 字符串 **只包含 'a', 'b', 'c' 三种字符**
- 平衡子串要求：**所有出现的字符频次相等**，且**最多3种**

因此只需考虑三种情况：

1. **1种字符**：任意长度都合法；
2. **2种字符**：两种频次必须相等；
3. **3种字符**：三种频次必须相等。

---

### 💡 分类处理策略

#### ✅ 情况1：1种字符

- 直接找**最长连续相同字符段**即可。
- 时间 O(n)

#### ✅ 情况2：2种字符

- 枚举所有两字符组合：(a,b), (a,c), (b,c)
- 对每种组合，使用 **前缀和 + 哈希表**：
    - 定义 `d = count(x) - count(y)`
    - 若 `d` 在位置 j 和 i 相同 ⇒ 子串 [j+1, i] 中 `#x == #y`
- 注意：必须保证子串**只含 x 和 y**，所以遇到第三种字符就中断

#### ✅ 情况3：3种字符

- 要求：`cnt[a] == cnt[b] == cnt[c]`
- 等价于：
  
    ```
    cnt[a] - cnt[b] = 0
    cnt[b] - cnt[c] = 0
    ```
    
- 所以我们维护两个差值：
    - `d1 = cnt[a] - cnt[b]`
    - `d2 = cnt[b] - cnt[c]`
- 若在位置 i 和 j 有相同的 `(d1, d2)`，则中间子串满足三者相等
- 用 `long` 编码 `(d1, d2)` 存入哈希表（偏移 +n 避免负数）

> 📌 为什么偏移 +n？
>
> - 最大差值绝对值 ≤ n，所以 `d + n ∈ [0, 2n]`
> - 用 `<< 20` 是因为 `2n ≤ 2000`（假设 n≤1000），20位足够（2^20 ≈ 1e6）

---

### 🌰 举例说明（3种字符）

字符串：`"abcabc"`

前缀计数：

| i    | a    | b    | c    | d1=a-b | d2=b-c | 编码 (d1+n, d2+n) |
| ---- | ---- | ---- | ---- | ------ | ------ | ----------------- |
| -1   | 0    | 0    | 0    | 0      | 0      | (n,n) → 初始      |
| 0    | 1    | 0    | 0    | 1      | 0      |                   |
| 1    | 1    | 1    | 0    | 0      | 1      |                   |
| 2    | 1    | 1    | 1    | 0      | 0      | ← 与初始相同！    |

→ 子串 `[0,2]`（"abc"）是平衡的，长度=3

继续到 i=5，再次出现 `(0,0)` → 子串 `[0,5]`（"abcabc"），长度=6

---

### ⏱️ 复杂度分析：

- **情况1**：O(n)
- **情况2**：3 × O(n) = O(n)
- **情况3**：O(n)
- **总时间**：O(n)
- **空间**：O(n)（哈希表）

> 💡 虽然看起来有三层循环，但每个字符最多被访问常数次（情况2中 `i--` 保证不重复扫描）

---

## 📚 笔记总结

### 🧩 问题定义：

子串中 **1~3 种字符**，且**每种字符出现次数完全相同**。

### 💡 核心思想：

> **分类讨论 + 前缀和差值编码 + 哈希表**

### ✅ 三种情况处理：

| 字符种类 | 方法                            | 关键条件                        |
| -------- | ------------------------------- | ------------------------------- |
| **1种**  | 扫描连续段                      | 任意长度合法                    |
| **2种**  | 枚举组合 + 前缀和 `d = #x - #y` | `d_i == d_j ⇒ 平衡`             |
| **3种**  | 维护 `(d1, d2) = (a-b, b-c)`    | `(d1,d2)_i == (d1,d2)_j ⇒ 平衡` |

### 🔑 关键技巧：

- **只考虑 'a','b','c'**，组合数有限（C(3,2)=3）；
- **用差值代替绝对计数**，避免存储三维状态；
- **偏移 +n 编码负数**，用 `long` 合并两个整数；
- **哈希表只存首次位置**，保证子串最长。

### ⏱️ 复杂度：

- 时间：O(n)
- 空间：O(n)

### 💡 延伸思考：

- 若字符集更大？→ 无法枚举组合，需其他方法；
- 本题利用了**字符集极小（仅3个）** 的特殊性质。

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public int longestBalanced(String S) {
        char[] s = S.toCharArray();
        int n = s.length;
        int ans = 0;

        // ========================
        // 情况1：只含1种字符（如 "aaaa"）
        // 这类子串天然满足“所有字符频次相等”
        // ========================
        for (int i = 0; i < n; ) {
            int start = i;
            // 向右扩展，直到字符改变
            for (i++; i < n && s[i] == s[i - 1]; i++) ;
            // 更新最长连续相同字符长度
            ans = Math.max(ans, i - start);
        }

        // ========================
        // 情况2：只含2种字符（如 "aabb", "abab"）
        // 枚举所有可能的两字符组合（题目限定只有 'a','b','c'）
        // ========================
        ans = Math.max(ans, f(s, 'a', 'b'));
        ans = Math.max(ans, f(s, 'a', 'c'));
        ans = Math.max(ans, f(s, 'b', 'c'));

        // ========================
        // 情况3：恰好含3种字符（'a','b','c'），且频次相等
        // 利用前缀和差值编码 + 哈希表找相同状态
        // ========================
        // 把 (diff1, diff2) 编码为一个 long：
        //   diff1 = cnt[a] - cnt[b]
        //   diff2 = cnt[b] - cnt[c]
        // 用 (diff1 + n) << 20 | (diff2 + n) 避免负数 & 冲突
        Map<Long, Integer> pos = new HashMap<>();
        // 初始状态：所有计数为0 → diff1=0, diff2=0
        // 对应位置设为 -1（虚拟起点）
        pos.put((long) n << 20 | n, -1);

        int[] cnt = new int[3]; // cnt[0]=a, cnt[1]=b, cnt[2]=c

        for (int i = 0; i < n; i++) {
            // 更新当前字符的计数
            cnt[s[i] - 'a']++;

            // 计算两个差值，并偏移 +n 避免负数
            long p = (long) (cnt[0] - cnt[1] + n) << 20 | (cnt[1] - cnt[2] + n);

            if (pos.containsKey(p)) {
                // 状态 p 之前出现过 → 中间子串满足 cnt[a]==cnt[b]==cnt[c]
                ans = Math.max(ans, i - pos.get(p));
            } else {
                pos.put(p, i); // 只记录首次出现位置（保证最长）
            }
        }

        return ans;
    }

    // 辅助函数：计算只含字符 x 和 y 的最长平衡子串
    private int f(char[] s, char x, char y) {
        int n = s.length;
        int ans = 0;

        // 枚举每个起始位置 i
        for (int i = 0; i < n; i++) {
            // 如果当前字符不是 x 或 y，跳过
            if (s[i] != x && s[i] != y) continue;

            // 哈希表记录前缀和 d = (#x - #y) 首次出现的位置
            Map<Integer, Integer> pos = new HashMap<>();
            // 初始状态：d=0 出现在 i-1（虚拟位置）
            pos.put(0, i - 1);

            int d = 0; // 当前 x 与 y 的数量差

            // 向右扩展，只包含 x 或 y
            for (; i < n && (s[i] == x || s[i] == y); i++) {
                d += (s[i] == x) ? 1 : -1;

                if (pos.containsKey(d)) {
                    // d 相同 ⇒ 中间子串 #x == #y
                    ans = Math.max(ans, i - pos.get(d));
                } else {
                    pos.put(d, i);
                }
            }
            i--; // 因为外层 for 会 i++，需回退
        }
        return ans;
    }
}
```



## Python代码

```Python
class Solution:
    def longestBalanced(self, s: str) -> int:
        string = list(s)
        n = len(string)
        ans = 0

        # 一种字母
        i = 0
        while i < n:
            start = i
            i += 1
            while i < n and string[i] == string[i - 1]:
                i += 1
            ans = max(ans, i - start)
        
        # 两种字母
        ans = max(ans, self.f(string, 'a', 'b'))
        ans = max(ans, self.f(string, 'a', 'c'))
        ans = max(ans, self.f(string, 'b', 'c'))

        # 三种字母
        pos = dict()
        # 初始状态：(0, 0) -> 编码为 (n << 20) | n
        pos[(n << 20) | n] = -1
        cnt = [0, 0, 0]  # a, b, c

        for i in range(n):
            idx = ord(string[i]) - ord('a')
            if 0 <= idx < 3:
                cnt[idx] += 1
            # 计算差值并偏移 +n
            d1 = cnt[0] - cnt[1] + n
            d2 = cnt[1] - cnt[2] + n
            p = (d1 << 20) | d2
            if p in pos:
                ans = max(ans, i - pos[p])
            else:
                pos[p] = i
            
        return ans

    def f(self, s, x, y):
        n = len(s)
        ans = 0
        i = 0
        while i < n:
            if s[i] != x and s[i] != y:
                i += 1
                continue
            pos = dict()
            pos[0] = i - 1
            d = 0
            # 向右扩展只包含 x 或 y 的子串
            while i < n and (s[i] == x or s[i] == y):
                if s[i] == x:
                    d += 1
                else:
                    d -= 1
                if d in pos:
                    ans = max(ans, i - pos[d])
                else:
                    pos[d] = i
                i += 1
            # 注意：外层 while 不会自动 i++，所以此处无需 i--
        return ans
```

![3714_最长的平衡子串 II_Python]()

## C++代码

```C++
class Solution {
public:
    int longestBalanced(string s) {
        int n = s.length();
        int ans = 0;

        // 一种字母
        for (int i = 0; i < n; ) {
            int start = i;
            for (i++; i < n && s[i] == s[i - 1]; i++) ;
            ans = max(ans, i - start);
        }

        // 两种字母
        ans = max(ans, f(s, 'a', 'b'));
        ans = max(ans, f(s, 'a', 'c'));
        ans = max(ans, f(s, 'b', 'c'));

        // 三种字母
        unordered_map<long long, int> pos;
        // 初始状态：(0, 0) -> (n << 20) | n
        pos[(static_cast<long long>(n) << 20) | n] = -1;
        vector<int> cnt(3, 0);  // a, b, c

        for (int i = 0; i < n; i++) {
            int idx = s[i] - 'a';
            if (idx >= 0 && idx < 3) {
                cnt[idx]++;
            }
            long long d1 = cnt[0] - cnt[1] + n;
            long long d2 = cnt[1] - cnt[2] + n;
            long long p = (d1 << 20) | d2;
            if (pos.find(p) != pos.end()) {
                ans = max(ans, i - pos[p]);
            } else {
                pos[p] = i;
            }
        }

        return ans;
    }

private:
    int f(const string& s, char x, char y) {
        int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] != x && s[i] != y) continue;
            unordered_map<int, int> pos;
            pos[0] = i - 1;
            int d = 0;
            for (; i < n && (s[i] == x || s[i] == y); i++) {
                d += (s[i] == x) ? 1 : -1;
                if (pos.find(d) != pos.end()) {
                    ans = max(ans, i - pos[d]);
                } else {
                    pos[d] = i;
                }
            }
            i--;  // 因为外层 for 会 i++，需回退
        }
        return ans;
    }
};
```

