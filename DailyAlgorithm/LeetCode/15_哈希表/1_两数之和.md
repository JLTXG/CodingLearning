本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  哈希表

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums` 和一个整数目标值 `target`。你的任务是，在数组中找到两个元素，使得它们的和等于目标值 `target`，并返回这两个元素在数组中的索引（下标）。

你可以假设：对于每个输入，只会存在一个有效的答案。此外，你不能使用同一个数组元素两次（即每个元素在答案中只能出现一次）。

答案可以以任意顺序返回（即两个索引的顺序不重要）。

## **示例说明**

- **示例1**：`nums = [2,7,11,15]`, `target = 9`。因为 `nums[0] + nums[1] = 2 + 7 = 9`，所以返回 `[0, 1]`。
- **示例2**：`nums = [3,2,4]`, `target = 6`。`nums[1] + nums[2] = 2 + 4 = 6`，返回 `[1, 2]`。
- **示例3**：`nums = [3,3]`, `target = 6`。返回 `[0, 1]`。

## **数据范围**

- 数组长度在 `2` 到 `10^4` 之间。
- 数组中的每个元素以及目标值 `target` 均在 `-10^9` 到 `10^9` 之间。
- 保证每个输入有且仅有一个有效答案。

## **进阶思考**

你能想出一个时间复杂度低于 O(n²) 的算法来解决这个问题吗？



# 二、解题思路\解题过程

这是一道简单的编程题目，可以采用两种思路来求解，最直接的方法就是直接暴力模拟求解；然后可以考虑使用哈希表来求解，在遍历数组的过程中，遍历到当前的数组值，然后去另外一堆数组值中去找有没有加起来等于`target`的值（也就是`target - nums[i]`），两种思路的具体代码如下！



# 三、代码演示

## Java代码

```Java
// 暴力模拟
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[0];
    }
}

// 哈希表写法
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int tmp = nums[i];
            if (map.containsKey(target - tmp)) {
                return new int[] {map.get(target - tmp), i};
            }
            map.put(tmp, i);
        }
        return new int[] {};
    }
}
```



## Python代码

```Python
# 哈希表写法
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        my_map = {}
        for i in range(len(nums)):
            tmp = nums[i]
            if target - tmp in my_map :
                return [my_map[target - tmp], i]
            my_map[tmp] = i
        return []
```



## C++代码

```C++
// 暴力模拟
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int num = 0;
        num = nums.size();
        for (int i = 0; i < num; i++) {
            for (int j = i + 1; j < num; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};

// 哈希表写法
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;  // key：数值，value：下标
        for (int i = 0; i < nums.size(); i++) {
            int tmp = nums[i];
            if (map.find(target - tmp) != map.end()) {
                return {map[target - tmp], i};
            }
            map[tmp] = i;
        }
        return {};
    }
};
```

![1_两数之和_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C_C++.png)