æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[138. éšæœºé“¾è¡¨çš„å¤åˆ¶ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

>æ ‡ç­¾ï¼šå“ˆå¸Œè¡¨  |  é“¾è¡¨

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ `next` æŒ‡é’ˆå¤–ï¼Œè¿˜åŒ…å«ä¸€ä¸ªé¢å¤–çš„ `random` æŒ‡é’ˆï¼Œå¯ä»¥æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„èŠ‚ç‚¹æˆ–ä¸ºç©ºã€‚è¯·æ„é€ è¯¥é“¾è¡¨çš„**æ·±æ‹·è´**ï¼Œå³åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„é“¾è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ä¸åŸé“¾è¡¨å¯¹åº”èŠ‚ç‚¹ç›¸åŒï¼Œä¸” `next` å’Œ `random` æŒ‡é’ˆéƒ½æ­£ç¡®æŒ‡å‘å¤åˆ¶é“¾è¡¨ä¸­çš„å¯¹åº”èŠ‚ç‚¹ï¼Œä½¿å¾—ä¸¤ä¸ªé“¾è¡¨åœ¨ç»“æ„ä¸Šå®Œå…¨ä¸€è‡´ã€‚è¿”å›å¤åˆ¶é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- è¾“å…¥ï¼š`head = [[7,null],[13,0],[11,4],[10,2],[1,0]]`ï¼Œè¾“å‡ºåº”å…·æœ‰ç›¸åŒçš„èŠ‚ç‚¹å€¼å’ŒæŒ‡é’ˆå…³ç³»ã€‚
- è¾“å…¥ï¼š`head = [[1,1],[2,1]]`ï¼Œè¾“å‡ºå¯¹åº”å¤åˆ¶é“¾è¡¨ã€‚
- è¾“å…¥ï¼š`head = [[3,null],[3,0],[3,null]]`ï¼Œè¾“å‡ºå¯¹åº”å¤åˆ¶é“¾è¡¨ã€‚

## **æ•°æ®èŒƒå›´**

- é“¾è¡¨èŠ‚ç‚¹æ•° `n` æ»¡è¶³ `0 â‰¤ n â‰¤ 1000`ã€‚
- èŠ‚ç‚¹å€¼èŒƒå›´ `-10^4 â‰¤ Node.val â‰¤ 10^4`ã€‚
- `Node.random` ä¸º `null` æˆ–æŒ‡å‘é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„ä»£ç 

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    // å“ˆå¸Œè¡¨ï¼šç”¨äºç¼“å­˜ã€ŒåŸèŠ‚ç‚¹ â†’ æ–°èŠ‚ç‚¹ã€çš„æ˜ å°„
    // ä½œç”¨ï¼šé¿å…é‡å¤åˆ›å»ºåŒä¸€ä¸ªèŠ‚ç‚¹çš„å‰¯æœ¬ï¼ˆè§£å†³ç¯å’Œå¤šæŒ‡é’ˆæŒ‡å‘åŒä¸€èŠ‚ç‚¹çš„é—®é¢˜ï¼‰
    Map<Node, Node> cacheNode = new HashMap<>();

    public Node copyRandomList(Node head) {
        // é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šåŸèŠ‚ç‚¹ä¸ºç©ºï¼Œè¿”å› null
        if (head == null) {
            return null;
        }

        // å¦‚æœå½“å‰åŸèŠ‚ç‚¹å°šæœªè¢«å¤åˆ¶ï¼Œåˆ™è¿›è¡Œå¤åˆ¶
        if (!cacheNode.containsKey(head)) {
            // åˆ›å»ºæ–°èŠ‚ç‚¹ï¼ˆåªå¤åˆ¶å€¼ï¼Œnext å’Œ random æš‚ä¸ºç©ºï¼‰
            Node headNew = new Node(head.val);
            
            // â­ å…³é”®ï¼šå…ˆå°†æ–°èŠ‚ç‚¹å­˜å…¥ç¼“å­˜ï¼Œå†é€’å½’å¤„ç†å­ç»“æ„
            // è¿™æ ·å³ä½¿åç»­é€’å½’ä¸­å†æ¬¡é‡åˆ° headï¼ˆå¦‚é€šè¿‡ random æŒ‡é’ˆï¼‰ï¼Œä¹Ÿèƒ½ç›´æ¥è¿”å›å·²åˆ›å»ºçš„å‰¯æœ¬
            cacheNode.put(head, headNew);

            // é€’å½’å¤åˆ¶ next æŒ‡é’ˆæŒ‡å‘çš„å­é“¾è¡¨
            headNew.next = copyRandomList(head.next);

            // é€’å½’å¤åˆ¶ random æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹
            headNew.random = copyRandomList(head.random);
        }

        // è¿”å›å·²ç¼“å­˜çš„æ–°èŠ‚ç‚¹ï¼ˆç¡®ä¿æ¯ä¸ªåŸèŠ‚ç‚¹åªåˆ›å»ºä¸€æ¬¡ï¼‰
        return cacheNode.get(head);
    }
}
```

> ğŸ’¡ æ³¨æ„ï¼š**å¿…é¡»åœ¨é€’å½’è°ƒç”¨å‰å°±å°†æ–°èŠ‚ç‚¹æ”¾å…¥ `cacheNode`**ï¼Œå¦åˆ™åœ¨å­˜åœ¨ç¯æˆ–äº¤å‰å¼•ç”¨æ—¶ä¼šæ— é™é€’å½’æˆ–é‡å¤åˆ›å»ºã€‚

---

## ğŸ§  æ ¸å¿ƒè§£é¢˜æ€æƒ³åˆ†æ

### ğŸ” é—®é¢˜éš¾ç‚¹ï¼š

æ™®é€šé“¾è¡¨åªéœ€å¤åˆ¶ `val` å’Œ `next`ï¼Œä½†æœ¬é¢˜æ¯ä¸ªèŠ‚ç‚¹è¿˜æœ‰ `random` æŒ‡é’ˆï¼Œå¯èƒ½æŒ‡å‘ï¼š

- é“¾è¡¨ä¸­ä»»æ„èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬è‡ªèº«ï¼‰
- `null`
- **å¤šä¸ªèŠ‚ç‚¹çš„ `random` å¯èƒ½æŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹**

å› æ­¤ï¼Œ**ä¸èƒ½ç®€å•åœ°â€œå…ˆå»ºèŠ‚ç‚¹å†è¿æŒ‡é’ˆâ€**ï¼Œå› ä¸ºï¼š

- è‹¥å…ˆåˆ›å»ºæ‰€æœ‰æ–°èŠ‚ç‚¹ï¼Œå†è¿ `random`ï¼Œéœ€è¦é¢å¤–æ˜ å°„ï¼›
- è‹¥è¾¹å»ºè¾¹è¿ï¼Œå¯èƒ½å›  `random` æŒ‡å‘æœªåˆ›å»ºçš„èŠ‚ç‚¹è€Œå¤±è´¥ã€‚

---

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š**é€’å½’ + è®°å¿†åŒ–ï¼ˆMemoizationï¼‰**

#### 1. **é€’å½’å¤©ç„¶åŒ¹é…é“¾è¡¨ç»“æ„**

- æ¯ä¸ªèŠ‚ç‚¹çš„å¤åˆ¶ä¾èµ–äº `next` å’Œ `random` èŠ‚ç‚¹çš„å¤åˆ¶ï¼›
- é€’å½’å¯ä»¥è‡ªç„¶åœ°â€œå…ˆå¤„ç†ä¾èµ–ï¼Œå†ç»„è£…â€ã€‚

#### 2. **ä¸ºä»€ä¹ˆéœ€è¦å“ˆå¸Œè¡¨ç¼“å­˜ï¼Ÿ**

- **é¿å…é‡å¤åˆ›å»º**ï¼šè‹¥ä¸¤ä¸ªèŠ‚ç‚¹çš„ `random` éƒ½æŒ‡å‘èŠ‚ç‚¹ Aï¼Œåˆ™ A çš„å‰¯æœ¬åº”åªåˆ›å»ºä¸€æ¬¡ï¼›
- **æ‰“ç ´å¾ªç¯ä¾èµ–**ï¼šå¦‚æœ `A.random = B` ä¸” `B.random = A`ï¼Œæ²¡æœ‰ç¼“å­˜ä¼šå¯¼è‡´æ— é™é€’å½’ï¼›
- **ä¿è¯ä¸€è‡´æ€§**ï¼šç¡®ä¿æ‰€æœ‰æŒ‡å‘åŒä¸€åŸèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œéƒ½æŒ‡å‘åŒä¸€ä¸ªæ–°èŠ‚ç‚¹ã€‚

#### 3. **ç¼“å­˜æ—¶æœºè‡³å…³é‡è¦**

```java
cacheNode.put(head, headNew); // âœ… å…ˆç¼“å­˜
headNew.next = copyRandomList(head.next); // å†é€’å½’
```

å¦‚æœå†™æˆï¼š

```java
headNew.next = copyRandomList(head.next);
cacheNode.put(head, headNew); // âŒ åç¼“å­˜ â†’ å¯èƒ½é‡å¤åˆ›å»º
```

é‚£ä¹ˆåœ¨ `copyRandomList(head.random)` ä¸­è‹¥åˆé‡åˆ° `head`ï¼Œä¼šå†æ¬¡è¿›å…¥ `if` åˆ†æ”¯ï¼Œåˆ›å»ºç¬¬äºŒä¸ªå‰¯æœ¬ï¼

---

### ğŸ”„ ç¤ºä¾‹è¯´æ˜

å‡è®¾é“¾è¡¨ï¼š`A â†’ B â†’ null`ï¼Œä¸” `A.random = B`, `B.random = A`

é€’å½’è¿‡ç¨‹ï¼š

1. `copy(A)` â†’ åˆ›å»º `A'`ï¼Œç¼“å­˜ `{A: A'}`
2. é€’å½’ `A'.next = copy(B)`
    - `copy(B)` â†’ åˆ›å»º `B'`ï¼Œç¼“å­˜ `{A:A', B:B'}`
    - é€’å½’ `B'.next = copy(null) â†’ null`
    - é€’å½’ `B'.random = copy(A)` â†’ æŸ¥ç¼“å­˜å¾— `A'` âœ…
3. å›åˆ° `A'`ï¼š`A'.random = copy(B)` â†’ æŸ¥ç¼“å­˜å¾— `B'` âœ…

æœ€ç»ˆï¼š`A' â†’ B' â†’ null`ï¼Œä¸” `A'.random = B'`, `B'.random = A'` âœ”ï¸

---

### â±ï¸ å¤æ‚åº¦åˆ†æï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n)  
    â€”â€” æ¯ä¸ªèŠ‚ç‚¹åªè¢«å¤åˆ¶ä¸€æ¬¡ï¼Œå“ˆå¸Œè¡¨æ“ä½œ O(1)
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)  
    â€”â€” å“ˆå¸Œè¡¨å­˜å‚¨ n ä¸ªæ˜ å°„ + é€’å½’æ ˆæ·±åº¦ O(n)

> âœ… è¿™æ˜¯æœ€æ¸…æ™°ã€æœ€å¯é çš„è§£æ³•ä¹‹ä¸€ï¼

---

## ğŸ“š ç¬”è®°æ€»ç»“

### ğŸ§© é—®é¢˜ç‰¹ç‚¹ï¼š

- èŠ‚ç‚¹åŒ…å« `next` å’Œ `random` ä¸¤ä¸ªæŒ‡é’ˆï¼›
- `random` å¯æŒ‡å‘ä»»æ„èŠ‚ç‚¹ï¼ˆå«è‡ªèº«æˆ– nullï¼‰ï¼›
- è¦æ±‚**æ·±æ‹·è´**ï¼šæ–°é“¾è¡¨ä¸åŸé“¾è¡¨å®Œå…¨ç‹¬ç«‹ã€‚

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š

> **é€’å½’ + å“ˆå¸Œè¡¨è®°å¿†åŒ–ï¼ˆMemoizationï¼‰**

### âœ… ç®—æ³•æ­¥éª¤ï¼š

1. è‹¥ `head == null`ï¼Œè¿”å› `null`ï¼›
2. è‹¥ `head` å·²åœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥è¿”å›å…¶å‰¯æœ¬ï¼›
3. å¦åˆ™ï¼š
    - åˆ›å»ºæ–°èŠ‚ç‚¹ `newNode(val = head.val)`
    - **ç«‹å³å°† `(head â†’ newNode)` å­˜å…¥å“ˆå¸Œè¡¨**
    - é€’å½’è®¾ç½® `newNode.next = copy(head.next)`
    - é€’å½’è®¾ç½® `newNode.random = copy(head.random)`
4. è¿”å› `newNode`

### ğŸ”‘ å…³é”®æŠ€å·§ï¼š

- **å…ˆç¼“å­˜ï¼Œå†é€’å½’**ï¼šé˜²æ­¢é‡å¤åˆ›å»ºå’Œæ— é™é€’å½’ï¼›
- **å“ˆå¸Œè¡¨æ˜ å°„åŸâ†’æ–°**ï¼šç¡®ä¿æŒ‡é’ˆä¸€è‡´æ€§ï¼›
- **é€’å½’è‡ªåŠ¨å¤„ç†ä¾èµ–**ï¼šæ— éœ€å…³å¿ƒåˆ›å»ºé¡ºåºã€‚

### â±ï¸ å¤æ‚åº¦ï¼š

- æ—¶é—´ï¼šO(n)
- ç©ºé—´ï¼šO(n)ï¼ˆå“ˆå¸Œè¡¨ + é€’å½’æ ˆï¼‰

### ğŸ’¡ å…¶ä»–è§£æ³•ï¼ˆæ‹“å±•ï¼‰ï¼š

- **è¿­ä»£ + ä¸‰æ¬¡éå†**ï¼š
    1. åœ¨åŸèŠ‚ç‚¹åæ’å…¥å‰¯æœ¬ï¼ˆA â†’ A' â†’ B â†’ B'ï¼‰
    2. è®¾ç½® randomï¼š`A'.random = A.random.next`
    3. æ‹†åˆ†æ–°æ—§é“¾è¡¨
       
        > ä¼˜ç‚¹ï¼šO(1) é¢å¤–ç©ºé—´ï¼ˆä¸è®¡è¾“å‡ºï¼‰ï¼›ç¼ºç‚¹ï¼šä¿®æ”¹åŸé“¾è¡¨ï¼ˆéœ€æ¢å¤ï¼‰
        

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    Map<Node, Node> cacheNode = new HashMap<Node, Node>();

    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        if (!cacheNode.containsKey(head)) {
            Node headNew = new Node(head.val);
            cacheNode.put(head, headNew);
            headNew.next = copyRandomList(head.next);
            headNew.random = copyRandomList(head.random);
        }
        return cacheNode.get(head);
    }
}
```

![138_éšæœºé“¾è¡¨çš„å¤åˆ¶_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/138_%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6_Java.png)

## Pythonä»£ç 

```Python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution:
    def __init__(self):
        self.cacheNode = {}
    
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None
        if head not in self.cacheNode:
            headNew = Node(head.val)
            self.cacheNode[head] = headNew
            headNew.next = self.copyRandomList(head.next)
            headNew.random = self.copyRandomList(head.random)
        return self.cacheNode[head]    
```



## C++ä»£ç 

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    unordered_map<Node*, Node*> cacheNode;
    
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (cacheNode.find(head) == cacheNode.end()) {
            Node* headNew = new Node(head->val);
            cacheNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cacheNode[head];
    }
};
```

