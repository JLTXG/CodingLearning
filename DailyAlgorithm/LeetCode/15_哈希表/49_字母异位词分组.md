本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  哈希表  |  字符串  |  排序

# 一、题目描述

## **问题概括**

给定一个仅包含小写字母的字符串数组 `strs`，请将其中所有**字母异位词**（即通过重新排列字母能够相互转换的字符串）分组在一起。分组结果可以以任意顺序返回。

## **示例说明**

- **示例1**：输入 `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`，输出 `[["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]`。
- **示例2**：输入 `strs = [""]`，输出 `[[""]]`。
- **示例3**：输入 `strs = ["a"]`，输出 `[["a"]]`。

## **数据范围**

- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母。



# 二、解题思路\解题过程

将题目提供的字符串数组中的每个字符串中的字符进行排序重组，这样原字符串数组中哪些字符串是“字母异位词”我们一循环就知道了，我们可以采用哈希表的写法，把排序后的字符串当做`key`，把原字符串当做`value`。

先定义一个哈希表，然后循环原字符串数组，然后将原字符串元素进行排序重组，然后判断重组后的字符串在哈希表中的`key`中存不存在，如果不存在就重新加一个`key`，然后在把原字符串当做`value`加入；如果存在，那就直接加入，然后一个个循环就可以得到最终的答案了，代码如下！

# 三、代码演示

## Java代码

```Java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 创建一个 HashMap : key 是排序后的字符串，value 是该字母异位词组的列表
        Map<String, List<String>> map = new HashMap<>();

        for (String s : strs) {
            // 将字符串转为字符数组并排序
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            // 排序后的字符串作为 key
            String sortedStr = new String(chars);

            // 检查 map 中是否已有这个 key
            if (!map.containsKey(sortedStr)) {
                // 如果没有，创建一个新的 ArrayList 作为该组的容器
                map.put(sortedStr, new ArrayList<String>());
            }

            // 把原字符串 s 加入对应的分组中
            map.get(sortedStr).add(s);
        }

        // 将所有分组（即 map 的 values）放入结果列表并返回
        return new ArrayList<List<String>>(map.values());
    }
}
```



## Python代码

```Python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = {}

        for s in strs:
            # 将字符串排序后转为 tuple（因为 list 不可哈希）
            key = ''.join(sorted(s))

            if key not in groups :
                groups[key] = []
            
            groups[key].append(s)
        
        # 返回所有分组（字典的 values）
        return list(groups.values())
```

![49_字母异位词分组_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/49_%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84_Python.png)

## C++代码

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 哈希表：key 是排序后的字符串，value 是该组的所有原字符串
        unordered_map<string, vector<string>> groups;

        for (const string& s : strs) {
            // 复制原字符串
            string key = s;
            // 排序得到 key
            sort(key.begin(), key.end());
            // 自动创建 vector（若不存在）
            groups[key].push_back(s);
        }

        // 将哈希表中的所有 value（即分组）放入结果 vector
        vector<vector<string>> result;
        for (const auto& pair : groups) {
            result.push_back(pair.second);
        }

        return result;
    }
};
```

