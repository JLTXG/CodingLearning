本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3713. 最长的平衡子串 I - 力扣（LeetCode）](https://leetcode.cn/problems/longest-balanced-substring-i/description/?envType=daily-question&envId=2026-02-12)

>标签：高级工程师  |  哈希表  |  字符串  |  计数  |  枚举

# 一、题目描述

## **问题概括**

给定一个仅由小写英文字母组成的字符串 `s`。一个子串被称为**平衡子串**，当且仅当该子串中所有**不同的字符**在子串中出现的**次数均相等**。请找出 `s` 中最长的平衡子串的长度，并返回该长度。

## **示例说明**

- **示例1**：`s = "abbac"`，最长平衡子串为 `"abba"`，其中字符 `'a'` 和 `'b'` 各出现 2 次，长度为 4。
- **示例2**：`s = "zzabccy"`，最长平衡子串为 `"zabc"`，其中字符 `'z'`、`'a'`、`'b'`、`'c'` 各出现 1 次，长度为 4。
- **示例3**：`s = "aba"`，最长平衡子串为 `"ab"` 或 `"ba"`，其中 `'a'` 和 `'b'` 各出现 1 次，长度为 2。

## **数据范围**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成。



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```java
class Solution {
    public int longestBalanced(String S) {
        char[] s = S.toCharArray(); // 转为字符数组，提升访问效率
        int n = s.length;
        int ans = 0; // 记录最长平衡子串长度

        // 枚举所有可能的起始位置 i
        for (int i = 0; i < n; i++) {
            // cnt[c] 表示当前子串中字符 'a'+c 的出现次数
            int[] cnt = new int[26];
            int mx = 0;     // 当前子串中字符的最大出现次数
            int kinds = 0;  // 当前子串中不同字符的种类数

            // 从 i 开始向右扩展子串 [i, j]
            for (int j = i; j < n; j++) {
                int b = s[j] - 'a'; // 当前字符的索引（0~25）

                // 如果该字符是第一次在当前子串中出现
                if (cnt[b] == 0) {
                    kinds++; // 种类数 +1
                }

                // 更新该字符的计数，并同步更新最大频次 mx
                mx = Math.max(mx, ++cnt[b]);

                // 🧠 核心判断条件：
                // 若子串长度 == 最大频次 × 字符种类数，
                // 则说明所有字符出现次数都等于 mx（即“平衡”）
                if (mx * kinds == j - i + 1) {
                    ans = Math.max(ans, j - i + 1);
                }
            }
        }
        return ans;
    }
}
```

---

## 🧠 核心解题思想分析

### 🔍 问题定义

一个子串是“平衡”的，当且仅当：

> **所有在子串中出现的字符，其出现次数完全相同**。

这包括两种情况：

1. **单一字符**：如 `"aaa"` → 只有 'a'，出现 3 次 → 平衡；
2. **多字符且频次一致**：如 `"aabbcc"` → a:2, b:2, c:2 → 平衡。

---

### 💡 核心洞察：**数学等价条件**

设当前子串：

- 长度为 `L = j - i + 1`
- 有 `k` 种不同字符
- 每种字符出现 `f` 次（理想情况下）

则必有：
  **`L = k × f`**

而在实际遍历中，我们不知道 `f`，但知道：

- `mx = max(各字符频次)`
- 若所有字符频次都等于 `mx`，则 `L = k × mx`

✅ 所以判断条件就是：
  **`mx * kinds == 子串长度`**

> ⚠️ 注意：这个条件是**充分必要**的！
>
> - 如果成立 → 所有字符频次 = mx（否则总和 < mx × kinds）
> - 如果不成立 → 至少有一个字符频次 < mx

---

### 🌰 举例说明

#### 例1：`"aabb"`

- i=0, j=3:
    - cnt: a→2, b→2
    - mx=2, kinds=2
    - 长度=4
    - `2×2 == 4` → ✅ 平衡

#### 例2：`"abcc"`

- i=0, j=3:
    - cnt: a→1, b→1, c→2
    - mx=2, kinds=3
    - 长度=4
    - `2×3 = 6 ≠ 4` → ❌ 不平衡

#### 例3：`"aaaa"`

- i=0, j=3:
    - cnt: a→4
    - mx=4, kinds=1
    - 长度=4
    - `4×1 == 4` → ✅ 平衡

---

### ⏱️ 复杂度分析：

- **时间复杂度**：O(n² × 26) → 实际 O(n²)，因为内层操作是 O(1)
    - 外层 i：n 次
    - 内层 j：平均 n/2 次
    - 每次操作：数组访问 + 简单算术
- **空间复杂度**：O(26) = O(1) —— 固定大小计数数组

> 💡 对于 `n ≤ 1000`（本题数据范围），O(n²) 完全可接受。

---

## 📚 笔记总结

### 🧩 问题定义：

找最长子串，使得**所有出现过的字符，其出现次数完全相同**。

### 💡 核心思想：

> **暴力枚举 + 频次统计 + 数学判定**

#### 关键等价条件：

> 子串平衡 ⇨ `最大频次 × 字符种类数 == 子串长度`

#### 算法步骤：

1. 枚举所有起始位置 `i`；
2. 从 `i` 向右扩展终点 `j`，动态维护：
    - `cnt[26]`：各字符频次
    - `mx`：当前最大频次
    - `kinds`：不同字符种类数
3. 每次扩展后，检查 `mx * kinds == length`；
4. 若成立，更新答案。

### 🔑 关键技巧：

- **用 `mx * kinds == length` 代替逐个比较频次**，避免 O(26) 判断；
- **只在新增字符时更新 `kinds`**，高效维护种类数；
- **原地复用计数数组**，空间 O(1)。

### ⏱️ 复杂度：

- 时间：O(n²)
- 空间：O(1)

### 💡 延伸思考：

- 若字符集更大（如 Unicode）？→ 改用 `HashMap`
- 能否优化到 O(n)？→ 目前无已知线性解法，本题暴力足够

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public int longestBalanced(String S) {
        char[] s = S.toCharArray(); // 转为字符数组，提升访问效率
        int n = s.length;
        int ans = 0; // 记录最长平衡子串长度

        // 枚举所有可能的起始位置 i
        for (int i = 0; i < n; i++) {
            // cnt[c] 表示当前子串中字符 'a'+c 的出现次数
            int[] cnt = new int[26];
            int mx = 0;     // 当前子串中字符的最大出现次数
            int kinds = 0;  // 当前子串中不同字符的种类数

            // 从 i 开始向右扩展子串 [i, j]
            for (int j = i; j < n; j++) {
                int b = s[j] - 'a'; // 当前字符的索引（0~25）

                // 如果该字符是第一次在当前子串中出现
                if (cnt[b] == 0) {
                    kinds++; // 种类数 +1
                }

                // 更新该字符的计数，并同步更新最大频次 mx
                mx = Math.max(mx, ++cnt[b]);

                // 🧠 核心判断条件：
                // 若子串长度 == 最大频次 × 字符种类数，
                // 则说明所有字符出现次数都等于 mx（即“平衡”）
                if (mx * kinds == j - i + 1) {
                    ans = Math.max(ans, j - i + 1);
                }
            }
        }
        return ans;
    }
}
```



## Python代码

```python
class Solution:
    def longestBalanced(self, S: str) -> int:
        s = list(S)
        n = len(s)
        ans = 0
        for i in range(n):
            cnt = [0] * 26
            mx = 0
            kinds = 0
            for j in range(i, n):
                b = ord(s[j]) - ord('a')
                if cnt[b] == 0:
                    kinds += 1
                cnt[b] += 1
                mx = max(mx, cnt[b])
                if mx * kinds == j - i + 1:
                    ans = max(ans, j - i + 1)
        return ans
```

![3713_最长的平衡子串 I_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/3713_%E6%9C%80%E9%95%BF%E7%9A%84%E5%B9%B3%E8%A1%A1%E5%AD%90%E4%B8%B2%20I_Python.png)

## C++代码

```C++
class Solution {
public:
    int longestBalanced(string S) {
        string s = S;
        int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            vector<int> cnt(26, 0);
            int mx = 0;
            int kinds = 0;
            for (int j = i; j < n; j++) {
                int b = s[j] - 'a';
                if (cnt[b] == 0) {
                    kinds++;
                }
                cnt[b]++;
                mx = max(mx, cnt[b]);
                if (mx * kinds == j - i + 1) {
                    ans = max(ans, j - i + 1);
                }
            }
        }
        return ans;
    }
};
```

