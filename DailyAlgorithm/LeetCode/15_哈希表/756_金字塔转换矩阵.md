本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[756. 金字塔转换矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/pyramid-transition-matrix/description/?envType=daily-question&envId=2025-12-29)

>标签：位运算  |  哈希表  |  字符串  |  回溯

# 一、题目描述

## **问题概括**

你正在使用不同颜色的积木搭建一个金字塔，每种颜色用一个英文大写字母表示。金字塔的每一层比其下面一层少一个积木，且每一层都居中放置。搭建过程必须遵循特定的三角形规则。

这些规则通过一个字符串列表 `allowed` 给出，列表中的每个字符串长度为 3，格式为 `"XYZ"`。该规则表示：如果底部相邻的两个积木颜色分别为 `X`（左）和 `Y`（右），则可以在它们正上方放置一个颜色为 `Z` 的积木。注意，规则是有序的，即 `"XYZ"` 与 `"YXZ"` 代表不同的左右组合。

你从最底层开始搭建，最底层由字符串 `bottom` 给出，表示从左到右的积木颜色序列。你需要判断：在给定的规则列表 `allowed` 下，能否从最底层开始，逐层向上构建，直到金字塔顶部（即只剩一个积木），并且每一层中任意相邻两个积木的上方积木颜色都符合 `allowed` 中的某条规则。

## **示例说明**

- **示例1**：底层 `bottom = "BCD"`，规则 `allowed = ["BCC","CDE","CEA","FFF"]`。可以依次构建：
    - 由 "B" 和 "C" 根据 "BCC" 得到上方 "C"，
    - 由 "C" 和 "D" 根据 "CDE" 得到上方 "E"，
    - 从而得到第二层 "CE"；
    - 再由 "C" 和 "E" 根据 "CEA" 得到上方 "A"，
    - 得到顶层 "A"。构建成功，返回 `true`。

![756_金字塔转换矩阵I](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/756_%E9%87%91%E5%AD%97%E5%A1%94%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5I.jpg)

- **示例2**：底层 `bottom = "AAAA"`，规则 `allowed = ["AAB","AAC","BCD","BBE","DEF"]`。无论怎样尝试，都无法构建到顶层，返回 `false`。

![756金字塔转换矩阵II](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/756%E9%87%91%E5%AD%97%E5%A1%94%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5II.jpg)

## **数据范围**

- `bottom` 的长度在 `2` 到 `6` 之间。
- `allowed` 的长度在 `0` 到 `216` 之间。
- 所有字符串中的字符来自集合 `{'A', 'B', 'C', 'D', 'E', 'F'}`。
- `allowed` 中的所有字符串都是唯一的。



# 二、解题思路



# 三、代码演示

## Java代码

```java
class Solution {
    public boolean pyramidTransition(String bottom, List<String> allowed) {
        List<Character>[][] groups = new ArrayList[6][6];
        for(List<Character>[] row : groups){
            //  Arrays.setAll 是 Java 8+ 的方法，对数组每个位置执行 lambda 表达式 _ -> new ArrayList<>()（_ 是占位符，表示忽略索引）。
            Arrays.setAll(row, _ -> new ArrayList<>());
        }
        for(String S : allowed){
            char[] s = S.toCharArray();
            groups[s[0] - 'A'][s[1] - 'A'].add(s[2]);
        }

        int n = bottom.length();
        char[][] pyramid =  new char[n][];
        for(int i = 0; i < n - 1; i++){
            pyramid[i] = new char[i + 1];
        }
        pyramid[n - 1] = bottom.toCharArray();

        return dfs(n - 2, 0, pyramid, groups);
    }

    private boolean dfs(int i, int j, char[][] pyramid, List<Character>[][] groups){
        if(i < 0){
            return true;
        }

        if(j ==  i + 1){
            return dfs(i - 1, 0, pyramid, groups);
        }

        for(char top : groups[pyramid[i + 1][j] - 'A'][pyramid[i + 1][j + 1] - 'A']){
            pyramid[i][j] = top;
            if(dfs(i, j + 1, pyramid, groups)){
                return true;
            }
        }
        return false;
    }
}
```



## Python代码



## C++代码

