本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[840. 矩阵中的幻方 - 力扣（LeetCode）](https://leetcode.cn/problems/magic-squares-in-grid/description/?envType=daily-question&envId=2025-12-30)

>标签：数组  |  哈希表  |  数学  |  矩阵

# 一、题目描述

## **问题概括**

给定一个 `row x col` 的整数矩阵 `grid`，矩阵中的元素可以是大于 9 的整数。你需要在其中找出所有大小为 `3 x 3` 的连续子矩阵，并判断其是否为一个 **幻方**。

一个 `3 x 3` 幻方的定义是：

1. **数字范围**：必须包含从 **1 到 9** 的 **所有不同整数**（即每个数字出现且仅出现一次）。
2. **和相等**：该子矩阵的**每一行、每一列以及两条主对角线**上的三个数字之和必须**完全相等**。

你需要计算并返回 `grid` 中满足上述条件的 `3 x 3` 幻方子矩阵的**总数量**。 

## **示例说明**

- **示例1**：给定的 `grid` 中，经过检查，**只存在一个** `3 x 3` 的子矩阵满足幻方的所有条件，因此输出为 `1`。

    ```
    输入: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]
    输出: 1
    ```

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/15_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/840_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%BB%E6%96%B9_%E7%A4%BA%E4%BE%8B1.jpg)

- **示例2**：矩阵太小，无法构成任何 `3 x 3` 子矩阵，因此输出为 `0`。

    ```
    输入: grid = [[8]]
    输出: 0
    ```

## **数据范围**

- 矩阵的行数 `row` 和列数 `col` 均在 `1` 到 `10` 之间。
- 矩阵中的每个元素值在 `0` 到 `15` 之间。



# 二、解题思路/解题过程



# 三、代码演示

## Java代码

```java
class Solution {
    public int numMagicSquaresInside(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int ans = 0;

        // 遍历所有可能的 3x3 子矩阵左上角
        for (int i = 0; i < m - 2; i++) {
            for (int j = 0; j < n - 2; j++) {
                // 优化：幻方中心必须是 5
                if (grid[i + 1][j + 1] != 5) {
                    continue;
                }

                // 检查是否包含 1~9 且不重复
                boolean valid = true;
                boolean[] seen = new boolean[10]; // seen[0] ~ seen[9]，我们只关心 1~9

                int[] rowSum = new int[3];
                int[] colSum = new int[3];

                for (int r = 0; r < 3; r++) {
                    for (int c = 0; c < 3; c++) {
                        int num = grid[i + r][j + c];

                        // 如果数字不在 1~9 范围内，直接无效
                        if (num < 1 || num > 9) {
                            valid = false;
                            break;
                        }

                        // 如果这个数字已经出现过，也无效
                        if (seen[num]) {
                            valid = false;
                            break;
                        }
                        seen[num] = true;

                        rowSum[r] += num;
                        colSum[c] += num;
                    }
                    if (!valid) break; // 提前退出外层循环
                }

                // 如果数字检查失败，跳过
                if (!valid) {
                    continue;
                }

                // 检查前两行和前两列是否为 15（第三行/列自动满足）
                if (rowSum[0] == 15 && rowSum[1] == 15 &&
                    colSum[0] == 15 && colSum[1] == 15) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
```



## Python代码



## C++代码



