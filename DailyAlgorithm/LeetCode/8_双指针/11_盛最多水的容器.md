[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/?envType=problem-list-v2&envId=greedy)

>标签：贪心  |  数组  |  双指针

# 一、题目描述

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![11_盛最多水的容器](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E5%8F%8C%E6%8C%87%E9%92%88/Images/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

 

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`



# 二、解题思路\解题过程

这道题还可以，之前做过一遍，在“贪心”标签的题库里面，可以使用“双指针”的方法来进行求解！思路如下：
这道题之所以可以使用“双指针”的方法，而且不用担心会遗漏掉某些情况，原因如下：
我们使用两个指针分别指向数组的首末两个位置，指向首的为“left”，指向未的为“right”，然后计算这两个指针的之间的长度，然后在乘以这个两个指针指向的其中较小的值，即可以得到目前两个指针能得到的水的水量！此时，指针之间的长度已经是最长的了，如果还想容器中的容量增加，那么只能移动指针，而不管怎么移、移动哪一个指针，指针之间的长度就不会再增加，那么就需要去增加“水”的高度，才有可能增加容器中的容量，那么就只能移动原先两个指针中较小的值的那个指针了，只有这样容器的容量才可能增加，这样就不用担心遗漏掉情况了！直到当两个指针相遇的时候就可以跳出循环了！（两个指针相遇之后就没必要继续遍历下去了，因为会和以前的遍历重复！）
代码如下：

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, flag = 0;
        while(left < right){
            int cnn = (right - left) * (height[left] < height[right] ? height[left] : height[right]);
            flag = flag > cnn ? flag : cnn;
            if(height[right] > height[left]){
                left++;
            } else {
                right--;
            }
        }
        return flag;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, flag = 0;
        while(left < right){
            int cnn = (right - left) * (height[left] < height[right] ? height[left] : height[right]);
            flag = flag > cnn ? flag : cnn;
            if(height[right] > height[left]){
                left++;
            } else {
                right--;
            }
        }
        return flag;
    }
}
```



## Python代码



## C++代码



