本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[2841. 几乎唯一子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)

>标签：数组  |  哈希表  |  滑动窗口

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums` 以及两个正整数 `m` 和 `k`，其中 `m ≤ k`。你需要找出所有长度为 `k` 的连续子数组中，满足**至少包含 `m` 个互不相同元素**（即不同元素的种类数至少为 `m`）的那些子数组，并计算它们的元素总和。返回这些总和中的**最大值**；如果不存在这样的子数组，则返回 `0`。

## **示例核心说明**

- **示例1**：`nums = [2,6,7,3,1,7]`, `m = 3`, `k = 4`。有 3 个长度为 4 的子数组满足至少包含 3 个不同元素，其中和最大的是 `[2,6,7,3]`，和为 18。
- **示例2**：`nums = [5,9,9,2,4,5,4]`, `m = 1`, `k = 3`。共有 5 个满足条件的子数组，最大和为 `[5,9,9]` 的和 23。
- **示例3**：`nums = [1,2,1,2,1,2,1]`, `m = 3`, `k = 3`。不存在包含至少 3 个不同元素的长度为 3 的子数组，因此返回 0。

## **数据范围**

- 数组长度 `n` 满足 `1 ≤ n ≤ 2 × 10^4`。
- `1 ≤ m ≤ k ≤ n`。
- 数组中的每个元素满足 `1 ≤ nums[i] ≤ 10^9`。



# 二、解题思路\解题过程

这是今天的第二道“滑动窗口”类的题目，这道题和以前做的“滑动窗口”类的题目不一样的地方在于——这道题目需要计算窗口内的不同元素的个数，这就需要用到对应的集合来进行处理就好了，基本的解题思路和思想都是按照灵神总结的那三步来的，至于那三步的顺序就得按照题目来进行调整了，期间还可能有其他的题目要求，只要一步步满足就好了，具体代码如下：

```cpp
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long result = 0, count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            count += nums[i];
            freq[nums[i]]++;

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums[i - k];
                count -= leftNum;
                freq[leftNum]--;
                if (freq[leftNum] == 0) {
                    // 只有计数为 0 才移除
                    freq.erase(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public long maxSum(List<Integer> nums, int m, int k) {
        long result = 0, count = 0;
        int n = nums.size();
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            int rightNum = nums.get(i);
            count += rightNum;
            freq.put(rightNum, freq.getOrDefault(rightNum, 0) + 1);

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums.get(i - k);
                count -= leftNum;
                freq.put(leftNum, freq.get(leftNum) - 1);
                if (freq.get(leftNum) == 0) {
                    // 只有计数为 0 才移除
                    freq.remove(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = Math.max(result, count);
                }
            }
        }
        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        max_sum, window_sum, n = 0, 0, len(nums)
        freq = defaultdict(int)

        for i in range(n):
            # 右端点进入窗口
            window_sum += nums[i]
            freq[nums[i]] += 1

            # 如果窗口超过 k，收缩左边界
            if i >= k :
                left_num = nums[i - k]
                window_sum -= left_num
                freq[left_num] -= 1
                if freq[left_num] == 0 :
                    freq.pop(left_num)

            # 更新答案，当前窗口长度为 k
            if i >= k - 1 :
                if len(freq) >= m :
                    max_sum = max(max_sum, window_sum)
        
        return max_sum
```



## C++代码

```C++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long result = 0, count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            count += nums[i];
            freq[nums[i]]++;

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums[i - k];
                count -= leftNum;
                freq[leftNum]--;
                if (freq[leftNum] == 0) {
                    // 只有计数为 0 才移除
                    freq.erase(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```

![2841_几乎唯一子数组的最大和_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2841_%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C_C++.png)