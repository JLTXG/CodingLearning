本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[2090. 半径为 k 的子数组平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/k-radius-subarray-averages/description/)

>标签：数组  |  滑动窗口

# 一、题目描述

## **问题概括**

给定一个长度为 `n` 的整数数组 `nums` 和一个非负整数 `k`。对于数组中的每个下标 `i`（从 0 开始），定义以其为中心的 **半径为 k 的子数组** 为索引范围在 `[i - k, i + k]` 内的所有元素（包含两端）。需要计算该子数组中所有元素的 **平均值**（使用整数除法，即截断小数部分），并将结果存入 `avgs[i]`。

然而，如果下标 `i` 的前面或后面不足 `k` 个元素（即 `i - k < 0` 或 `i + k >= n`），则无法构成完整的半径为 `k` 的子数组，此时 `avgs[i]` 应设为 `-1`。

你需要构建并返回数组 `avgs`。

## **示例说明**

- **示例1**：`nums = [7,4,3,9,1,8,5,2,6]`, `k = 3`。对于中心下标 0、1、2，左侧元素不足 k 个，因此对应 `avgs` 为 `-1`；对于中心下标 3、4、5，可以计算半径为 3 的子数组平均值，分别为 5、4、4；对于下标 6、7、8，右侧元素不足 k 个，因此为 `-1`。最终输出 `[-1,-1,-1,5,4,4,-1,-1,-1]`。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2090_%E5%8D%8A%E5%BE%84%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC_%E7%A4%BA%E4%BE%8B1.png)

- **示例2**：`nums = [100000]`, `k = 0`。半径为 0 的子数组只包含该元素本身，平均值为 100000，输出 `[100000]`。

- **示例3**：`nums = [8]`, `k = 100000`。中心下标 0 前后不足 k 个元素，因此输出 `[-1]`。

## **数据范围**

- `n == nums.length`
- `1 <= n <= 10^5`
- `0 <= nums[i], k <= 10^5`



# 二、解题思路\解题过程

这也是一道`滑动窗口`类的题目，也可以采用灵神总结的框架方法，不过需要注意的是，这次的`i`下标指向的值是整个窗口的中心，所以，这次关注的不仅仅只有左端点，还有下标`i`中心到右端点这部分的数值，我采用的方法就是，再加一个循环——把`i 到 i + k（不包括i，但包括 i + k）`这部分的数值临时加了起来，这样就和之前做的题目差不多了，但是，只通过了39个测试样例，还差最后1个测试样例没有跑通，然后我在IDEA中写了一个测试代码，准备把最后一个样例跑出来看看最终的结果，结果代码太长了，跑不通！具体代码如下：

```java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length, flag = 0;
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            // 入
            flag += nums[i];

            // 更新答案
            int left = i - k, rigth = i + k;
            if (left < 0 || rigth >= n) {
                arr[i] = -1;
                continue;
            }
            int tmp = 0;
            for (int j = i + 1; j <= i + k; j++) {
                tmp += nums[j];
            }
            arr[i] = (flag + tmp) / (2 * k + 1);

            // 出
            flag -= nums[left];
        }
        return arr;
    }
}
```

后面我把我的代码给`AI`分析了一下，`AI`得出的结论是：
- 时间复杂度过高：内层循环导致`~4e9`操作，超时
- 整数溢出：`int`无法存下`8e9`的和，结果错误
- 滑动窗口逻辑错误：没有真正实现滑动，而是暴力重算

解决方案：改用标准`O(n)`滑动窗口 + `long`累加和。

代码如下：

```cpp
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(), windowSize = 2 * k + 1;
        long long windowSum = 0;  // 用 long 防溢出
        vector<int> arr(n, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = static_cast<int> (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = static_cast<int> (windowSum / windowSize);
        }
        return arr;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length, windowSize = 2 * k + 1;
        long windowSum = 0;  // 用 long 防溢出
        int[] arr = new int[n];
        Arrays.fill(arr, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = (int) (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = (int) (windowSum / windowSize);
        }
        return arr;
    }
}
```



## Python代码

```Python
class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n, window_size, window_sum = len(nums), 2 * k + 1, 0
        arr = [-1] * n

        if k == 0 :
            # 边界
            return nums
        if window_size > n :
            # 窗口太大
            return arr

        for i in range(window_size):
            window_sum += nums[i]
        arr[k] = window_sum // window_size

        for i in range(k + 1, n - k):
            window_sum = window_sum - nums[i - k - 1] + nums[i + k]
            arr[i] = window_sum // window_size
        
        return arr
```



## C++代码

```C++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(), windowSize = 2 * k + 1;
        long long windowSum = 0;  // 用 long 防溢出
        vector<int> arr(n, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = static_cast<int> (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = static_cast<int> (windowSum / windowSize);
        }
        return arr;
    }
};
```

![2090_半径为 k 的子数组平均值_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2090_%E5%8D%8A%E5%BE%84%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC_C++.png)