本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1456. 定长子串中元音的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

>标签：字符串  |  滑动窗口

# 一、题目描述

## **问题概括**

给定一个由小写英文字母组成的字符串 `s` 和一个正整数 `k`。你需要找出所有长度为 `k` 的连续子串中，包含元音字母（`a`, `e`, `i`, `o`, `u`）的最大数量。

## **示例说明**

- **示例1**：`s = "abciiidef"`, `k = 3`。子串 `"iii"` 包含 3 个元音字母，这是最大值。
- **示例2**：`s = "aeiou"`, `k = 2`。任意长度为 2 的子串都包含 2 个元音字母。
- **示例3**：`s = "leetcode"`, `k = 3`。多个子串包含 2 个元音字母，最大值为 2。
- **示例4**：`s = "rhythms"`, `k = 4`。字符串中没有元音字母，因此最大值为 0。
- **示例5**：`s = "tryhard"`, `k = 4`。存在包含 1 个元音字母的子串，最大值为 1。

## **数据范围**

- `1 <= s.length <= 10^5`
- `s` 由小写英文字母组成。
- `1 <= k <= s.length`



# 二、解题思路\解题过程

这道题是灵神提供的题单——[分享丨【算法题单】滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环） - 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/)——中的第一题，对于这道题我主要是采用学习的态度来写的，以下思路内容皆转载至[1456. 定长子串中元音的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/2809359/tao-lu-jiao-ni-jie-jue-ding-chang-hua-ch-fzfo/)，具体内容如下：

## 核心思想

对于下图的字符串 `abci`，假如我们已经计算出了子串 `abc` 的元音个数，那么从子串 `abc` 到子串 `bci`，只需要考虑移除（离开窗口）的字母 `a` 是不是元音，以及添加（进入窗口）的字母 `i` 是不是元音即可，因为中间的字母 `b` 和 `c` 都在这两个子串中。

![1456_定长子串中元音的最大数目_核心思想图解](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/1456_%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE_%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%9B%BE%E8%A7%A3.png)

## 示例

示例 1，s=`abciiidef`, k=3。

从左到右遍历 s。

首先统计前 k−1=2 个字母的元音个数，这有 1 个。
1. `s[2]=c` 进入窗口，此时找到了第一个长为 k 的子串 `abc`，现在元音个数有 1 个，更新答案最大值。然后 `s[0]=a` 离开窗口，现在元音个数有 0 个。
2. `s[3]=i` 进入窗口，此时找到了第二个长为 k 的子串 `bci`，现在元音个数有 1 个，更新答案最大值。然后 `s[1]=b` 离开窗口，现在元音个数有 1 个。
3. `s[4]=i` 进入窗口，此时找到了第三个长为 k 的子串 `cii`，现在元音个数有 2 个，更新答案最大值。然后 `s[2]=c` 离开窗口，现在元音个数有 2 个。
4. `s[5]=i` 进入窗口，此时找到了第四个长为 k 的子串 `iii`，现在元音个数有 3 个，更新答案最大值。然后 `s[3]=i` 离开窗口，现在元音个数有 2 个。
5. `s[6]=d` 进入窗口，此时找到了第五个长为 k 的子串 `iid`，现在元音个数有 2 个，更新答案最大值。然后 `s[4]=i` 离开窗口，现在元音个数有 1 个。
6. `s[7]=e` 进入窗口，此时找到了第六个长为 k 的子串 `ide`，现在元音个数有 2 个，更新答案最大值。然后 `s[5]=i` 离开窗口，现在元音个数有 1 个。
7. `s[8]=f` 进入窗口，此时找到了第七个长为 k 的子串 `def`，现在元音个数有 1 个，更新答案最大值。遍历结束。

## 定长滑窗套路（经典）

窗口右端点在`i`时，由于窗口长度为`k`，所以窗口在左端点为`i - k + 1`。

一共有三步：**入——更新——出**。

1. **入**：下标为`i`的元素进入窗口，更新相关统计量。如果窗口左端点`i - k + 1 < 0`，则尚未形成第一个窗口，重复第一步。
2. **更新**：更新答案。一般是更新最大值/最小值。
3. **出**：下标为`i - k + 1`的元素离开窗口，更新相关统计量，为下一个循环做准备。

以上三步适用于所有定长滑窗题目。



# 三、代码演示

## Java代码

```Java
class Solution {
    public int maxVowels(String s, int k) {
        char[] str = s.toCharArray();
        int result = 0, count = 0;
        for (int i = 0; i < str.length; i++) {
            // 右端点进入窗口
            if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') {
                count++;
            }

            // 左端点
            int left = i - k + 1;
            if (left < 0) {
                // 说明左端点还没有移动到字符串中
                continue;
            }

            // 更新答案
            result = result > count ? result : count;

            // 左端点离开滑动窗口
            char outStr = str[left];
            if (outStr == 'a' || outStr == 'e' || outStr == 'i' || outStr == 'o' || outStr == 'u') {
                count--;
            }
        }
        return result;
    }
}
```

![1456_定长子串中元音的最大数目_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/1456_%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE_Java.png)

## Python代码

```Python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        result, count, n = 0, 0, len(s)
        for i in range(n):
            # 入
            # 右端点进入窗口
            if s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or s[i] == 'o' or s[i] == 'u' :
                count += 1
            
            # 左端点
            left = i - k + 1
            if left < 0 :
                # 此时，左端点还没有进入窗口，先跳出此次循环
                continue
            
            # 更新答案
            result = result if result > count else count

            # 出
            # 左端点离开窗口
            if s[left] == 'a' or s[left] == 'e' or s[left] == 'i' or s[left] == 'o' or s[left] == 'u' :
                count -= 1
        
        return result
```



## C++代码

```C++
class Solution {
public:
    int maxVowels(string s, int k) {
        int result = 0, count = 0;
        for (int i = 0; i < s.size(); i++) {
            // 右端点进入窗口
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                count++;
            }

            // 左端点
            int left = i - k + 1;
            if (left < 0) {
                // 说明左端点还没有移动到字符串中
                continue;
            }

            // 更新答案
            result = result > count ? result : count;

            // 左端点离开滑动窗口
            char outStr = s[left];
            if (outStr == 'a' || outStr == 'e' || outStr == 'i' || outStr == 'o' || outStr == 'u') {
                count--;
            }
        }
        return result;
    }
};
```

