本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/)

>标签：数组  |  滑动窗口

# 一、题目描述

## **问题概括**

给定一个整数数组 `arr` 以及两个正整数 `k` 和 `threshold`。你需要统计所有长度为 `k` 的连续子数组中，平均值不小于 `threshold` 的子数组个数。

注意：平均值计算为子数组元素之和除以 `k`，不需要是整数。

## **示例说明**

- **示例1**：`arr = [2,2,2,2,5,5,5,8]`, `k = 3`, `threshold = 4`。有三个符合条件的子数组：`[2,5,5]`（平均值4）、`[5,5,5]`（平均值5）和 `[5,5,8]`（平均值6），因此输出 `3`。
- **示例2**：`arr = [11,13,17,23,29,31,7,5,2,3]`, `k = 3`, `threshold = 5`。前6个长度为3的子数组平均值都大于5，因此输出 `6`。

## **数据范围**

- `1 <= arr.length <= 10^5`
- `1 <= arr[i] <= 10^4`
- `1 <= k <= arr.length`
- `0 <= threshold <= 10^4`



# 二、解题思路\解题过程

今天又是一道`滑到窗口`类的题目，题目依旧采用灵神提供的框架，具体如下：

窗口右端点在`i`时，由于窗口长度为`k`，所以窗口在左端点为`i - k + 1`。

一共有三步：**入——更新——出**。

1. **入**：下标为`i`的元素进入窗口，更新相关统计量。如果窗口在左端点`i - k + 1 < 0`，则尚未形成第一个窗口，重复第一步。
2. **更新**：更新答案。一般是更新最大值/最小值。
3. **出**：下标为`i - k + 1`的元素离开窗口，更新相关统计量，为下一个循环做准备。

以上三步适用于所有定长滑窗题目。



# 三、代码演示

## Java代码

```Java
class Solution {
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        int count = 0, average = 0, sum = 0, n = arr.length;
        for (int i = 0; i < n; i++) {
            // 入
            // 右端点进入窗口
            sum += arr[i];

            // 更新答案
            int left = i - k + 1;
            if (left < 0) {
                // 左端点还未进入窗口，直接跳过本次循环
                continue;
            }
            average = sum / k;

            if (average >= threshold) {
                count++;
            }

            // 出
            sum -= arr[left];
        }
        return count;
    }
}
```



## Python代码

```Python
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        count, average, flag, n = 0, 0, 0, len(arr)
        for i in range(n):
            # 入
            # 右端点进入窗口
            flag += arr[i]

            # 更新答案
            left = i - k + 1
            if left < 0 :
                # 说明此时左端点还没有进入窗口，直接跳出本次循环——continue
                continue
            average = flag / k
            if average >= threshold :
                count += 1
            
            # 出
            flag -= arr[left]
        return count
```



## C++代码

```C++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int count = 0, average = 0, sum = 0, n = arr.size();
        for (int i = 0; i < n; i++) {
            // 入
            // 右端点进入窗口
            sum += arr[i];

            // 更新答案
            int left = i - k + 1;
            if (left < 0) {
                // 左端点还未进入窗口，直接跳过本次循环
                continue;
            }
            average = sum / k;

            if (average >= threshold) {
                count++;
            }

            // 出
            sum -= arr[left];
        }
        return count;
    }
};
```

![1343_大小为 K 且平均值大于等于阈值的子数组数目_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/1343_%E5%A4%A7%E5%B0%8F%E4%B8%BA%20K%20%E4%B8%94%E5%B9%B3%E5%9D%87%E5%80%BC%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE_C++.png)