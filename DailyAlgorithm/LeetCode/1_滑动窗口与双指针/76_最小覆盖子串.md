本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：哈希表  |  字符串  |  滑动窗口

# 一、题目描述

## **问题概括**

给定两个字符串 `s` 和 `t`，长度分别为 `m` 和 `n`。请在 `s` 中找到一个长度最短的连续子串，使得该子串包含 `t` 中的每个字符（包括重复出现的字符，且次数不少于 `t` 中该字符的出现次数）。如果不存在这样的子串，则返回空字符串 `""`。题目保证若有解则唯一。

## **示例说明**

- **示例1**：`s = "ADOBECODEBANC"`, `t = "ABC"`，最短满足条件的子串是 `"BANC"`。
- **示例2**：`s = "a"`, `t = "a"`，整个字符串 `"a"` 即为所求。
- **示例3**：`s = "a"`, `t = "aa"`，没有子串包含两个 `'a'`，返回空字符串。

## **数据范围**

- `1 <= m, n <= 10^5`
- `s` 和 `t` 由英文字母组成

## **进阶要求**

能否设计时间复杂度为 `O(m + n)` 的算法？



# 二、解题思路\解题过程

## ✅ 题目回顾

> 给定字符串 `s` 和 `t`，找出 `s` 中**最短的连续子串**，使得该子串**包含 `t` 中所有字符（包括重复次数）**。若不存在，返回空字符串 `""`。

- 示例：
    `s = "ADOBECODEBANC"`, `t = "ABC"` → 输出 `"BANC"`

---

## ✅ 解题核心思想：滑动窗口 + 字符频次统计

### 🔑 核心策略：

使用 **双指针（left, right）维护一个滑动窗口**，动态扩展右边界，收缩左边界，在满足“覆盖 t”的前提下，不断寻找**最短有效窗口**。

### 🧠 关键点：

1. **用两个长度为 128 的数组 `cntT` 和 `cntS`** 分别记录 `t` 中每个字符的出现次数，以及当前窗口中每个字符的出现次数（ASCII 编码范围 0~127，英文字母都在其中）。
2. **窗口扩张**：`right` 指针不断右移，把新字符加入窗口。
3. **窗口收缩**：一旦当前窗口**完全覆盖了 `t`**（即对每个字符 c，`cntS[c] >= cntT[c]`），就尝试**移动 `left` 指针缩小窗口**，直到不再满足覆盖条件。
4. **记录最优解**：在每次满足覆盖时，比较当前窗口长度，更新最短答案。

> ⏱️ 时间复杂度：O(m + n)，其中 m = len(s), n = len(t)  
> （虽然 `isCovered` 看似 O(52)，但常数很小，可视为 O(1)）

---

## ✅ 优化建议（进阶思考）

代码逻辑正确，但 `isCovered` 函数每次都要遍历 52 个字母，其实可以进一步优化：

### 🔁 优化方向：**用一个变量记录“还需覆盖的字符种类数”**

- 初始化 `need = 不同字符的数量`
- 当某个字符 `c` 的 `cntS[c] == cntT[c]` 时，`need--`
- 当 `need == 0` 时，说明已覆盖
- 这样 `isCovered` 就变成 O(1) 判断

> 这是官方题解常用技巧，能真正达到 **严格 O(m + n)**。

---

## ✅ 总结

| 要点           | 说明                                      |
| -------------- | ----------------------------------------- |
| **算法类型**   | 滑动窗口（Sliding Window）                |
| **数据结构**   | 两个长度为 128 的整型数组（模拟哈希表）   |
| **窗口扩张**   | `right++`，加入新字符                     |
| **窗口收缩**   | 当覆盖 `t` 时，`left++`，尝试缩小         |
| **覆盖判断**   | 对所有英文字母，检查 `cntS[c] >= cntT[c]` |
| **答案更新**   | 在满足覆盖时，记录最短 `[left, right]`    |
| **时间复杂度** | O(m × 52) ≈ O(m)，可接受                  |

---

# 三、代码演示

## Java代码

```Java
class Solution {
    public String minWindow(String s, String t) {
        // cntS：记录当前滑动窗口中每个字符的出现次数（ASCII 0~127）
        // cntT：记录目标字符串 t 中每个字符的出现次数
        int[] cntS = new int[128];
        int[] cntT = new int[128];

        // 初始化 cntT：遍历 t，统计每个字符需要多少个
        for (char c : t.toCharArray()) {
            cntT[c]++;
        }

        char[] sChar = s.toCharArray();  // 转为字符数组，提高访问效率
        int m = sChar.length;

        // ansLeft 和 ansRight 用于记录最短有效窗口的左右边界
        // 初始 ansRight = m（表示无效长度），ansLeft = -1（未找到）
        int ansLeft = -1, ansRight = m;
        int left = 0;  // 滑动窗口左指针

        // 右指针遍历整个字符串 s
        for (int right = 0; right < m; right++) {
            // 将 sChar[right] 加入当前窗口
            cntS[sChar[right]]++;

            // 当前窗口是否已经“覆盖”了 t？如果是，尝试收缩左边界
            while (isCovered(cntS, cntT)) {
                // 如果当前窗口 [left, right] 比之前记录的更短，就更新答案
                if (right - left < ansRight - ansLeft) {
                    ansLeft = left;
                    ansRight = right;
                }

                // 尝试收缩左边界：移除 s[left]，然后 left++
                cntS[sChar[left]]--;
                left++;
            }
        }

        // 如果 ansLeft 仍是 -1，说明没找到有效窗口，返回空串
        return ansLeft < 0 ? "" : s.substring(ansLeft, ansRight + 1);
    }

    /**
     * 辅助函数：判断当前窗口 cntS 是否完全覆盖了目标字符串 t（即 cntT）
     * 覆盖条件：对于所有英文字母（大小写），cntS[c] >= cntT[c]
     */
    private boolean isCovered(int[] cntS, int[] cntT) {
        // 检查大写字母 'A' ~ 'Z'
        for (int i = 'A'; i <= 'Z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }

        // 检查小写字母 'a' ~ 'z'
        for (int i = 'a'; i <= 'z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }

        return true;  // 所有字符都满足，说明已覆盖
    }
}
```

![76_最小覆盖子串_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/1_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/76_%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_Java.png)

## Python代码

```Python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        # 使用长度为 128 的列表模拟 ASCII 字符频次表（0~127）
        cntS = [0] * 128  # 当前窗口中各字符的出现次数
        cntT = [0] * 128  # 目标字符串 t 中各字符的出现次数

        # 统计 t 中每个字符的出现次数
        for c in t:
            cntT[ord(c)] += 1

        m = len(s)
        ans_left = -1      # 最优窗口左边界
        ans_right = m      # 最优窗口右边界（初始设为无效大值）
        left = 0           # 滑动窗口左指针

        # 右指针遍历整个字符串 s
        for right in range(m):
            # 将 s[right] 加入当前窗口
            cntS[ord(s[right])] += 1

            # 当前窗口是否已覆盖 t？如果是，尝试收缩左边界
            while self.is_covered(cntS, cntT):
                # 如果当前窗口更短，更新答案
                if right - left < ans_right - ans_left:
                    ans_left = left
                    ans_right = right

                # 收缩左边界：移除 s[left]
                cntS[ord(s[left])] -= 1
                left += 1

        # 若未找到有效窗口，返回空串；否则返回子串
        return "" if ans_left == -1 else s[ans_left:ans_right + 1]

    def is_covered(self, cntS: list, cntT: list) -> bool:
        """
        判断当前窗口 cntS 是否完全覆盖目标字符串 t（即 cntT）
        覆盖条件：对所有 ASCII 字符 c，cntS[c] >= cntT[c]
        """
        # 遍历全部 128 个 ASCII 字符（确保兼容数字、符号等）
        for i in range(128):
            if cntS[i] < cntT[i]:
                return False
        return True
```



## C++代码

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> cntS(128);
        vector<int> cntT(128);

        for (auto c : t) {
            cntT[c]++;
        }

        int m = s.size();
        int ansLeft = -1, ansRight = m;
        int left = 0;

        for (int right = 0; right < m; right++) {
            cntS[s[right]]++;

            while (isCovered(cntS, cntT)) {
                if (right - left < ansRight - ansLeft) {
                    ansLeft = left;
                    ansRight = right;
                }
                
                cntS[s[left]]--;
                left++;
            }
        }

        return ansLeft < 0 ? "" : s.substr(ansLeft, ansRight - ansLeft + 1);
    }

private:
    bool isCovered(vector<int>& cntS, vector<int>& cntT) {
        for (int i = 'A'; i <= 'Z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }

        for (int i = 'a'; i <= 'z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }

        return true;
    }
};
```

