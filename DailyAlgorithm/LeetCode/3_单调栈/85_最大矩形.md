本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[85. 最大矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-rectangle/description/?envType=daily-question&envId=2026-01-11)

>标签：栈  |  数组  |  动态规划  |  矩阵  |  单调栈

# 一、题目描述

## **问题概括**

给定一个仅包含字符 `'0'` 和 `'1'` 的二维二进制矩阵，找出其中全部由 `'1'` 组成的最大矩形（即矩形区域内所有元素均为 `'1'`），并返回其面积。如果不存在这样的矩形，则返回 `0`。

## **示例说明**

- **示例1**：一个4行5列的矩阵中，最大矩形面积为6。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/85_%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2_%E7%A4%BA%E4%BE%8B1.png)

    ```
    输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
    输出：6
    解释：最大矩形如上图所示。
    ```

- **示例2**：矩阵 `[["0"]]` 中没有由 `'1'` 组成的矩形，面积为0。

- **示例3**：矩阵 `[["1"]]` 中最大矩形就是其本身，面积为1。

## **数据范围**

- 矩阵的行数 `rows` 和列数 `cols` 均在 `1` 到 `200` 之间。
- 矩阵中的每个元素为 `'0'` 或 `'1'`。



# 二、解题思路\解题过程

这道题是今日的“每日一题”，这道题其实和[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)这道题是类似的，力扣第84题就是只有一行矩阵图，而对于力扣第85题，题目给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，我们可以将其看成题目给了`rows`行矩阵图，我们可以参考灵神的思路——转载——[85. 最大矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-rectangle/solutions/3704011/zhi-jie-diao-yong-84-ti-dai-ma-jie-jue-p-49at/?envType=daily-question&envId=2026-01-11)，具体转载思路如下：

回顾一下，这是[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)的图：

![84_柱状图中最大的矩形_示例1](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/84_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E7%A4%BA%E4%BE%8B1.jpg)

对于本题，设`matrix`有`m`行，我们可以枚举矩形的底边，做`m`次 84 题。

- 以第一行为底的柱子高度为 [1,0,1,0,0]，最大矩形面积为 1。
- 以第二行为底的柱子高度为 [2,0,2,1,1]，最大矩形面积为 3。
- 以第三行为底的柱子高度为 [3,1,3,2,2]，最大矩形面积为 6。
- 以第四行为底的柱子高度为 [4,0,0,3,0]，最大矩形面积为 4。
- 答案为 max(1,3,6,4)=6。

由于我们枚举的是矩形的底边，如果 `matrix[i][j]=0`，那么没有柱子，高度等于 0。否则，在上一行柱子的基础上，把柱子高度增加 1。形象地说，就是在柱子下面垫一块石头，把柱子抬高。

代码如下：
```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix[0].length;
        int[] heights = new int[n + 1];
        int answer = 0;
        for (char[] row : matrix) {
            for (int j = 0; j < n; j++) {
                if (row[j] == '0') {
                    heights[j] = 0;
                } else {
                    heights[j]++;
                }
            }
            // 调用 84. 柱状图中最大的矩形 中的代码
            answer = Math.max(answer, largestRectangleArea(heights));
        }
        return answer;
    }

    // 84. 柱状图中最大的矩形
    private int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] flag = new int[n];
        int top = -1;
        flag[++top] = -1;
        int answer = 0;
        for (int right = 0; right < n; right++) {
            int h = heights[right];
            while (top > 0 && heights[flag[top]] >= h) {
                int i = flag[top--];
                int left = flag[top];
                answer = Math.max(answer, heights[i] * (right - left - 1));
            }
            flag[++top] = right;
        }
        return answer;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix[0].length;
        int[] heights = new int[n + 1];
        int answer = 0;
        for (char[] row : matrix) {
            for (int j = 0; j < n; j++) {
                if (row[j] == '0') {
                    heights[j] = 0;
                } else {
                    heights[j]++;
                }
            }
            // 调用 84. 柱状图中最大的矩形 中的代码
            answer = Math.max(answer, largestRectangleArea(heights));
        }
        return answer;
    }

    // 84. 柱状图中最大的矩形
    private int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] flag = new int[n];
        int top = -1;
        flag[++top] = -1;
        int answer = 0;
        for (int right = 0; right < n; right++) {
            int h = heights[right];
            while (top > 0 && heights[flag[top]] >= h) {
                int i = flag[top--];
                int left = flag[top];
                answer = Math.max(answer, heights[i] * (right - left - 1));
            }
            flag[++top] = right;
        }
        return answer;
    }
}
```

![85_最大矩形_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/85_%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2_Java.png)

## Python代码

```Python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        n = len(matrix[0])
        # 多一位哨兵（末尾0）
        heights = [0] * (n + 1)
        answer = 0

        for row in matrix:
            for j in range(n):
                if row[j] == '0':
                    heights[j] = 0
                else:
                    heights[j] += 1
            answer = max(answer, self.largestRectangleArea(heights))
        return answer
    
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        # 栈，初始放入哨兵 -1
        flag = [-1]
        answer = 0

        for right in range(n):
            h = heights[right]
            # 维护单调递增栈（非递减）
            while len(flag) > 1 and heights[flag[-1]] >= h:
                i = flag.pop()
                left = flag[-1]
                answer = max(answer, heights[i] * (right - left - 1))
            flag.append(right)
        return answer
```



## C++代码

```C++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return 0;
        int n = matrix[0].size();
        vector<int> heights(n + 1, 0); // 多一位用于哨兵
        int answer = 0;

        for(const auto& row : matrix){
            for(int j = 0; j < n; j++){
                if(row[j] == '0'){
                    heights[j] = 0;
                } else {
                    heights[j]++;
                }
            }
            answer = max(answer, largestRectangleArea(heights));
        }
        return answer;
    }

private:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> flag(n); // 模拟栈，存下标
        int top = -1;
        flag[++top] = -1; // 哨兵：左边界
        int answer = 0;

        for (int right = 0; right < n; right++) {
            int h = heights[right];
            // 维护单调递增栈（严格来说是非递减）
            while (top > 0 && heights[flag[top]] >= h) {
                // 弹出栈顶
                int i = flag[top--];
                // 新栈顶是左边界
                int left = flag[top];
                answer = max(answer, heights[i] * (right - left - 1));
            }
            flag[++top] = right;
        }
        return answer;
    }
};
```

