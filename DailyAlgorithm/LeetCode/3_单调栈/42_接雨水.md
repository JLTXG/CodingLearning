本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：栈  |  数组  |  双指针  |  动态规划  |  单调栈

# 一、题目描述

## **问题概括**

给定一个非负整数数组 `height`，其中的每个元素表示一个柱子的高度。这些柱子宽度为 1，按照数组顺序紧密排列。请计算在这种排列下，柱子之间能够存留的雨水总量。

## **示例说明**

- **示例1**：输入 `height = [0,1,0,2,1,0,1,3,2,1,2,1]`，可以存留 6 个单位的雨水。

![42_接雨水_示例1]()

- **示例2**：输入 `height = [4,2,0,3,2,5]`，可以存留 9 个单位的雨水。

## **数据范围**

- 数组长度 `n` 满足 `1 <= n <= 2 * 10^4`
- 每个柱子的高度满足 `0 <= height[i] <= 10^5`



# 二、解题思路\解题过程

这道题目可以采用三种方法来进行求解，具体文字描述思路参考灵神题解——[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/solutions/1974340/zuo-liao-nbian-huan-bu-hui-yi-ge-shi-pin-ukwm/?envType=study-plan-v2&envId=top-100-liked)，我目前对于“前后缀分解”和“相向双指针”这两种解法比较熟悉，至于第三种“单调栈”目前能写出来这道题目，但是这种方法我还不是很熟！

# 三、代码演示

## Java代码

```Java
// 前后缀分解
class Solution {
    public int trap(int[] height) {
        // 前后缀分解
        int n = height.length, result = 0;

        // 前缀
        int[] pre_max = new int[n];
        pre_max[0] = height[0];
        for (int i = 1; i < n; i++) {
            pre_max[i] = Math.max(pre_max[i - 1], height[i]);
        }

        // 后缀
        int[] suf_max = new int[n];
        suf_max[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suf_max[i] = Math.max(suf_max[i + 1], height[i]);
        }

        for (int i = 0; i < n; i++) {
            result += Math.min(pre_max[i], suf_max[i]) - height[i];
        }
        return result;
    }
}

// 相向双指针
class Solution {
    public int trap(int[] height) {
        // 双指针
        int result = 0, n = height.length;
        int left = 0, right = n - 1;
        int preMax = 0, sufMax = 0;
        while (left <= right) {
            preMax = Math.max(preMax, height[left]);
            sufMax = Math.max(sufMax, height[right]);
            if (preMax < sufMax) {
                result += preMax - height[left];
                left++;
            } else {
                result += sufMax - height[right];
                right--;
            }
        }
        return result;
    }
}

// 单调栈
class Solution {
    public int trap(int[] height) {
        // 单调栈
        int result = 0;
        Deque<Integer> st = new ArrayDeque<>();
        for (int i = 0; i < height.length; i++) {
            int h = height[i];
            while (!st.isEmpty() && height[st.peek()] <= h) {
                int bottomH = height[st.pop()];
                if (st.isEmpty()) {
                    break;
                }
                int left = st.peek();
                // 面积的高
                int dh = Math.min(height[left], height[i]) - bottomH;
                result += dh * (i - left - 1);
            }
            st.push(i);
        }
        return result;
    }
}
```



## Python代码

```Python
# 前后缀分解
class Solution:
    def trap(self, height: List[int]) -> int:
        # 前后缀分解
        n, result = len(height), 0

        # 前缀
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i - 1], height[i])
        
        # 后缀
        suf_max = [0] * n
        suf_max[-1] = height[-1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i + 1], height[i])
        
        for h, pre, suf in zip(height, pre_max, suf_max):
            result += min(pre, suf) - h
        return result

# 相向双指针
class Solution:
    def trap(self, height: List[int]) -> int:
        # 双指针
        result, n = 0, len(height)
        left, right, pre_max, suf_max = 0, n - 1, 0, 0
        while left <= right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                result += pre_max - height[left]
                left += 1
            else:
                result += suf_max - height[right]
                right -= 1
        return result

# 单调栈
class Solution:
    def trap(self, height: List[int]) -> int:
        # 单调栈
        result, st = 0, []
        for i, h in enumerate(height):
            while st and height[st[-1]] <= h:
                bottom_h = height[st.pop()]
                # 栈是空的
                if not st:
                    break
                left = st[-1]
                # 面积的高
                dh = min(height[left], h) - bottom_h
                result += dh * (i - left - 1)
            st.append(i)
        return result
```



## C++代码

```C++
// 前后缀分解
class Solution {
public:
    int trap(vector<int>& height) {
        // 前后缀分解
        int n = height.size(), result = 0;

        // 前缀
        vector<int> preMax(n);
        preMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            preMax[i] = max(preMax[i - 1], height[i]);
        }

        // 后缀
        vector<int> sufMax(n);
        sufMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            sufMax[i] = max(sufMax[i + 1], height[i]);
        }

        for (int i = 0; i < n; i++) {
            result += min(preMax[i], sufMax[i]) - height[i];
        }
        return result;
    }
};

// 相向双指针
class Solution {
public:
    int trap(vector<int>& height) {
        // 双指针
        int result = 0, n = height.size();
        int left = 0, right = n - 1;
        int preMax = 0, sufMax = 0;
        while (left <= right) {
            preMax = max(preMax, height[left]);
            sufMax = max(sufMax, height[right]);
            if (preMax < sufMax) {
                result += preMax - height[left];
                left++;
            } else {
                result += sufMax - height[right];
                right--;
            }
        }
        return result;
    }
};

// 单调栈
class Solution {
public:
    int trap(vector<int>& height) {
        // 单调栈
        int result = 0;
        stack<int> st;
        for (int i = 0; i < height.size(); i++) {
            int h = height[i];
            while (!st.empty() && height[st.top()] <= h) {
                int bottom_h = height[st.top()];
                st.pop();
                if (st.empty()) {
                    break;
                }
                int left = st.top();
                // 面积的高
                int dh = min(height[left], height[i]) - bottom_h;
                result += dh * (i - left - 1);
            }
            st.push(i);
        }
        return result;
    }
};
```

![42_接雨水_C++]()