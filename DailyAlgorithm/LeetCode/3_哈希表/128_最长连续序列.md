本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：并查集  |  数组  |  哈希表

# 一、题目描述

## **问题概括**

给定一个未排序的整数数组 `nums`，请找出其中数字按数值连续的最长序列的长度。序列中的数字在原数组中不必连续出现。要求算法的时间复杂度为 O(n)。

## **示例说明**

- **示例1**：`nums = [100,4,200,1,3,2]`，最长连续序列是 `[1,2,3,4]`，长度为 4。
- **示例2**：`nums = [0,3,7,2,5,8,4,6,0,1]`，最长连续序列是 `[0,1,2,3,4,5,6,7,8]`，长度为 9。
- **示例3**：`nums = [1,0,1,2]`，最长连续序列是 `[0,1,2]`，长度为 3。

## **数据范围**

- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`



# 二、解题思路\解题过程

这是今天做的“LeetCode 热题 100”中的一道题目，如果单纯是把这道题目AC了，还是很简单的，就是把整个数组进行排序，然后循环去记录数组中数字连续的最长序列的长度即可！虽然后台测试没有设置禁止排序之类的限制，但是题目中的文字还是明确说了，需要设计时间复杂度为`O(n)`的算法，如果用了排序函数的话，时间复杂度为 O(n log*n*) 了，不符合题意，所以如果想要使时间复杂度达到题目的要求，我们可以采用哈希表来进行求解，这样即剔除了多余重复的元素，然后逐步循环探寻最长连续序列！上述两种方法的代码如下！

# 三、代码演示

## Java代码

```Java
// 排序
class Solution {
    public int longestConsecutive(int[] nums) {
        int n = nums.length, result = 1, tmp = 1;
        if (n == 0) {
            return 0;
        }
        Arrays.sort(nums);
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1] + 1) {
                tmp++;
                result = Math.max(result, tmp);
            } else if (nums[i] == nums[i - 1]) {
                continue;
            } else {
                tmp = 1;
            }
        }
        return result;
    }
}

// 哈希表写法
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        // 将数组中的元素加入集合set中，剔除重复元素
        for (int num : nums) {
            set.add(num);
        }
        int result = 0;
        for (int tmp : set) {
            if (set.contains(tmp - 1)) {
                // 此时说明当前的tmp不是连续序列的开端，所以跳过本次循环
                continue;
            }
            // 当前的tmp是连续序列的开端
            int flag = tmp + 1;
            // 持续判断下一个连续的数字在不在集合set中
            while (set.contains(flag)) {
                flag++;
            }
            // 此时已经跳出来 while 循环，说明此时的 flag 已经不在set集合中了，那么说明 flag - 1 这个数还在set集合中（而且还是最后一个），那么此时的连续序列的长度为—— (flag - 1) - tmp + 1 = flag - tmp
            result = Math.max(result, flag - tmp);
        }
        return result;
    }
}
```



## Python代码

```Python
# 排序
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        n, result, tmp = len(nums), 1, 1
        if n == 0:
            return 0
        nums.sort()
        for i in range(1, n):
            if nums[i] == nums[i - 1] + 1:
                tmp += 1
                result = max(result, tmp)
            elif nums[i] == nums[i - 1]:
                continue
            else:
                tmp = 1
        return result
    
# 哈希表写法
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 将数组中的值加入到arr集合中，并剔除重复元素
        arr = set(nums)
        result = 0
        # 注意：此时遍历的应该是集合arr！
        for tmp in arr:
            if tmp - 1 in arr:
                # 说明此时的tmp - 1不是其整个连续序列的开端，我们需要跳过本次循环
                continue
            # 说明此时的num[i]是其整个连续序列的开端
            flag = tmp + 1
            # 持续判断下一个数字是否在arr集合中
            while flag in arr:
                flag += 1
            # 此时说明当前的 flag 已经不在arr集合中了，同时，也说明 flag - 1 是已 tmp 为开端的连续序列的最后一个数了，所以，我们可以计算出当前连续序列的长度—— (flag - 1) - tmp + 1 = flag - tmp
            result = max(result, flag - tmp)
        return result
```

![128_最长连续序列_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/3_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/128_%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97_Python.png)

## C++代码

```C++
// 排序
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int n = nums.size(), result = 1, tmp = 1;
        if (n == 0) {
            return 0;
        }
        sort(nums.begin(), nums.end());
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1] + 1) {
                tmp++;
                result = max(result, tmp);
            } else if (nums[i] == nums[i - 1]) {
                continue;
            } else {
                tmp = 1;
            }
        }
        return result;
    }
};

// 哈希表写法
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        set<int> arr;
        // 将数组中的元素加入集合arr中，剔除重复元素
        for (auto num : nums) {
            arr.insert(num);
        }
        int result = 0;
        for (auto tmp : arr) {
            if (arr.find(tmp - 1) != arr.end()) {
                // 此时说明当前的tmp不是连续序列的开端，所以跳过本次循环
                continue;
            }
            // 当前的tmp是连续序列的开端
            int flag = tmp + 1;
            // 持续判断下一个连续的数字在不在集合set中
            while (arr.find(flag) != arr.end()) {
                flag++;
            }
            // 此时已经跳出来 while 循环，说明此时的 flag 已经不在arr集合中了，那么说明 flag - 1 这个数还在arr集合中（而且还是最后一个），那么此时的连续序列的长度为—— (flag - 1) - tmp + 1 = flag - tmp
            result = max(result, flag - tmp);
        }
        return result;
    }
};
```

