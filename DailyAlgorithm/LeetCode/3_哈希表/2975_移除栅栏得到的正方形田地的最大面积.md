[2975. 移除栅栏得到的正方形田地的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/description/?envType=daily-question&envId=2026-01-16)

>标签：数组  |  哈希表  |  枚举

# 一、题目描述

有一个大型的 `(m - 1) x (n - 1)` 矩形田地，其两个对角分别是 `(1, 1)` 和 `(m, n)` ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 `hFences` 和 `vFences` 给出。

水平栅栏为坐标 `(hFences[i], 1)` 到 `(hFences[i], n)`，垂直栅栏为坐标 `(1, vFences[i])` 到 `(m, vFences[i])` 。

返回通过 **移除** 一些栅栏（**可能不移除**）所能形成的最大面积的 **正方形** 田地的面积，或者如果无法形成正方形田地则返回 `-1`。

由于答案可能很大，所以请返回结果对 `109 + 7` **取余** 后的值。

**注意：**田地外围两个水平栅栏（坐标 `(1, 1)` 到 `(1, n)` 和坐标 `(m, 1)` 到 `(m, n)` ）以及两个垂直栅栏（坐标 `(1, 1)` 到 `(m, 1)` 和坐标 `(1, n)` 到 `(m, n)` ）所包围。这些栅栏 **不能** 被移除。

 

**示例 1：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/3_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/2975_%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF_%E7%A4%BA%E4%BE%8B1.png)

```
输入：m = 4, n = 3, hFences = [2,3], vFences = [2]
输出：4
解释：移除位于 2 的水平栅栏和位于 2 的垂直栅栏将得到一个面积为 4 的正方形田地。
```

**示例 2：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/3_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/2975_%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF_%E7%A4%BA%E4%BE%8B2.png)

```
输入：m = 6, n = 7, hFences = [2], vFences = [4]
输出：-1
解释：可以证明无法通过移除栅栏形成正方形田地。
```

 

**提示：**

- `3 <= m, n <= 10^9`
- `1 <= hFences.length, vFences.length <= 600`
- `1 < hFences[i] < m`
- `1 < vFences[i] < n`
- `hFences` 和 `vFences` 中的元素是唯一的。



# 二、解题思路\解题过程

## 解题过程

这道题是今天的“每日一题”，和昨天的“每日一题”——[2943. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/?envType=daily-question&envId=2026-01-16)——很类似（几乎可以说是昨天那道题目的一个进阶版本）！

昨天那道“每日一题”中的栅栏数都是从1开始，然后逐渐递增1，然而今天这道题目中的栅栏数是题目给的，也就是说题目给的栅栏数放在“栅栏”里面可能不连续，所以，我就把栅栏边框也一起加了进去，从而把题目给的两个数组进行了扩展得到了两个新的数组——包含栅栏边框，然后我就想通过排序，然后在计数得到每个新数组中连续的数值有多少个，然后求长宽的最小值，最后和`0`判断一下，如果`side == 0`，那么就说明无法构成正方形，就返回`-1`；否则，就将`side`平方然后在对`10 ^ 9 + 7`进行取余，最后在返回即可，代码如下：

```java
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        // 将栅栏对应的数据也加入进去，得到新数组
        int[] newHFences = new int[2 + hFences.length], newVFences = new int[2 + vFences.length];
        newHFences[0] = 1;
        newVFences[0] = 1;
        for(int i = 1; i < newHFences.length - 1; i++){
            newHFences[i] = hFences[i - 1];
        }
        newHFences[newHFences.length - 1] = m;
        for(int i = 1; i < newVFences.length - 1; i++){
            newVFences[i] = vFences[i - 1];
        }
        newVFences[newVFences.length - 1] = n;
        int side = Math.min(resort(newHFences), resort(newVFences));
        if(side == 0){
            return -1;
        }
        return side * side % 1000000007;
    }

    private int resort(int[] arr) {
        Arrays.sort(arr);
        int result = 0, count = 0;
        for(int i = 0; i < arr.length - 1; i++){
            if(arr[i] + 1 == arr[i + 1]){
                count++;
                result = result > count ? result : count;
            } else {
                count = 0;
            }
        }
        return result;
    }
}
```

上面的思路看着很清晰，但是，忽略了很多细节，如果题目给的数据不是连续的，但是恰恰可以构成正方形，那么我上述写的代码就错了！

然后，我就去看了灵神的题解——[2975. 移除栅栏得到的正方形田地的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/solutions/2577867/fen-bie-ji-suan-bao-li-mei-ju-by-endless-zxhr/?envType=daily-question&envId=2026-01-16)——灵神的很简单易懂，直接就是**暴力枚举**（以下思路皆转载至题解[2975. 移除栅栏得到的正方形田地的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/solutions/2577867/fen-bie-ji-suan-bao-li-mei-ju-by-endless-zxhr/?envType=daily-question&envId=2026-01-16)），具体思路如下：

水平栅栏和垂直栅栏需要分开计算：
- 对于水平栅栏，任意两个栅栏之间的距离（中间的栅栏全部删除）都可能是正方形的边长，存到一个哈希表`hSet`中。
- 对于垂直栅栏，任意两个栅栏之间的距离（中间的栅栏全部删除）都可能是正方形的边长，存到一个哈希表`uSet`中。

最后在对`hSet`和`uSet`交集中的最大值进行平方，然后在取模，即可返回最终答案，代码如下：

```java
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        final int MOD = 1_000_000_007;
        Set<Integer> hFSet = resort(hFences, m);
        Set<Integer> vFSet = resort(vFences, n);

        int result = 0;
        for (int flag : hFSet) {
            if (vFSet.contains(flag)) {
                result = result > flag ? result : flag;
            }
        }

        return result > 0 ? (int)((long) result * result % MOD) : -1;
    }

    private Set<Integer> resort(int[] arr, int y) {
        int n = arr.length;
        arr = Arrays.copyOf(arr, n + 2);
        arr[n++] = 1;
        arr[n++] = y;
        Arrays.sort(arr);

        // 计算 arr 中任意两个数的差(任意两个栅栏之间的距离都可能是正方形的边长)，保存到哈希集合中
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                set.add(arr[j] - arr[i]);
            }
        }
        return set;
    }
}
```
## 知识补充
### **1、哈希表**

哈希表是一种以平均O(1)时间复杂度实现插入、删除和查找的数据结构。它通过“哈希函数”将键（Key）映射到一个数组的索引位置，从而快速存取数据。

在Java中，最常用的哈希表实现有：
- `HashMap<K, V>`：存储键值对（key-value）
- `HashSet<E>`：只存储键（本质是`HashMap<E, Object>`的封装，值固定为一个占位对象）
#### 创建
```Java
Set<Integer> set = new HashSet<>();
```

#### 添加元素
```Java
set.add(5);  // 添加元素5
```
- 如果元素已存在，`add()`返回`false`，否则返回`true`。
- 自动去重。

#### 判断是否存在
```Java
if (set.contains(5)) {
	// 存在
}

//  时间复杂度：平均O(1)
```

#### 删除元素
```java
set.remove(5);
```

#### 遍历
```java
for (int x : set) {
	System.out.println(x);
}
```

#### contains用法
| 集合类型       | 方法签名                                                     | 含义说明                         |
| -------------- | ------------------------------------------------------------ | -------------------------------- |
| `HashSet<E>`   | `boolean contains(Object o)`                                 | 判断集合中是否包含某个元素（值） |
| `HashMap<K,V>` | `boolean containsKey(Object key)`  <br>`boolean containsValue(Object value)` | 分别判断是否包含某个键或某个值   |
### Arrays.copyOf方法
#### 基本用法
```java
public static <T> T[] copyOf(T[] original, int newLength)
```
- `original`：原始数组
- `newLength`：新数组的长度
- 返回：一个新数组，类型与原数组相同

#### 功能说明

- 如果`newLength > original.length`：扩容，多出的位置用默认值填充（如`0`、`null`、`false`）
- 如果`newLength < original.length`：截断，只保留前`newLength`个元素
- 如果相等：相当于浅拷贝一份新数组



# 三、代码演示

## Java代码

```Java
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
        final int MOD = 1_000_000_007;
        Set<Integer> hFSet = resort(hFences, m);
        Set<Integer> vFSet = resort(vFences, n);

        int result = 0;
        for (int flag : hFSet) {
            if (vFSet.contains(flag)) {
                result = result > flag ? result : flag;
            }
        }

        return result > 0 ? (int)((long) result * result % MOD) : -1;
    }

    private Set<Integer> resort(int[] arr, int y) {
        int n = arr.length;
        arr = Arrays.copyOf(arr, n + 2);
        arr[n++] = 1;
        arr[n++] = y;
        Arrays.sort(arr);

        // 计算 arr 中任意两个数的差(任意两个栅栏之间的距离都可能是正方形的边长)，保存到哈希集合中
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                set.add(arr[j] - arr[i]);
            }
        }
        return set;
    }
}
```

![2975_移除栅栏得到的正方形田地的最大面积_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/3_%E5%93%88%E5%B8%8C%E8%A1%A8/Images/2975_%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF_Java.png)

## Python代码

```Python
class Solution:
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
        MOD = 1_000_000_007

        h_set = self._get_differences(hFences, m)
        v_set = self._get_differences(vFences, n)

        max_side = 0
        for side in h_set:
            if side in v_set:
                max_side = max(max_side, side)

        return (max_side * max_side) % MOD if max_side > 0 else -1

    def _get_differences(self, arr: List[int], mx: int) -> set:
        new_arr = arr + [1, mx]
        new_arr.sort()

        diffs = set()
        n = len(new_arr)
        for i in range(n):
            for j in range(i + 1, n):
                diffs.add(new_arr[j] - new_arr[i])
        return diffs
```



## C++代码

```C++
class Solution {
public:
    int maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences) {
        const int MOD = 1'000'000'007;
        unordered_set<int> hSet = getDifferences(hFences, m);
        unordered_set<int> vSet = getDifferences(vFences, n);

        int result = 0;
        for (int side : hSet) {
            if (vSet.count(side)) {
                result = result > side ? result : side;
            }
        }

        return result > 0 ? (static_cast<long long>(result) * result % MOD) : -1;
    }

private:
    unordered_set<int> getDifferences(vector<int> arr, int mx) {
        arr.push_back(1);
        arr.push_back(mx);
        sort(arr.begin(), arr.end());

        unordered_set<int> diffs;
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                diffs.insert(arr[j] - arr[i]);
            }
        }
        return diffs;
    }
};
```

