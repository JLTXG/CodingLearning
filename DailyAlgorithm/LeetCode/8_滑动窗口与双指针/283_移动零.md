本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：数组  |  标签

# 一、题目描述

## **问题概括**

给定一个整数数组 `nums`，你需要在不使用额外数组的情况下，原地将所有值为 `0` 的元素移动到数组的末尾，同时保持所有非零元素的相对顺序不变。

## **示例说明**

- **示例1**：输入 `nums = [0,1,0,3,12]`，输出 `[1,3,12,0,0]`。
- **示例2**：输入 `nums = [0]`，输出 `[0]`。

## **数据范围**

- 数组长度范围：`1 <= nums.length <= 10^4`
- 数组元素范围：`-2^31 <= nums[i] <= 2^31 - 1`

## **进阶要求**

能否尽量减少完成的操作次数？



# 二、解题思路\解题过程

这是我写的LeetCode热题100题中的第二道题目，采用双指针的思想来进行求解，准确来说是快慢指针，快指针在前面判断当前的值是否等于0，如果不等于0，直接和慢指针指向的值直接替换并更新慢指针；如果快指针指向的当前的等于0，就不替换，需要更新快指针，如此下去，直到快指针到数组末尾，代码如下！

# 三、代码演示

## Java代码

```Java
class Solution {
    public void moveZeroes(int[] nums) {
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != 0) {
                int tmp = nums[fast];
                nums[fast] = nums[slow];
                nums[slow] = tmp;
                slow++;
            }
            fast++;
        }
    }
}
```



## Python代码

```Python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        fast, slow = 0, 0
        while fast < len(nums) :
            if nums[fast] != 0 :
                tmp = nums[fast]
                nums[fast] = nums[slow]
                nums[slow] = tmp
                slow += 1
            fast += 1
```



## C++代码

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int fast = 0, slow = 0;
        while (fast < nums.size()) {
            if (nums[fast] != 0) {
                swap(nums[fast], nums[slow]);
                slow++;
            }
            fast++;
        }
    }
};
```

![283_移动零_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/283_%E7%A7%BB%E5%8A%A8%E9%9B%B6_C++.png)