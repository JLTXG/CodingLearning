本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[3439. 重新安排会议得到最多空余时间 I - 力扣（LeetCode）](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/description/)

>标签：贪心  |  数组  |  滑动窗口

# 一、题目描述

## **问题概括**

你有一个从时间 `0` 到 `eventTime` 的活动时间段。已有 `n` 个会议，分别由起始时间 `startTime[i]` 和结束时间 `endTime[i]` 定义，这些会议互不重叠且按时间顺序给出（即 `endTime[i] <= startTime[i+1]`）。每个会议的持续时间为 `endTime[i] - startTime[i]`。

你最多可以选择 `k` 个会议进行重新安排：将选中的会议沿着时间轴平移（保持时长不变），平移后所有会议仍需满足：

1. 保持原有的相对顺序（即第 `i` 个会议必须在第 `i - 1` 个会议结束之后开始，且在第 `i + 1` 个会议开始之前结束）；
2. 会议之间不能重叠；
3. 所有会议都必须完全位于活动时间段 `[0, eventTime]` 内。

你的目标是，通过合理安排，使得所有相邻会议之间（或会议与活动边界之间）的连续空闲时间段的最大值尽可能大。请返回这个最大空闲时间长度。

## **示例说明**

- **示例1**：输入：`eventTime = 5, k = 1, startTime = [1, 3], endTime = [2, 5]`，输出`2`
- **示例2**：输入：`eventTime = 10, k = 1, startTime= [0, 2, 9], endTime = [1, 4, 10]`，输出`6`
- **示例3**：`eventTime = 5, k = 2, startTime = [0, 1, 2, 3, 4], endTime = [1, 2, 3, 4, 5]`。所有时间都被占满，空闲为0。

## **数据范围**

- `1 <= eventTime <= 10^9`
- `n == startTime.length == endTime.length`
- `2 <= n <= 10^5`
- `1 <= k <= n`
- `0 <= startTime[i] < endTime[i] <= eventTime`
- `endTime[i] <= startTime[i+1]` 对 `i` 在 `[0, n-2]` 成立。



# 二、解题思路\解题过程

题目要求重新安排会议得到最多空余时间，题目给的示例是“安排会议”，我们可以换一个思路，换成“合并连续的空余时间”，这样子，就转化成了定长滑动窗口类的题目了，只需要定义好空闲时间段的数组，然后采用灵神总结的定长滑动窗口类的三步经典方法即可求出最终的答案（需要注意窗口的长度）！关于空闲时间段的数组——最左边的空闲时间段 + 中间的空闲时间段 + 最右边的空闲时间段！代码如下！

# 三、代码演示

## Java代码

```Java
class Solution {
    public int maxFreeTime(int eventTime, int k, int[] startTime, int[] endTime) {
        int n = startTime.length;
        int[] flag = new int[n + 1];
        // 最左边的空闲时间段
        flag[0] = startTime[0];
        // 中间的空闲时间段
        for (int i = 1; i < n; i++) {
            flag[i] = startTime[i] - endTime[i - 1];
        }
        // 最右边的空闲时间段
        flag[n] = eventTime - endTime[n - 1];

        // 经典的滑动窗口三步法（窗口长度为 k + 1）
        int result = 0, tmp = 0;
        for (int i = 0; i < n + 1; i++) {
            // 入
            // 右端点进入滑动窗口
            tmp += flag[i];

            // 更新答案
            if (i < k) {
                continue;
            }
            result = Math.max(result, tmp);

            // 出
            tmp -= flag[i - k];
        }

        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def maxFreeTime(self, eventTime: int, k: int, startTime: List[int], endTime: List[int]) -> int:
        n = len(startTime)
        flag = [0] * (n + 1)
        # 最左边的空闲时间段
        flag[0] = startTime[0]
        # 中间的空闲时间段
        for i in range(1, n):
            flag[i] = startTime[i] - endTime[i - 1]
        # 最右边的空闲时间段
        flag[n] = eventTime - endTime[n - 1]

        # 经典的滑动窗口三步解法（窗口大小为 k + 1）
        result, tmp = 0, 0
        for i in range(n + 1):
            # 入
            # 右端点进入滑动窗口
            tmp += flag[i]

            # 更新答案
            if i < k :
                continue
            result = max(result, tmp)

            # 出
            tmp -= flag[i - k]
        
        return result
```

![3439_重新安排会议得到最多空余时间 I_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/3439_%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4%20I_Python.png)

## C++代码

```C++
class Solution {
public:
    int maxFreeTime(int eventTime, int k, vector<int>& startTime, vector<int>& endTime) {
        int n = startTime.size();
        vector<int> flag(n + 1);
        // 最左边的空闲时间段
        flag[0] = startTime[0];
        // 中间的空闲时间段
        for (int i = 1; i < n; i++) {
            flag[i] = startTime[i] - endTime[i - 1];
        }
        // 最右边的空闲时间段
        flag[n] = eventTime - endTime[n - 1];

        // 经典的滑动窗口三步法（窗口长度为 k + 1）
        int result = 0, tmp = 0;
        for (int i = 0; i < n + 1; i++) {
            // 入
            // 右端点进入滑动窗口
            tmp += flag[i];

            // 更新答案
            if (i < k) {
                continue;
            }
            result = max(result, tmp);

            // 出
            tmp -= flag[i - k];
        }

        return result;
    }
};
```

