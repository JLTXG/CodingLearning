本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[1052. 爱生气的书店老板 - 力扣（LeetCode）](https://leetcode.cn/problems/grumpy-bookstore-owner/description/)

>标签：数组  |  滑动窗口

# 一、题目描述

## **问题概括**

书店营业时长为 `n` 分钟。每分钟，有一定数量的顾客进入商店（由数组 `customers` 给出，`customers[i]` 表示第 `i` 分钟进入的顾客数），这些顾客在该分钟结束时离开。

老板的情绪状态由数组 `grumpy` 表示：若 `grumpy[i] = 1`，则老板在第 `i` 分钟生气，该分钟的顾客会不满意；若 `grumpy[i] = 0`，则老板不生气，该分钟的顾客感到满意。

老板有一个秘密技巧：他可以选择一个连续的时段，长度为 `minutes` 分钟，在这段时间内保持不生气（无论原本的 `grumpy` 值如何）。这个技巧只能使用**一次**。

你的任务是计算：在最优使用技巧的情况下，这一天最多有多少顾客感到满意（即满意顾客的总数）。

## **示例说明**

- **示例1**：`customers = [1,0,1,2,1,1,7,5]`，`grumpy = [0,1,0,1,0,1,0,1]`，`minutes = 3`。最优方案是在最后 3 分钟使用技巧，使得原本生气的分钟变为不生气。满意顾客总数 = 1 + 0 + 1 + 0 + 1 + 0 + 7 + 5 = 16（技巧覆盖的分钟原本生气，现在满意；其他分钟按原状态计算）。
- **示例2**：`customers = [1]`，`grumpy = [0]`，`minutes = 1`。无论是否使用技巧，满意顾客数都是 1。

## **数据范围**

- `n == customers.length == grumpy.length`
- `1 <= minutes <= n <= 2 * 10^4`
- `0 <= customers[i] <= 1000`
- `grumpy[i]` 的取值为 0 或 1。



# 二、解题思路\解题过程

## ❌ 初次提交情况

这是今天的“滑动窗口”类的题目，同样我也采用的是灵神总结的滑动窗口题目类的经典方法，这里就不赘述了，另外，这道题目还提供了一个数组，用来判断是否加上对应的`customers[i]`值，但是，我有些情况并没有考虑到，提交代码之后并没有通过所有的测试案例，代码如下：

```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int result = 0, windowSum = 0, n = customers.length, flag = 0;
        for (int i = 0; i < n; i++) {
            // 入
            // 右端点进入窗口
            windowSum += customers[i];

            // 更新答案
            int left = i - minutes + 1;
            if (left < 0) {
                // 左端点此时还没有进入滑窗
                continue;
            }
            if (windowSum > result) {
                result = windowSum;
                flag = left;
            }

            // 出
            windowSum -= customers[left];
        }
        for (int i = 0; i < flag; i++) {
            if (grumpy[i] == 0) {
                result += customers[i];
            }
        }
        for (int i = flag + minutes + 1; i < n; i++) {
            if (grumpy[i] == 0) {
                result += customers[i];
            }
        }
        return result;
    }
}
```

我当前代码有以下几个关键错误：

---

## ❌ **主要问题 1：滑动窗口计算的是所有顾客，而不是“因生气而流失”的顾客**

当前的滑动窗口：

```Java
windowSum += customers[i];
```

这是把所有顾客都加进去了，但**只有当 `grumpy[i] == 1` 时，这些顾客才是“本可以挽回”的**。如果老板本来就不生气（`grumpy[i] == 0`），那这部分顾客已经算在最终结果里了，**不应该再通过技巧（控制不生气）来“额外”获得**。

所以，滑动窗口应该只累加 `grumpy[i] == 1` 时的 `customers[i]`。

---

## ❌ **主要问题 2：最终结果的计算方式错误**

代码中最后是这样计算：

```Java
for (int i = 0; i < flag; i++) {
	if (grumpy[i] == 0) result += customers[i];
}

for (int i = flag + minutes + 1; i < n; i++) {
	if (grumpy[i] == 0) result += customers[i];
}
```

这里有两个错误：
1. **初始的 `result` 是滑动窗口中最大总顾客数（包括本来就不生气的部分）**，但你应该只把“额外挽回的生气时段顾客”加到“原本就满意的顾客总数”上。
2. **第二个循环的起始索引写错了**：应该是 `flag + minutes`，不是 `flag + minutes + 1`（多跳了一位）。

而且，更清晰的做法是：
- 先计算 **所有 `grumpy[i] == 0` 的 `customers[i]` 总和**（即基础满意顾客）。
- 再用滑动窗口找出 **在任意连续 `minutes` 内，`grumpy[i] == 1` 的 `customers[i]` 最大和**（即最多能额外挽回多少）。
- 两者相加就是答案。

## ✅ 正确思路总结 + 代码展示

1. 计算 `base = sum(customers[i] for i where grumpy[i] == 0)`
2. 用滑动窗口计算 `maxExtra = max(sum(customers[i] for i in [j, j+minutes-1] where grumpy[i]==1))`
3. 返回 `base + maxExtra`

```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int windowSum = 0, result = 0;
        int n = customers.length, base = 0;

        // Step 1：计算原本就满意的顾客总数
        for (int i = 0; i < n; i++) {
            if (grumpy[i] == 0) {
                base += customers[i];
            }
        }

        // Step 2：滑动窗口找最多能挽回的生气时段顾客
        for (int i = 0; i < n; i++) {
            // 入
            // 右端点进入滑窗
            if (grumpy[i] == 1) {
                windowSum += customers[i];
            }

            // 更新答案
            int left = i - minutes + 1;
            if (left < 0) {
                // 此时左端点还没有进入滑窗
                continue;
            }
            result = Math.max(result, windowSum);

            // 出
            if (grumpy[left] == 1) {
                windowSum -= customers[left];
            }
        }

        return base + result;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int windowSum = 0, result = 0;
        int n = customers.length, base = 0;

        // Step 1：计算原本就满意的顾客总数
        for (int i = 0; i < n; i++) {
            if (grumpy[i] == 0) {
                base += customers[i];
            }
        }

        // Step 2：滑动窗口找最多能挽回的生气时段顾客
        for (int i = 0; i < n; i++) {
            // 入
            // 右端点进入滑窗
            if (grumpy[i] == 1) {
                windowSum += customers[i];
            }

            // 更新答案
            int left = i - minutes + 1;
            if (left < 0) {
                // 此时左端点还没有进入滑窗
                continue;
            }
            result = Math.max(result, windowSum);

            // 出
            if (grumpy[left] == 1) {
                windowSum -= customers[left];
            }
        }

        return base + result;
    }
}
```



## Python代码

```Python
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        result, window_sum, base, n = 0, 0, 0, len(customers)

        for i in range(n):
            # 原本满意顾客的数量
            if grumpy[i] == 0 :
                base += customers[i]

            # 入
            # 右端点进入滑窗
            if grumpy[i] == 1 :
                window_sum += customers[i]
            
            # 更新答案
            left = i - minutes + 1
            if left < 0 : 
                # 说明此时左端点还没有进入滑窗
                continue
            result = max(result, window_sum)
            
            # 出
            if grumpy[left] == 1 :
                window_sum -= customers[left]
        
        return base + result
```



## C++代码

```C++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int result = 0, windowSum = 0;
        int base = 0, n = customers.size();

        for (int i = 0; i < n; i++) {
            // 原本满意顾客的数量
            if (grumpy[i] == 0) {
                base += customers[i];
            }

            // 入
            // 右端点进入滑窗
            if (grumpy[i] == 1) {
                windowSum += customers[i];
            }

            // 更新答案
            int left = i - minutes + 1;
            if (left < 0) {
                // 此时左端点还没有进入窗口
                continue;
            }
            result = max(result, windowSum);

            // 出
            if (grumpy[left] == 1) {
                windowSum -= customers[left];
            }
        }

        return base + result;
    }
};
```

![1052_爱生气的书店老板_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/1052_%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF_C++.png)