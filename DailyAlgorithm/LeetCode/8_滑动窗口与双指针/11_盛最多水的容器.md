本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/?envType=problem-list-v2&envId=greedy)

>标签：贪心  |  数组  |  双指针

# 一、题目描述

## **问题概括**

给定一个整数数组 `height`，其中 `height[i]` 表示位于 x 坐标 `i` 处的一条垂直线的高度。你需要选择两条不同的垂直线，使得它们与 x 轴围成的矩形容器能够容纳最多的水。容器的宽度等于两条线在 x 轴上的距离（即索引差的绝对值），容器的高度等于两条线中较短的那条线的高度。容器的容量（储水量）即为宽度与高度的乘积。你的目标是找出这个容量的最大值。

## **示例说明**

- **示例1**：输入 `height = [1,8,6,2,5,4,8,3,7]`，最大容量为 49。对应的两条线是索引 1（高度 8）和索引 8（高度 7），宽度为 7，高度为 7，乘积为 49。

    ![IMG](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg)

- **示例2**：输入 `height = [1,1]`，最大容量为 1。两条线索引 0 和 1，宽度 1，高度 1，乘积为 1。

## **数据范围**

- 数组长度 `n` 满足 `2 <= n <= 10^5`。
- 数组中的每个元素满足 `0 <= height[i] <= 10^4`。



# 二、解题思路\解题过程

这道题还可以，之前做过一遍，在“贪心”标签的题库里面，可以使用“双指针”的方法来进行求解！思路如下：
这道题之所以可以使用“双指针”的方法，而且不用担心会遗漏掉某些情况，原因如下：
我们使用两个指针分别指向数组的首末两个位置，指向首的为“left”，指向未的为“right”，然后计算这两个指针的之间的长度，然后在乘以这个两个指针指向的其中较小的值，即可以得到目前两个指针能得到的水的水量！此时，指针之间的长度已经是最长的了，如果还想容器中的容量增加，那么只能移动指针，而不管怎么移、移动哪一个指针，指针之间的长度就不会再增加，那么就需要去增加“水”的高度，才有可能增加容器中的容量，那么就只能移动原先两个指针中较小的值的那个指针了，只有这样容器的容量才可能增加，这样就不用担心遗漏掉情况了！直到当两个指针相遇的时候就可以跳出循环了！（两个指针相遇之后就没必要继续遍历下去了，因为会和以前的遍历重复！）
代码如下：

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, flag = 0;
        while(left < right){
            int cnn = (right - left) * (height[left] < height[right] ? height[left] : height[right]);
            flag = flag > cnn ? flag : cnn;
            if(height[right] > height[left]){
                left++;
            } else {
                right--;
            }
        }
        return flag;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, flag = 0;
        while(left < right){
            int cnn = (right - left) * (height[left] < height[right] ? height[left] : height[right]);
            flag = flag > cnn ? flag : cnn;
            if(height[right] > height[left]){
                left++;
            } else {
                right--;
            }
        }
        return flag;
    }
}
```



## Python代码

```Python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right, flag = 0, len(height) - 1, 0
        while left < right :
            capacity = (right - left) * min(height[right], height[left])
            flag = flag if flag > capacity else capacity
            if height[right] > height[left] :
                left += 1
            else :
                right -= 1
        return flag
```



## C++代码

```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = size(height) - 1, flag = 0;
        while(left < right){
            int capacity = (right - left) * min(height[left], height[right]);
            flag = flag > capacity ? flag : capacity;
            if(height[left] > height[right]){
                right--;
            } else {
                left++;
            }
        }
        return flag;
    }
};
```

![11_盛最多水的容器_力扣_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8_%E5%8A%9B%E6%89%A3_C++.png)
