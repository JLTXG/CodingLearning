[2841. 几乎唯一子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)

>标签：数组  |  哈希表  |  滑动窗口

# 一、题目描述

给你一个整数数组 `nums` 和两个正整数 `m` 和 `k` 。

请你返回 `nums` 中长度为 `k` 的 **几乎唯一** 子数组的 **最大和** ，如果不存在几乎唯一子数组，请你返回 `0` 。

如果 `nums` 的一个子数组有至少 `m` 个互不相同的元素，我们称它是 **几乎唯一** 子数组。

子数组指的是一个数组中一段连续 **非空** 的元素序列。

 

**示例 1：**

```
输入：nums = [2,6,7,3,1,7], m = 3, k = 4
输出：18
解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。
```

**示例 2：**

```
输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3
输出：23
解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。
```

**示例 3：**

```
输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3
输出：0
解释：输入数组中不存在长度为 k = 3 的子数组含有至少  m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。
```

 

**提示：**

- `1 <= nums.length <= 2 * 10^4`
- `1 <= m <= k <= nums.length`
- `1 <= nums[i] <= 10^9`



# 二、解题思路\解题过程

这是今天的第二道“滑动窗口”类的题目，这道题和以前做的“滑动窗口”类的题目不一样的地方在于——这道题目需要计算窗口内的不同元素的个数，这就需要用到对应的集合来进行处理就好了，基本的解题思路和思想都是按照灵神总结的那三步来的，至于那三步的顺序就得按照题目来进行调整了，期间还可能有其他的题目要求，只要一步步满足就好了，具体代码如下：

```cpp
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long result = 0, count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            count += nums[i];
            freq[nums[i]]++;

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums[i - k];
                count -= leftNum;
                freq[leftNum]--;
                if (freq[leftNum] == 0) {
                    // 只有计数为 0 才移除
                    freq.erase(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public long maxSum(List<Integer> nums, int m, int k) {
        long result = 0, count = 0;
        int n = nums.size();
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            int rightNum = nums.get(i);
            count += rightNum;
            freq.put(rightNum, freq.getOrDefault(rightNum, 0) + 1);

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums.get(i - k);
                count -= leftNum;
                freq.put(leftNum, freq.get(leftNum) - 1);
                if (freq.get(leftNum) == 0) {
                    // 只有计数为 0 才移除
                    freq.remove(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = Math.max(result, count);
                }
            }
        }
        return result;
    }
}
```



## Python代码

```Python
class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        max_sum, window_sum, n = 0, 0, len(nums)
        freq = defaultdict(int)

        for i in range(n):
            # 右端点进入窗口
            window_sum += nums[i]
            freq[nums[i]] += 1

            # 如果窗口超过 k，收缩左边界
            if i >= k :
                left_num = nums[i - k]
                window_sum -= left_num
                freq[left_num] -= 1
                if freq[left_num] == 0 :
                    freq.pop(left_num)

            # 更新答案，当前窗口长度为 k
            if i >= k - 1 :
                if len(freq) >= m :
                    max_sum = max(max_sum, window_sum)
        
        return max_sum
```



## C++代码

```C++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long result = 0, count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for (int i = 0; i < n; i++) {
            // 右端点进入滑窗
            count += nums[i];
            freq[nums[i]]++;

            // 如果窗口大小超过 k，收缩左边界
            if (i >= k) {
                int leftNum = nums[i - k];
                count -= leftNum;
                freq[leftNum]--;
                if (freq[leftNum] == 0) {
                    // 只有计数为 0 才移除
                    freq.erase(leftNum);
                }
            }

            // 上述第二个判断中，就已经调整好了窗口大小（已经满足了先验条件），只要 i >= k - 1，这个时候，窗口大小就正好是 k
            if (i >= k - 1) {
                if (freq.size() >= m) {
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```

![2841_几乎唯一子数组的最大和_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2841_%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C_C++.png)