[2090. 半径为 k 的子数组平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/k-radius-subarray-averages/description/)

>标签：数组  |  滑动窗口

# 一、题目描述

给你一个下标从 **0** 开始的数组 `nums` ，数组中有 `n` 个整数，另给你一个整数 `k` 。

**半径为 k 的子数组平均值** 是指：`nums` 中一个以下标 `i` 为 **中心** 且 **半径** 为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（**含** `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么 **半径为 k 的子数组平均值** 是 `-1` 。

构建并返回一个长度为 `n` 的数组 `avgs` ，其中 `avgs[i]` 是以下标 `i` 为中心的子数组的 **半径为 k 的子数组平均值** 。

`x` 个元素的 **平均值** 是 `x` 个元素相加之和除以 `x` ，此时使用截断式 **整数除法** ，即需要去掉结果的小数部分。

- 例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`，截断后得到 `2` 。

 

**示例 1：**

![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2090_%E5%8D%8A%E5%BE%84%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC_%E7%A4%BA%E4%BE%8B1.png)

```
输入：nums = [7,4,3,9,1,8,5,2,6], k = 3
输出：[-1,-1,-1,5,4,4,-1,-1,-1]
解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。
```

**示例 2：**

```
输入：nums = [100000], k = 0
输出：[100000]
解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。
```

**示例 3：**

```
输入：nums = [8], k = 100000
输出：[-1]
解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 10^5`
- `0 <= nums[i], k <= 10^5`



# 二、解题思路\解题过程

这也是一道`滑动窗口`类的题目，也可以采用灵神总结的框架方法，不过需要注意的是，这次的`i`下标指向的值是整个窗口的中心，所以，这次关注的不仅仅只有左端点，还有下标`i`中心到右端点这部分的数值，我采用的方法就是，再加一个循环——把`i 到 i + k（不包括i，但包括 i + k）`这部分的数值临时加了起来，这样就和之前做的题目差不多了，但是，只通过了39个测试样例，还差最后1个测试样例没有跑通，然后我在IDEA中写了一个测试代码，准备把最后一个样例跑出来看看最终的结果，结果代码太长了，跑不通！具体代码如下：

```java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length, flag = 0;
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            // 入
            flag += nums[i];

            // 更新答案
            int left = i - k, rigth = i + k;
            if (left < 0 || rigth >= n) {
                arr[i] = -1;
                continue;
            }
            int tmp = 0;
            for (int j = i + 1; j <= i + k; j++) {
                tmp += nums[j];
            }
            arr[i] = (flag + tmp) / (2 * k + 1);

            // 出
            flag -= nums[left];
        }
        return arr;
    }
}
```

后面我把我的代码给`AI`分析了一下，`AI`得出的结论是：
- 时间复杂度过高：内层循环导致`~4e9`操作，超时
- 整数溢出：`int`无法存下`8e9`的和，结果错误
- 滑动窗口逻辑错误：没有真正实现滑动，而是暴力重算

解决方案：改用标准`O(n)`滑动窗口 + `long`累加和。

代码如下：

```cpp
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(), windowSize = 2 * k + 1;
        long long windowSum = 0;  // 用 long 防溢出
        vector<int> arr(n, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = static_cast<int> (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = static_cast<int> (windowSum / windowSize);
        }
        return arr;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] getAverages(int[] nums, int k) {
        int n = nums.length, windowSize = 2 * k + 1;
        long windowSum = 0;  // 用 long 防溢出
        int[] arr = new int[n];
        Arrays.fill(arr, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = (int) (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = (int) (windowSum / windowSize);
        }
        return arr;
    }
}
```



## Python代码

```Python
class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n, window_size, window_sum = len(nums), 2 * k + 1, 0
        arr = [-1] * n

        if k == 0 :
            # 边界
            return nums
        if window_size > n :
            # 窗口太大
            return arr

        for i in range(window_size):
            window_sum += nums[i]
        arr[k] = window_sum // window_size

        for i in range(k + 1, n - k):
            window_sum = window_sum - nums[i - k - 1] + nums[i + k]
            arr[i] = window_sum // window_size
        
        return arr
```



## C++代码

```C++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(), windowSize = 2 * k + 1;
        long long windowSum = 0;  // 用 long 防溢出
        vector<int> arr(n, -1);  // 默认 -1

        if (k == 0) {
            // 边界
            return nums;
        }
        if (windowSize > n) {
            // 窗口太大
            return arr;
        }

        // 初始化第一个完整窗口 [0, 2k]
        for (int i = 0; i < windowSize; i++) {
            windowSum += nums[i];
        }
        arr[k] = static_cast<int> (windowSum / windowSize);

        // 滑动窗口：从 [i - k, i + k] → [i - k + 1, i + k + 1]
        for (int i = k + 1; i <= n - k - 1; i++) {
            windowSum = windowSum - nums[i - k - 1] + nums[i + k];
            arr[i] = static_cast<int> (windowSum / windowSize);
        }
        return arr;
    }
};
```

![2090_半径为 k 的子数组平均值_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/8_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/Images/2090_%E5%8D%8A%E5%BE%84%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC_C++.png)