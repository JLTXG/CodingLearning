本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：递归  |  链表

# 一、题目描述

## **问题概括**

给定一个单链表的头节点 `head` 和一个正整数 `k`，请将链表按照每 `k` 个节点一组进行翻转，并返回翻转后的链表。如果链表中的节点总数不是 `k` 的整数倍，则最后剩余不足 `k` 个的节点保持原有顺序。要求只能通过改变节点之间的链接关系实现，不能修改节点内部的值。

## **示例说明**

- 输入 `head = [1,2,3,4,5]`, `k = 2`，输出 `[2,1,4,3,5]`。
- 输入 `head = [1,2,3,4,5]`, `k = 3`，输出 `[3,2,1,4,5]`。

## **数据范围**

- 链表节点数 `n` 满足 `1 <= k <= n <= 5000`。
- 节点值范围 `0 <= Node.val <= 1000`。

## **进阶要求**

能否使用 O(1) 额外内存空间解决？



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 第一步：统计链表总长度 n
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            n++;
        }

        // 创建哨兵节点（dummy），统一处理头节点被反转的情况
        ListNode dummy = new ListNode(0, head);

        // p0：指向当前待反转组的前一个节点（初始为 dummy）
        ListNode p0 = dummy;

        // pre 和 cur：用于标准的链表反转（pre 是已反转部分的头，cur 是待处理节点）
        ListNode pre = null;
        ListNode cur = head;

        // 只要剩余节点数 ≥ k，就进行一次 k 个节点的反转
        for (; n >= k; n -= k) {
            // 内层循环：反转当前 k 个节点（标准三指针反转）
            for (int i = 0; i < k; i++) {
                ListNode nxt = cur.next;   // 保存下一个节点
                cur.next = pre;            // 反转当前节点的指针
                pre = cur;                 // pre 前移
                cur = nxt;                 // cur 前移
            }

            // 此时：
            // - pre 指向当前已反转组的头（原组尾）
            // - cur 指向下一组的开头（或 null）
            // - p0.next 仍指向原组头（现在是组尾）

            // 关键：重新连接三段链表
            ListNode nextGroupStart = p0.next;  // 原组头（现在是组尾），也是下一轮的 p0

            // 1. 原组尾 → 下一组开头（保持链表连续）
            p0.next.next = cur;

            // 2. p0 → 新组头（即 pre）
            p0.next = pre;

            // 3. 更新 p0 为原组尾（即下一轮的前驱）
            p0 = nextGroupStart;
        }

        return dummy.next;
    }
}
```

---

## 🧠 核心解题思想分析

### 🔍 问题目标：

将链表**每 k 个节点一组进行反转**，如果最后不足 k 个，则**保持原样**。

> 例如：  
> 输入：`1 → 2 → 3 → 4 → 5`, `k = 2`  
> 输出：`2 → 1 → 4 → 3 → 5`  
> （最后一组只有 1 个，不反转）

---

### 💡 核心思想：**分组迭代 + 局部反转 + 全局拼接**

#### 1. **为什么先统计长度？**

- 题目要求：**不足 k 个不反转**；
- 通过总长度 `n`，可提前知道能完整反转多少组（`n / k` 组）；
- 避免在反转过程中“试错”判断是否够 k 个（更简洁）。

#### 2. **每组反转使用标准三指针法**

- `pre`：已反转部分的头
- `cur`：当前待处理节点
- `nxt`：保存 `cur.next`
- 循环 k 次，完成局部反转。

#### 3. **反转后如何拼接？**

这是本题最难的部分！需要连接三段：

```
[已处理部分] → [新反转组] → [未处理部分]
```

设当前组原为：`A → B → C`（k=3），p0 指向 A 的前驱 X

反转后：

- 组内：`C → B → A`
- `pre = C`（新头）
- `cur = D`（下一组开头）
- `p0.next = A`（仍指向原头）

拼接步骤：

1. `A.next = D` → 让原组尾连到下一组
2. `X.next = C` → 让前驱连到新头
3. 更新 `p0 = A`（为下一组做准备）

> ✅ 这三步确保链表不断裂！

---

### 🔄 示例演示（k=2）

初始：`dummy → 1 → 2 → 3 → 4 → 5`  
`p0 = dummy`, `cur = 1`, `n = 5`

**第1组（1→2）**：

- 反转后：`2 → 1`
- `pre = 2`, `cur = 3`
- 拼接：
    - `1.next = 3`
    - `dummy.next = 2`
    - `p0 = 1`
- 链表：`dummy → 2 → 1 → 3 → 4 → 5`

**第2组（3→4）**：

- 反转后：`4 → 3`
- `pre = 4`, `cur = 5`
- 拼接：
    - `3.next = 5`
    - `1.next = 4`
    - `p0 = 3`
- 链表：`dummy → 2 → 1 → 4 → 3 → 5`

**剩余 n=1 < k=2 → 停止**

返回 `dummy.next = 2` ✅

---

### ⏱️ 复杂度分析：

- **时间复杂度**：O(n)  
    —— 遍历两次：一次统计长度，一次反转（每个节点访问常数次）
- **空间复杂度**：O(1)  
    —— 只用常数个指针

> ✅ 这是最优解！

---

## 📚 笔记总结

### 🧩 核心思想：

> **先统计长度 → 分组迭代 → 局部反转 → 全局拼接**

### ✅ 算法步骤：

1. **统计链表长度 `n`**；
2. 创建哨兵节点 `dummy`，`p0 = dummy`；
3. 当 `n >= k`：
    - 使用三指针（`pre`, `cur`, `nxt`）**反转当前 k 个节点**；
    - 反转后：
        - 原组尾（`p0.next`）连到 `cur`（下一组开头）；
        - `p0` 连到新组头（`pre`）；
        - 更新 `p0 = 原组尾`；
    - `n -= k`；
4. 返回 `dummy.next`。

### 🔑 关键技巧：

- **哨兵节点**统一处理头节点变化；
- **先统计长度**避免“试反转”；
- **反转后三步拼接**是核心难点：
  
    ```java
    ListNode nxt = p0.next;
    p0.next.next = cur;  // 原组尾 → 下一组
    p0.next = pre;       // 前驱 → 新组头
    p0 = nxt;            // 更新前驱
    ```
    

### ⏱️ 复杂度：

- 时间：O(n)
- 空间：O(1)

### 💡 对比其他方法：

- 方法1：每次反转前检查是否有 k 个 → 需额外遍历；
- **本方法更高效**：仅两次完整遍历。

---

# 三、代码演示

## Java代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 第一步：统计链表总长度 n
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            n++;
        }

        // 创建哨兵节点（dummy），统一处理头节点被反转的情况
        ListNode dummy = new ListNode(0, head);

        // p0：指向当前待反转组的前一个节点（初始为 dummy）
        ListNode p0 = dummy;

        // pre 和 cur：用于标准的链表反转（pre 是已反转部分的头，cur 是待处理节点）
        ListNode pre = null;
        ListNode cur = head;

        // 只要剩余节点数 ≥ k，就进行一次 k 个节点的反转
        for (; n >= k; n -= k) {
            // 内层循环：反转当前 k 个节点（标准三指针反转）
            for (int i = 0; i < k; i++) {
                ListNode nxt = cur.next;   // 保存下一个节点
                cur.next = pre;            // 反转当前节点的指针
                pre = cur;                 // pre 前移
                cur = nxt;                 // cur 前移
            }

            // 此时：
            // - pre 指向当前已反转组的头（原组尾）
            // - cur 指向下一组的开头（或 null）
            // - p0.next 仍指向原组头（现在是组尾）

            // 关键：重新连接三段链表
            ListNode nextGroupStart = p0.next;  // 原组头（现在是组尾），也是下一轮的 p0

            // 1. 原组尾 → 下一组开头（保持链表连续）
            p0.next.next = cur;

            // 2. p0 → 新组头（即 pre）
            p0.next = pre;

            // 3. 更新 p0 为原组尾（即下一轮的前驱）
            p0 = nextGroupStart;
        }

        return dummy.next;
    }
}
```



## Python代码

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 第一步：统计链表总长度 n
        n = 0
        cur = head
        while cur is not None:
            n += 1
            cur = cur.next

        # 创建哨兵节点（dummy），统一处理头节点被反转的情况
        dummy = ListNode(0, head)

        # p0：指向当前待反转组的前一个节点（初始为 dummy）
        p0 = dummy

        # pre 和 cur：用于标准的链表反转（pre 是已反转部分的头，cur 是待处理节点）
        pre = None
        cur = head

        # 只要剩余节点数 ≥ k，就进行一次 k 个节点的反转
        while n >= k:
            # 内层循环：反转当前 k 个节点（标准三指针反转）
            for i in range(k):
                nxt = cur.next    # 保存下一个节点
                cur.next = pre    # 反转当前节点的指针
                pre = cur         # pre 前移
                cur = nxt         # cur 前移

            # 此时：
            # - pre 指向当前已反转组的头（原组尾）
            # - cur 指向下一组的开头（或 null）
            # - p0.next 仍指向原组头（现在是组尾）

            # 关键：重新连接三段链表
            next_group_start = p0.next  # 原组头（现在是组尾），也是下一轮的 p0

            # 1. 原组尾 → 下一组开头（保持链表连续）
            p0.next.next = cur

            # 2. p0 → 新组头（即 pre）
            p0.next = pre

            # 3. 更新 p0 为原组尾（即下一轮的前驱）
            p0 = next_group_start
            
            n -= k

        return dummy.next
```



## C++代码

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 第一步：统计链表总长度 n
        int n = 0;
        for (ListNode* cur = head; cur != nullptr; cur = cur->next) {
            n++;
        }

        // 创建哨兵节点（dummy），统一处理头节点被反转的情况
        ListNode* dummy = new ListNode(0, head);

        // p0：指向当前待反转组的前一个节点（初始为 dummy）
        ListNode* p0 = dummy;

        // pre 和 cur：用于标准的链表反转（pre 是已反转部分的头，cur 是待处理节点）
        ListNode* pre = nullptr;
        ListNode* cur = head;

        // 只要剩余节点数 ≥ k，就进行一次 k 个节点的反转
        for (; n >= k; n -= k) {
            // 内层循环：反转当前 k 个节点（标准三指针反转）
            for (int i = 0; i < k; i++) {
                ListNode* nxt = cur->next;   // 保存下一个节点
                cur->next = pre;             // 反转当前节点的指针
                pre = cur;                   // pre 前移
                cur = nxt;                   // cur 前移
            }

            // 此时：
            // - pre 指向当前已反转组的头（原组尾）
            // - cur 指向下一组的开头（或 null）
            // - p0->next 仍指向原组头（现在是组尾）

            // 关键：重新连接三段链表
            ListNode* nextGroupStart = p0->next;  // 原组头（现在是组尾），也是下一轮的 p0

            // 1. 原组尾 → 下一组开头（保持链表连续）
            p0->next->next = cur;

            // 2. p0 → 新组头（即 pre）
            p0->next = pre;

            // 3. 更新 p0 为原组尾（即下一轮的前驱）
            p0 = nextGroupStart;
        }

        return dummy->next;
    }
};
```

![25_K 个一组翻转链表_C++]()