本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

>标签：哈希表  |  链表  |  双指针

# 一、题目描述

## **问题概括**

给定两个无环单链表的头节点 `headA` 和 `headB`。如果两个链表相交（即从某个节点开始，它们后续的节点完全重合），请找出并返回相交的起始节点。如果两个链表没有相交，则返回 `null`。

**要求**：返回结果后，两个链表必须保持其原始结构。你需要设计一个时间复杂度为 O(m + n)、空间复杂度为 O(1) 的解决方案。

## **示例说明**

- **示例1**：链表 A 为 `[4,1,8,4,5]`，链表 B 为 `[5,6,1,8,4,5]`，它们在值为 8 的节点处相交，返回指向该节点的指针。
- **示例2**：链表 A 为 `[1,9,1,2,4]`，链表 B 为 `[3,2,4]`，它们在值为 2 的节点处相交。
- **示例3**：链表 A 为 `[2,6,4]`，链表 B 为 `[1,5]`，它们不相交，返回 `null`。

## **数据范围**

- 链表 A 的长度为 m，链表 B 的长度为 n，满足 `1 <= m, n <= 3 * 10^4`
- 节点值在 `1` 到 `10^5` 之间



# 二、解题思路\解题过程

## ✅ 带详细注释的代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 定义两个指针 p 和 q，分别从链表 A 和 B 的头节点出发
        ListNode p = headA;
        ListNode q = headB;

        // 循环条件：当 p 和 q 没有相遇时继续移动
        // 注意：如果两链表不相交，最终 p 和 q 都会变为 null，此时也会退出循环（null == null）
        while (p != q) {
            // p 向前走一步；如果走到 A 的末尾（p == null），则跳到 B 的头部继续走
            p = p != null ? p.next : headB;
            
            // q 向前走一步；如果走到 B 的末尾（q == null），则跳到 A 的头部继续走
            q = q != null ? q.next : headA;
        }

        // 当 p == q 时，有两种可能：
        // 1. 找到了相交节点（p 和 q 指向同一个节点）
        // 2. 两链表不相交，此时 p == q == null
        // 无论哪种情况，直接返回 p 即可
        return p;
    }
}
```

---

## 🧠 核心解题思想分析

### 🔍 问题目标：

给定两个单链表 `headA` 和 `headB`，判断它们是否**相交**（即是否存在某个节点，两个链表都指向它，并且之后完全共享）。  
如果相交，返回**第一个相交的节点**；否则返回 `null`。

> ⚠️ 注意：相交是指**节点对象相同**（内存地址相同），不是值相同！

---

### 💡 关键洞察：**“路径长度对齐”**

假设：

- 链表 A 独有部分长度为 `a`
- 链表 B 独有部分长度为 `b`
- 公共部分长度为 `c`

那么：

- A 的总长度 = `a + c`
- B 的总长度 = `b + c`

如果我们让两个指针分别走完自己的链表后，**立即跳到对方的头节点继续走**，那么：

- 指针 p 走的路径：`A独有(a) → 公共(c) → B独有(b)`
- 指针 q 走的路径：`B独有(b) → 公共(c) → A独有(a)`

两者总共都走了 `a + b + c` 步！

✅ **关键结论**：

> 在第 `a + b + c` 步时，两个指针一定会在**第一个相交节点**处相遇（如果存在相交）；  
> 如果不相交（`c = 0`），那么它们会在走完 `a + b` 步后同时变为 `null`，也满足 `p == q`。

这就巧妙地**消除了两个链表长度不同的影响**，无需提前计算长度或对齐。

---

### 🔄 举个例子说明

```
A:     a1 → a2
              ↘
               c1 → c2 → c3
              ↗
B:  b1 → b2 → b3
```

- A 独有：2 个节点（a1, a2）
- B 独有：3 个节点（b1, b2, b3）
- 公共：3 个节点（c1, c2, c3）

指针路径：

| 步数 | p（从A出发）           | q（从B出发）           |
| ---- | ---------------------- | ---------------------- |
| 0    | a1                     | b1                     |
| 1    | a2                     | b2                     |
| 2    | c1                     | b3                     |
| 3    | c2                     | c1                     |
| 4    | c3                     | c2                     |
| 5    | null → 跳到 headB (b1) | c3                     |
| 6    | b1                     | null → 跳到 headA (a1) |
| 7    | b2                     | a1                     |
| 8    | b3                     | a2                     |
| 9    | c1 ← 相遇！            | c1 ← 相遇！            |

虽然看起来绕远了，但**第 9 步时 p 和 q 同时到达 c1**，正确返回！

> 实际上，数学上可以证明：最多走 `a + b + c` 步就一定相遇。

---

## 📚 笔记总结

### 🧩 核心思想：

- 利用**双指针 + 路径拼接**技巧，消除链表长度差异。
- 每个指针遍历完自己的链表后，**跳到另一个链表的头部继续遍历**。
- 由于总路径长度相同（`lenA + lenB`），两指针必在**第一个相交点**或 `null` 处相遇。

### ✅ 算法步骤：

1. 初始化 `p = headA`, `q = headB`
2. 循环直到 `p == q`：
    - `p = p != null ? p.next : headB`
    - `q = q != null ? q.next : headA`
3. 返回 `p`（即相交节点或 `null`）

### ⏱️ 时间复杂度：

- **O(m + n)**，其中 m、n 是两个链表的长度

### 📦 空间复杂度：

- **O(1)**，仅使用两个指针

### 💡 为什么有效？

- 若相交：两指针在公共部分起点相遇
- 若不相交：两指针同时走到 `null`（因为都走了 `m + n` 步）

### ❗ 注意事项：

- 相交判断依据是**节点引用相同**，不是值相同
- 不需要修改原链表结构
- 优雅、简洁、高效，是面试高频解法

---

# 三、代码演示

## Java代码

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while (p != q) {
            p = p != null ? p.next : headB;
            q = q != null ? q.next : headA;
        }
        return p;
    }
}
```

![160_相交链表_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%9E%E6%BA%AF/Images/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8_Java.png)

## Python代码

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        p, q = headA, headB
        while p is not q:
            p = p.next if p else headB
            q = q.next if q else headA
        return p
```



## C++代码

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* p = headA;
        ListNode* q = headB;
        while (p != q) {
            p = p != NULL ? p->next : headB;
            q = q != NULL ? q->next : headA;
        }
        return p;
    }
};
```

