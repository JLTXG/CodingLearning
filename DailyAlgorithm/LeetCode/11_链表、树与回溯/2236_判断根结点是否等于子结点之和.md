本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[2236. 判断根结点是否等于子结点之和 - 力扣（LeetCode）](https://leetcode.cn/problems/root-equals-sum-of-children/description/?envType=study-plan-v2&envId=primers-list)

>标签：树  |  二叉树

# 一、题目描述

## **问题概括**

给定一个恰好包含三个节点的二叉树：根节点、左子节点和右子节点。你需要判断根节点的值是否等于左子节点值与右子节点值之和。如果相等，返回 `true`；否则返回 `false`。

## **示例说明**

- **示例1**：根节点值为 `10`，左子节点值为 `4`，右子节点值为 `6`。由于 `10 = 4 + 6`，返回 `true`。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/2236_%E5%88%A4%E6%96%AD%E6%A0%B9%E7%BB%93%E7%82%B9%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E5%AD%90%E7%BB%93%E7%82%B9%E4%B9%8B%E5%92%8C_%E7%A4%BA%E4%BE%8B1.png)

    ```
    输入：root = [10,4,6]
    输出：true
    解释：根结点、左子结点和右子结点的值分别是 10 、4 和 6 。
    由于 10 等于 4 + 6 ，因此返回 true 。
    ```

- **示例2**：根节点值为 `5`，左子节点值为 `3`，右子节点值为 `1`。由于 `5 ≠ 3 + 1`，返回 `false`。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/2236_%E5%88%A4%E6%96%AD%E6%A0%B9%E7%BB%93%E7%82%B9%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E5%AD%90%E7%BB%93%E7%82%B9%E4%B9%8B%E5%92%8C_%E7%A4%BA%E4%BE%8B2.png)

    ```
    输入：root = [5,3,1]
    输出：false
    解释：根结点、左子结点和右子结点的值分别是 5 、3 和 1 。
    由于 5 不等于 3 + 1 ，因此返回 false 。
    ```

## **数据范围**

- 节点值的范围在 `-100` 到 `100` 之间。



# 二、解题思路\解题过程

这也是一道非常简单的题目，就是简单的判断一下就OK了，话不多说，代码如下：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool checkTree(TreeNode* root) {
        return root->val == root->right->val + root->left->val;
    }
};
```



# 三、代码演示

## Java代码

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean checkTree(TreeNode root) {
        return root.val == root.right.val + root.left.val;
    }
}
```



## Python代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.right.val + root.left.val == root.val
```



## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool checkTree(TreeNode* root) {
        return root->val == root->right->val + root->left->val;
    }
};
```

![2236_判断根结点是否等于子结点之和_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/Images/2236_%E5%88%A4%E6%96%AD%E6%A0%B9%E7%BB%93%E7%82%B9%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E5%AD%90%E7%BB%93%E7%82%B9%E4%B9%8B%E5%92%8C_C++.png)