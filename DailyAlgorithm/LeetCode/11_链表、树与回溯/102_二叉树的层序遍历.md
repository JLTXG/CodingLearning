本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

>标签：树  |  广度优先搜索  |  二叉树

# 一、题目描述

## **问题概括**

给定一个二叉树的根节点 `root`，要求返回其节点值的 **层序遍历** 结果。层序遍历是指从根节点开始，逐层、从左到右地访问树中的所有节点，并将每一层的节点值分别存储在一个子列表中。

## **示例说明**

- **示例1**：给定二叉树 `[3,9,20,null,null,15,7]`，其层序遍历结果为 `[[3],[9,20],[15,7]]`。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%9E%E6%BA%AF/Images/102_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86_%E7%A4%BA%E4%BE%8B1.jpg)

- **示例2**：只有一个节点 `[1]`，结果为 `[[1]]`。

- **示例3**：空树 `[]`，结果为 `[]`。

## **数据范围**

- 树中节点数目在 `[0, 2000]` 范围内。
- 节点值的范围在 `-1000` 到 `1000` 之间。



# 二、解题思路\解题过程

这道题参考灵神的视频讲解——[二叉树的层序遍历【基础算法精讲 13】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hG4y1277i/?vd_source=12bf3ca6137fdd845e5fdc4e85bccc36)！（灵神视频中采用的是Python，我们可以用其他编程语言来写，进一步加深对题目的理解和学习！）

代码如下：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> value = new ArrayList<>();
        if(root == null){
            return value;
        }
        Queue<TreeNode> qRoot = new LinkedList<>();
        qRoot.offer(root);

        while(!qRoot.isEmpty()){
            int size = qRoot.size();
            List<Integer> flag = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = qRoot.poll();
                flag.add(node.val);
                if(node.left != null){
                    qRoot.add(node.left);
                }
                if(node.right != null){
                    qRoot.add(node.right);
                }
            }
            value.add(flag);
        }
        return value;
    }
}
```



# 三、代码演示

## Java代码

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> value = new ArrayList<>();
        if(root == null){
            return value;
        }
        Queue<TreeNode> qRoot = new LinkedList<>();
        qRoot.offer(root);

        while(!qRoot.isEmpty()){
            int size = qRoot.size();
            List<Integer> flag = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode node = qRoot.poll();
                flag.add(node.val);
                if(node.left != null){
                    qRoot.add(node.left);
                }
                if(node.right != null){
                    qRoot.add(node.right);
                }
            }
            value.add(flag);
        }
        return value;
    }
}
```



## Python代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None :
            return []
        value, current = [], [root]
        while current:
            nxt = []
            flag = []
            for node in current :
                flag.append(node.val)
                if node.left : nxt.append(node.left)
                if node.right : nxt.append(node.right)
            current = nxt
            value.append(flag)
        return value
```



## C++代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr){
            return result;
        }

        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()){
            int size = q.size();
            vector<int> currentLevel;

            for(int i = 0; i < size; i++){
                TreeNode* node = q.front();
                q.pop();
                currentLevel.push_back(node->val);

                if(node->left != nullptr){
                    q.push(node->left);
                }
                if(node->right != nullptr){
                    q.push(node->right);
                }
            }

            result.push_back(currentLevel);
        }
        return result;
    }
};
```

![102_二叉树的层序遍历_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%9E%E6%BA%AF/Images/102_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86_C++.png)