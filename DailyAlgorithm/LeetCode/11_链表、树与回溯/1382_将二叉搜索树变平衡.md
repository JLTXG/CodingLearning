æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[1382. å°†äºŒå‰æœç´¢æ ‘å˜å¹³è¡¡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/balance-a-binary-search-tree/description/?envType=daily-question&envId=2026-02-09)

>æ ‡ç­¾ï¼šé«˜çº§å·¥ç¨‹å¸ˆ  |  è´ªå¿ƒ  |  æ ‘  |  æ·±åº¦ä¼˜å…ˆæœç´¢  |  äºŒå‰æœç´¢æ ‘  |  åˆ†æ²»  |  äºŒå‰æ ‘

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œå…¶èŠ‚ç‚¹å€¼äº’ä¸ç›¸åŒã€‚è¦æ±‚ä½ æ„é€ ä¸€æ£µæ–°çš„å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ–°æ ‘åŒ…å«åŸæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼ï¼Œä¸”æ»¡è¶³å¹³è¡¡æ¡ä»¶ï¼šå¯¹äºæ ‘ä¸­ä»»æ„èŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ã€‚å¦‚æœæœ‰å¤šç§å¯èƒ½çš„å¹³è¡¡BSTï¼Œè¿”å›ä»»æ„ä¸€ç§å³å¯ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼šè¾“å…¥ä¸€æ£µä¸¥é‡ä¸å¹³è¡¡çš„BSTï¼ˆä¾‹å¦‚ä¸€æ¡é“¾ï¼‰ï¼Œéœ€è¦é‡æ„ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡çš„BSTï¼Œè¾“å‡ºå¯èƒ½æœ‰å¤šé‡å½¢å¼ï¼Œå‡è¢«æ¥å—ã€‚
- **ç¤ºä¾‹2**ï¼šå¦‚æœè¾“å…¥å·²ç»æ˜¯å¹³è¡¡çš„ï¼Œåˆ™ç›´æ¥è¿”å›åŸæ ‘ã€‚

## **æ•°æ®èŒƒå›´**

- æ ‘ä¸­èŠ‚ç‚¹æ•°åœ¨ `[1, 10^4]` èŒƒå›´å†…ã€‚
- èŠ‚ç‚¹å€¼åœ¨ `1` åˆ° `10^5` ä¹‹é—´ã€‚



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„ä»£ç 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    /**
     * ä¸»å‡½æ•°ï¼šå°†ä¸€ä¸ªå¯èƒ½ä¸å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„ BSTã€‚
     * æ€è·¯ï¼šä¸­åºéå†å¾—åˆ°æœ‰åºæ•°ç»„ â†’ ç”¨æœ‰åºæ•°ç»„æ„å»ºå¹³è¡¡ BSTã€‚
     */
    public TreeNode balanceBST(TreeNode root) {
        // ç¬¬ä¸€æ­¥ï¼šå¯¹åŸ BST è¿›è¡Œä¸­åºéå†ï¼Œå¾—åˆ°å‡åºæ’åˆ—çš„èŠ‚ç‚¹å€¼åˆ—è¡¨
        List<Integer> nums = inorderTraversal(root);
        
        // ç¬¬äºŒæ­¥ï¼šå°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„ BST
        return sortedArrayToBST(nums);
    }

    /**
     * ä¸­åºéå† BSTï¼Œè¿”å›å‡åºçš„èŠ‚ç‚¹å€¼åˆ—è¡¨ã€‚
     * å› ä¸º BST çš„ä¸­åºéå†ç»“æœå¤©ç„¶æœ‰åºã€‚
     */
    private List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(ans, root);  // æ‰§è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆä¸­åºï¼‰
        return ans;
    }
    
    /**
     * æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰å®ç°ä¸­åºéå†ã€‚
     * éå†é¡ºåºï¼šå·¦å­æ ‘ â†’ æ ¹èŠ‚ç‚¹ â†’ å³å­æ ‘
     */
    private void dfs(List<Integer> ans, TreeNode node) {
        if (node == null) {
            return;  // ç©ºèŠ‚ç‚¹ç›´æ¥è¿”å›
        }
        dfs(ans, node.left);   // é€’å½’éå†å·¦å­æ ‘
        ans.add(node.val);     // è®¿é—®æ ¹èŠ‚ç‚¹ï¼ˆå°†å€¼åŠ å…¥åˆ—è¡¨ï¼‰
        dfs(ans, node.right);  // é€’å½’éå†å³å­æ ‘
    }

    /**
     * å°†ä¸€ä¸ªå‡åºæ•°ç»„è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚
     * æ ¸å¿ƒï¼šæ¯æ¬¡é€‰æ‹©ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹ï¼Œä¿è¯å·¦å³å­æ ‘èŠ‚ç‚¹æ•°å°½å¯èƒ½ç›¸ç­‰ã€‚
     */
    private TreeNode sortedArrayToBST(List<Integer> nums) {
        // è°ƒç”¨è¾…åŠ©å‡½æ•°ï¼ŒåŒºé—´ä¸º [0, nums.size())
        return buildBST(nums, 0, nums.size());
    }

    /**
     * é€’å½’æ„å»ºå¹³è¡¡ BSTã€‚
     * å‚æ•°ï¼š
     *   - nums: å‡åºæ•°ç»„
     *   - left: å½“å‰å­æ•°ç»„å·¦è¾¹ç•Œï¼ˆåŒ…å«ï¼‰
     *   - right: å½“å‰å­æ•°ç»„å³è¾¹ç•Œï¼ˆä¸åŒ…å«ï¼‰
     * è¿”å›ï¼šä»¥ nums[left:right] æ„å»ºçš„å¹³è¡¡ BST çš„æ ¹èŠ‚ç‚¹
     */
    private TreeNode buildBST(List<Integer> nums, int left, int right) {
        // åŸºçº¿æ¡ä»¶ï¼šåŒºé—´ä¸ºç©ºï¼Œè¿”å› null
        if (left == right) {
            return null;
        }
        
        // é€‰æ‹©ä¸­é—´ä½ç½®ä½œä¸ºæ ¹ï¼ˆä½¿ç”¨æ— ç¬¦å·å³ç§»é¿å…æ•´æ•°æº¢å‡ºï¼‰
        // (left + right) >>> 1 ç­‰ä»·äº (left + right) / 2ï¼Œä½†æ›´å®‰å…¨
        int m = (left + right) >>> 1;
        
        // åˆ›å»ºæ ¹èŠ‚ç‚¹ï¼š
        //   - å€¼ä¸º nums[m]
        //   - å·¦å­æ ‘ç”± [left, m) æ„å»º
        //   - å³å­æ ‘ç”± [m+1, right) æ„å»º
        return new TreeNode(
            nums.get(m),
            buildBST(nums, left, m),       // å·¦å­æ ‘
            buildBST(nums, m + 1, right)   // å³å­æ ‘
        );
    }
}
```

---

## ğŸ§  æ ¸å¿ƒè§£é¢˜æ€æƒ³åˆ†æ

### ğŸ” é—®é¢˜ç›®æ ‡ï¼š

ç»™å®šä¸€æ£µ**äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰**ï¼ˆä¸ä¸€å®šæ˜¯å¹³è¡¡çš„ï¼‰ï¼Œå°†å…¶**é‡æ„ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡çš„ BST**ã€‚

> **é«˜åº¦å¹³è¡¡**å®šä¹‰ï¼šæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡ 1ã€‚

---

### ğŸ’¡ å…³é”®æ´å¯Ÿï¼š

#### 1ï¸âƒ£ **BST çš„ä¸­åºéå† = å‡åºæ•°ç»„**

- è¿™æ˜¯ BST çš„åŸºæœ¬æ€§è´¨ã€‚
- æ— è®ºåŸæ ‘æ˜¯å¦å¹³è¡¡ï¼Œä¸­åºéå†éƒ½èƒ½å¾—åˆ°ä¸€ä¸ª**ä¸¥æ ¼é€’å¢çš„åºåˆ—**ã€‚

#### 2ï¸âƒ£ **æœ‰åºæ•°ç»„ â†’ å¹³è¡¡ BST çš„æ ‡å‡†æ–¹æ³•**

- è¦æ„é€ **é«˜åº¦å¹³è¡¡**çš„ BSTï¼Œå¿…é¡»è®©å·¦å³å­æ ‘çš„èŠ‚ç‚¹æ•°é‡å°½å¯èƒ½ç›¸ç­‰ã€‚
- æœ€ä¼˜ç­–ç•¥ï¼š**æ¯æ¬¡é€‰ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹**ã€‚
    - å·¦åŠéƒ¨åˆ† â†’ æ„å»ºå·¦å­æ ‘
    - å³åŠéƒ¨åˆ† â†’ æ„å»ºå³å­æ ‘
- è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„**åˆ†æ²»ï¼ˆDivide and Conquerï¼‰** æ€æƒ³ã€‚

#### 3ï¸âƒ£ **ä¸ºä»€ä¹ˆè¿™æ ·èƒ½ä¿è¯å¹³è¡¡ï¼Ÿ**

- æ¯æ¬¡åˆ’åˆ†éƒ½è¿‘ä¼¼å‡åˆ†æ•°ç»„ï¼Œé€’å½’æ·±åº¦ä¸º `O(log n)`
- æ¯ä¸ªå­æ ‘çš„å·¦å³èŠ‚ç‚¹æ•°æœ€å¤šç›¸å·® 1 â†’ é«˜åº¦å·® â‰¤ 1 â†’ æ»¡è¶³å¹³è¡¡æ¡ä»¶

---

### ğŸ”„ æ•´ä½“æµç¨‹ï¼ˆä¸¤æ­¥èµ°ï¼‰ï¼š

| æ­¥éª¤       | æ“ä½œ                                 | ç›®çš„                        |
| ---------- | ------------------------------------ | --------------------------- |
| **Step 1** | ä¸­åºéå†åŸ BST â†’ å¾—åˆ°æœ‰åºæ•°ç»„ `nums` | åˆ©ç”¨ BST æ€§è´¨æå–æ‰€æœ‰èŠ‚ç‚¹å€¼ |
| **Step 2** | ç”¨ `nums` é€’å½’æ„å»ºå¹³è¡¡ BST           | é€šè¿‡â€œé€‰ä¸­ç‚¹ä¸ºæ ¹â€ç¡®ä¿å¹³è¡¡    |

> âœ… æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼ˆéå† + æ„å»ºå„ O(n)ï¼‰  
> âœ… ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼ˆå­˜å‚¨æ•°ç»„ + é€’å½’æ ˆ O(log n)ï¼‰

---

### ğŸŒ° ä¸¾ä¸ªä¾‹å­ï¼š

åŸ BSTï¼ˆä¸å¹³è¡¡ï¼‰ï¼š

```
    1
     \
      2
       \
        3
         \
          4
```

1. ä¸­åºéå† â†’ `[1, 2, 3, 4]`
2. æ„å»ºå¹³è¡¡ BSTï¼š
    - é€‰ `2` ä¸ºæ ¹ï¼ˆä¸­é—´ï¼‰
    - å·¦ï¼š`[1]` â†’ èŠ‚ç‚¹ 1
    - å³ï¼š`[3,4]` â†’ é€‰ `3` ä¸ºæ ¹ï¼Œå³å­ä¸º `4`

ç»“æœï¼š

```
      2
     / \
    1   3
         \
          4
```

æˆ–æ›´å¹³è¡¡çš„ç‰ˆæœ¬ï¼ˆå–å†³äºä¸­ç‚¹é€‰æ‹©ï¼‰ï¼š

```
      3
     / \
    2   4
   /
  1
```

> å®é™…ä¸Šï¼Œå½“æ•°ç»„é•¿åº¦ä¸ºå¶æ•°æ—¶ï¼Œé€‰å·¦ä¸­æˆ–å³ä¸­éƒ½åˆæ³•ï¼Œåªè¦ä¿æŒä¸€è‡´å³å¯ã€‚æœ¬é¢˜é‡‡ç”¨ `(left + right) >>> 1` æ˜¯**å·¦ä¸­ä½æ•°**ï¼ˆå‘ä¸‹å–æ•´ï¼‰ã€‚

---

## ğŸ“š ç¬”è®°æ€»ç»“

### ğŸ§© æ ¸å¿ƒæ€æƒ³ï¼š

> **â€œBST â†’ æœ‰åºæ•°ç»„ â†’ å¹³è¡¡ BSTâ€ ä¸¤æ­¥è½¬æ¢æ³•**

1. **åˆ©ç”¨ BST ä¸­åºéå†çš„æœ‰åºæ€§**ï¼Œå°†æ ‘å±•å¹³ä¸ºå‡åºæ•°ç»„ï¼›
2. **ç”¨åˆ†æ²»æ³•é‡å»º BST**ï¼šæ¯æ¬¡å–æ•°ç»„ä¸­ç‚¹ä½œä¸ºæ ¹ï¼Œé€’å½’æ„å»ºå·¦å³å­æ ‘ã€‚

### âœ… ç®—æ³•æ­¥éª¤ï¼š

1. å¯¹åŸ BST è¿›è¡Œ**ä¸­åºéå†**ï¼Œå¾—åˆ°å‡åºåˆ—è¡¨ `nums`ï¼›
2. è°ƒç”¨ `sortedArrayToBST(nums)`ï¼š
    - è‹¥åŒºé—´ä¸ºç©ºï¼Œè¿”å› `null`ï¼›
    - å¦åˆ™ï¼Œå–ä¸­ç‚¹ `m = (left + right) / 2`ï¼›
    - ä»¥ `nums[m]` ä¸ºæ ¹ï¼Œé€’å½’æ„å»ºå·¦å³å­æ ‘ã€‚

### â±ï¸ å¤æ‚åº¦åˆ†æï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n)  
    ï¼ˆä¸­åºéå† O(n) + æ„å»ºæ ‘ O(n)ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)  
    ï¼ˆå­˜å‚¨æ•°ç»„ O(n)ï¼Œé€’å½’æ ˆ O(log n)ï¼‰

### ğŸ’¡ å…³é”®æŠ€å·§ï¼š

- **ä¸­åºéå† = BST çš„â€œåºåˆ—åŒ–â€**
- **æœ‰åºæ•°ç»„è½¬å¹³è¡¡ BST = ç»å…¸åˆ†æ²»æ¨¡æ¿**
- ä½¿ç”¨ `(left + right) >>> 1` é¿å…æ•´æ•°æº¢å‡ºï¼ˆæ¯” `/2` æ›´å®‰å…¨ï¼‰

### â— æ³¨æ„äº‹é¡¹ï¼š

- ä¸éœ€è¦ä¿®æ”¹åŸæ ‘ç»“æ„ï¼Œç›´æ¥è¿”å›æ–°æ ‘ï¼›
- æ–°æ ‘å¿…é¡»ä»æ˜¯ BSTï¼ˆæœ¬æ–¹æ³•å¤©ç„¶æ»¡è¶³ï¼Œå› ä¸ºä¸­åºæœ‰åº + ä¸­ç‚¹åˆ†å‰²ï¼‰ï¼›
- å¹³è¡¡å®šä¹‰ï¼šä»»æ„èŠ‚ç‚¹å·¦å³å­æ ‘é«˜åº¦å·® â‰¤ 1ã€‚

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode balanceBST(TreeNode root) {
        List<Integer> nums = inorderTraversal(root);
        return sortedArrayToBST(nums);
    }

    private List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(ans, root);
        return ans;
    }
    
    private void dfs(List<Integer> ans, TreeNode node) {
        if (node == null) {
            return;
        }
        dfs(ans, node.left);  // å·¦
        ans.add(node.val);    // æ ¹ï¼ˆè¿™è¡Œä»£ç ç§»åˆ°å‰é¢å°±æ˜¯å‰åºï¼Œç§»åˆ°åé¢å°±æ˜¯ååºï¼‰
        dfs(ans, node.right); // å³
    }

    private TreeNode sortedArrayToBST(List<Integer> nums) {
        return buildBST(nums, 0, nums.size());
    }

    private TreeNode buildBST(List<Integer> nums, int left, int right) {
        if (left == right) {
            return null;
        }
        int m = (left + right) >>> 1;
        return new TreeNode(nums.get(m), buildBST(nums, left, m), buildBST(nums, m + 1, right));
    }
}
```



## Pythonä»£ç 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def balanceBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        nums = self.inorderTraversal(root)
        return self.sortedArrayToBST(nums)
    
    def inorderTraversal(self, root):
        ans = []
        self.dfs(ans, root)
        return ans
    
    def dfs(self, ans, node):
        if node is None:
            return
        self.dfs(ans, node.left)
        ans.append(node.val)
        self.dfs(ans, node.right)

    def sortedArrayToBST(self, nums):
        return self.buildBST(nums, 0, len(nums))
    
    def buildBST(self, nums, left, right):
        if left == right:
            return None
        m = (left + right) >> 1
        return TreeNode(
            nums[m],
            self.buildBST(nums, left, m),
            self.buildBST(nums, m + 1, right)
        )
```

![1382_å°†äºŒå‰æœç´¢æ ‘å˜å¹³è¡¡_Python]()

## C++ä»£ç 

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* balanceBST(TreeNode* root) {
        vector<int> nums = inorderTraversal(root);
        return sortedArrayToBST(nums);
    }

private:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        dfs(ans, root);
        return ans;
    }

    void dfs(vector<int>& ans, TreeNode* node) {
        if (node == nullptr) {
            return;
        }
        dfs(ans, node->left);   // å·¦
        ans.push_back(node->val); // æ ¹
        dfs(ans, node->right);  // å³
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildBST(nums, 0, nums.size());
    }

    TreeNode* buildBST(vector<int>& nums, int left, int right) {
        if (left == right) {
            return nullptr;
        }
        int m = (left + right) >> 1;  // æ— ç¬¦å·å³ç§»åœ¨éè´Ÿæ•°ä¸‹ç­‰ä»·äº /2
        TreeNode* root = new TreeNode(nums[m]);
        root->left = buildBST(nums, left, m);
        root->right = buildBST(nums, m + 1, right);
        return root;
    }
};
```

