æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[110. å¹³è¡¡äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/balanced-binary-tree/description/?envType=daily-question&envId=2026-02-08)

>æ ‡ç­¾ï¼šæ ‘  |  æ·±åº¦ä¼˜å…ˆæœç´¢  |  äºŒå‰æ ‘

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œåˆ¤æ–­è¯¥äºŒå‰æ ‘æ˜¯å¦ä¸º**å¹³è¡¡äºŒå‰æ ‘**ã€‚å¹³è¡¡äºŒå‰æ ‘çš„å®šä¹‰ä¸ºï¼šå¯¹äºæ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦å·®ï¼ˆæ·±åº¦å·®ï¼‰çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œä¸”å…¶å·¦å­æ ‘å’Œå³å­æ ‘ä¹Ÿéƒ½æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼šè¾“å…¥ `root = [3,9,20,null,null,15,7]`ï¼Œè¾“å‡º `true`ã€‚
- **ç¤ºä¾‹2**ï¼šè¾“å…¥ `root = [1,2,2,3,3,null,null,4,4]`ï¼Œè¾“å‡º `false`ã€‚
- **ç¤ºä¾‹3**ï¼šè¾“å…¥ `root = []`ï¼ˆç©ºæ ‘ï¼‰ï¼Œè¾“å‡º `true`ã€‚

## **æ•°æ®èŒƒå›´**

- æ ‘ä¸­èŠ‚ç‚¹æ•°åœ¨ `[0, 5000]` èŒƒå›´å†…ã€‚
- èŠ‚ç‚¹å€¼åœ¨ `-10^4` åˆ° `10^4` ä¹‹é—´ã€‚



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## ğŸ§© é¢˜ç›®è¦æ±‚å›é¡¾

> ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯ **é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘**ã€‚
>
> **é«˜åº¦å¹³è¡¡å®šä¹‰**ï¼šå¯¹äºæ ‘ä¸­çš„ **æ¯ä¸€ä¸ªèŠ‚ç‚¹**ï¼Œå…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ **ä¸è¶…è¿‡ 1**ã€‚

âœ… ç¤ºä¾‹ï¼š

- `[3,9,20,null,null,15,7]` â†’ æ˜¯å¹³è¡¡çš„
- `[1,2,2,3,3,null,null,4,4]` â†’ ä¸æ˜¯å¹³è¡¡çš„ï¼ˆæŸèŠ‚ç‚¹å·¦å³é«˜åº¦å·®ä¸º 2ï¼‰

---

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„ä»£ç 

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // ä¸»å‡½æ•°ï¼šåˆ¤æ–­æ•´æ£µæ ‘æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘
    bool isBalanced(TreeNode* root) {
        // è°ƒç”¨è¾…åŠ©å‡½æ•°ï¼Œè‹¥è¿”å› -1 è¡¨ç¤ºä¸å¹³è¡¡ï¼›å¦åˆ™è¿”å›çš„æ˜¯æ ‘çš„é«˜åº¦ï¼ˆâ‰¥0ï¼‰
        return myIsBalanced(root) != -1;
    }

private:
    // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä»¥ node ä¸ºæ ¹çš„å­æ ‘çš„é«˜åº¦
    // å¦‚æœè¯¥å­æ ‘æ˜¯å¹³è¡¡çš„ï¼Œåˆ™è¿”å›å…¶é«˜åº¦ï¼ˆâ‰¥0ï¼‰
    // å¦‚æœä¸å¹³è¡¡ï¼Œåˆ™è¿”å› -1ï¼ˆä½œä¸ºâ€œä¸å¹³è¡¡â€çš„æ ‡è®°ï¼‰
    int myIsBalanced(TreeNode* node) {
        // ç©ºèŠ‚ç‚¹ï¼šé«˜åº¦ä¸º 0ï¼Œä¸”å¤©ç„¶å¹³è¡¡
        if (node == nullptr) {
            return 0;
        }

        // é€’å½’è·å–å·¦å­æ ‘çš„é«˜åº¦ï¼ˆæˆ– -1 è¡¨ç¤ºä¸å¹³è¡¡ï¼‰
        int mLeft = myIsBalanced(node->left);

        // é€’å½’è·å–å³å­æ ‘çš„é«˜åº¦ï¼ˆæˆ– -1 è¡¨ç¤ºä¸å¹³è¡¡ï¼‰
        int mRight = myIsBalanced(node->right);

        // åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦â€œç ´åâ€äº†å¹³è¡¡æ€§ï¼š
        // æƒ…å†µ1ï¼šå·¦å­æ ‘å·²ä¸å¹³è¡¡ï¼ˆmLeft == -1ï¼‰
        // æƒ…å†µ2ï¼šå³å­æ ‘å·²ä¸å¹³è¡¡ï¼ˆmRight == -1ï¼‰
        // æƒ…å†µ3ï¼šå·¦å³å­æ ‘éƒ½å¹³è¡¡ï¼Œä½†é«˜åº¦å·® > 1
        if (mLeft == -1 || mRight == -1 || abs(mLeft - mRight) > 1) {
            return -1;  // å½“å‰å­æ ‘ä¸å¹³è¡¡ï¼Œå‘ä¸Šè¿”å› -1
        }

        // å½“å‰èŠ‚ç‚¹å¹³è¡¡ï¼Œè¿”å›è¯¥å­æ ‘çš„é«˜åº¦ = max(å·¦é«˜, å³é«˜) + 1
        return max(mLeft, mRight) + 1;
    }
};
```

---

## ğŸ” æ ¸å¿ƒè§£é¢˜æ€æƒ³åˆ†æ

### âŒ ä½æ•ˆåšæ³•ï¼ˆè‡ªé¡¶å‘ä¸‹ï¼‰ï¼š

å¯¹æ¯ä¸ªèŠ‚ç‚¹éƒ½å•ç‹¬è®¡ç®—å·¦å³å­æ ‘é«˜åº¦ï¼š

```cpp
int getHeight(TreeNode* node) { ... }
bool isBalanced(TreeNode* root) {
    if (!root) return true;
    return abs(getHeight(root->left) - getHeight(root->right)) <= 1
           && isBalanced(root->left)
           && isBalanced(root->right);
}
```

- **é—®é¢˜**ï¼šå¤§é‡é‡å¤è®¡ç®—ï¼æ¯ä¸ªèŠ‚ç‚¹çš„é«˜åº¦è¢«å¤šæ¬¡æ±‚å–ã€‚
- **æ—¶é—´å¤æ‚åº¦**ï¼šæœ€å O(nÂ²)ï¼ˆå¦‚é€€åŒ–ä¸ºé“¾è¡¨ï¼‰

---

### âœ… é«˜æ•ˆåšæ³•ï¼ˆè‡ªåº•å‘ä¸Š + ååºéå†ï¼‰

#### å…³é”®æ€æƒ³ï¼š

> **åœ¨ä¸€æ¬¡ååºéå†ä¸­ï¼ŒåŒæ—¶å®Œæˆâ€œè®¡ç®—é«˜åº¦â€å’Œâ€œåˆ¤æ–­å¹³è¡¡â€ä¸¤ä»¶äº‹**ã€‚

#### ä¸ºä»€ä¹ˆæœ‰æ•ˆï¼Ÿ

- **ååºéå†é¡ºåº**ï¼šå…ˆå¤„ç†å·¦å³å­æ ‘ï¼Œå†å¤„ç†å½“å‰èŠ‚ç‚¹ â†’ è‡ªç„¶çŸ¥é“å­æ ‘ä¿¡æ¯
- **ä¿¡æ¯å¤ç”¨**ï¼šå­æ ‘é«˜åº¦åœ¨é€’å½’è¿”å›æ—¶ç›´æ¥ä¼ é€’ï¼Œæ— éœ€é‡å¤è®¡ç®—
- **å‰ªæä¼˜åŒ–**ï¼šä¸€æ—¦å‘ç°æŸä¸ªå­æ ‘ä¸å¹³è¡¡ï¼ˆè¿”å› -1ï¼‰ï¼Œç«‹å³å‘ä¸Šä¼ æ’­ï¼Œä¸å†ç»§ç»­æ— æ„ä¹‰çš„é€’å½’

#### æ—¶é—´å¤æ‚åº¦ï¼š

- æ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ â†’ **O(n)**
- ç©ºé—´å¤æ‚åº¦ï¼š**O(h)**ï¼ˆh ä¸ºæ ‘é«˜ï¼Œé€’å½’è°ƒç”¨æ ˆï¼‰

---

## ğŸ“Œ ç¬”è®°é‡ç‚¹æ€»ç»“

### âœ… æ–¹æ³•åç§°ï¼š

> **è‡ªåº•å‘ä¸Šçš„ååºéå† + å“¨å…µå€¼å‰ªæ**

### âœ… æ ¸å¿ƒæŠ€å·§ï¼š

1. **ä¸€ä¸ªå‡½æ•°å¹²ä¸¤ä»¶äº‹**ï¼šæ—¢è¿”å›é«˜åº¦ï¼Œåˆéšå¼ä¼ é€’å¹³è¡¡çŠ¶æ€
2. **ç”¨ -1 ä½œä¸ºâ€œä¸å¹³è¡¡â€çš„å“¨å…µå€¼**ï¼Œé¿å…é¢å¤–å¸ƒå°”å‚æ•°
3. **ååºéå†å¤©ç„¶é€‚åˆâ€œå­é—®é¢˜å…ˆè§£å†³â€ç±»é—®é¢˜**

### âœ… è¿”å›å€¼å«ä¹‰ï¼š

| è¿”å›å€¼ | å«ä¹‰                     |
| ------ | ------------------------ |
| â‰¥ 0    | å­æ ‘å¹³è¡¡ï¼Œä¸”å€¼ä¸ºå­æ ‘é«˜åº¦ |
| -1     | å­æ ‘ä¸å¹³è¡¡               |

### âœ… ç±»ä¼¼é¢˜å‹ï¼š

- LeetCode 543. äºŒå‰æ ‘çš„ç›´å¾„ï¼ˆè¿”å›æ·±åº¦+æ›´æ–°å…¨å±€ç­”æ¡ˆï¼‰
- LeetCode 124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œï¼ˆè¿”å›å•è¾¹æœ€å¤§è·¯å¾„+æ›´æ–°å…¨å±€ï¼‰

---

## âœ… ä¸€å¥è¯ç»ˆæç¬”è®°

> **åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘åº”é‡‡ç”¨â€œè‡ªåº•å‘ä¸Šååºéå†â€ï¼Œç”¨ -1 æ ‡è®°ä¸å¹³è¡¡çŠ¶æ€ï¼Œåœ¨ O(n) æ—¶é—´å†…ä¸€æ¬¡æ€§å®Œæˆé«˜åº¦è®¡ç®—ä¸å¹³è¡¡éªŒè¯ã€‚**

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        return myIsBalanced(root) != -1;
    }
    private int myIsBalanced(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int mLeft = myIsBalanced(node.left);
        int mRight = myIsBalanced(node.right);
        if (mLeft == -1 || mRight == -1 || Math.abs(mLeft - mRight) > 1) {
            return -1;
        }
        return Math.max(mLeft, mRight) + 1;
    }
}
```



## Pythonä»£ç 

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def myIsBalanced(node: Optional[TreeNode]) -> int:
            if node is None:
                return 0
            n_left = myIsBalanced(node.left)
            n_right = myIsBalanced(node.right)
            if n_left == -1 or n_right == -1 or abs(n_left - n_right) > 1:
                return -1
            return max(n_left, n_right) + 1
        return myIsBalanced(root) != -1
```



## C++ä»£ç 

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return myIsBalanced(root) != -1;
    }

private:
    int myIsBalanced(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        int mLeft = myIsBalanced(node->left);
        int mRight = myIsBalanced(node->right);
        if (mLeft == -1 || mRight == -1 || abs(mLeft - mRight) > 1) {
            return -1;
        }
        return max(mLeft, mRight) + 1;
    }
};
```

![110_å¹³è¡¡äºŒå‰æ ‘_C++]()