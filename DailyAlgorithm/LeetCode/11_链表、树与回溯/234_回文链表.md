æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[525. è¿ç»­æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/contiguous-array/description/)

>æ ‡ç­¾ï¼šæ ˆ  |  é€’å½’  |  é“¾è¡¨  |  åŒæŒ‡é’ˆ

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œè¯·åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ï¼ˆå³æ­£åºéå†å’Œé€†åºéå†å¾—åˆ°çš„èŠ‚ç‚¹å€¼åºåˆ—ç›¸åŒï¼‰ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- è¾“å…¥ï¼š`head = [1,2,2,1]`ï¼Œè¾“å‡ºï¼š`true`
- è¾“å…¥ï¼š`head = [1,2]`ï¼Œè¾“å‡ºï¼š`false`

## **æ•°æ®èŒƒå›´**

- é“¾è¡¨èŠ‚ç‚¹æ•°åœ¨ `[1, 10^5]` èŒƒå›´å†…
- èŠ‚ç‚¹å€¼åœ¨ `0` åˆ° `9` ä¹‹é—´

## **è¿›é˜¶è¦æ±‚**

èƒ½å¦åœ¨ O(n) æ—¶é—´å¤æ‚åº¦å’Œ O(1) ç©ºé—´å¤æ‚åº¦å†…è§£å†³ï¼Ÿ



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„ä»£ç 

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        // è¾¹ç•Œæƒ…å†µï¼šç©ºé“¾è¡¨æˆ–å•èŠ‚ç‚¹é“¾è¡¨ï¼Œè§†ä¸ºå›æ–‡
        if (head == null || head.next == null) return true;

        // 1ï¸âƒ£ ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹
        // - slow æ¯æ¬¡èµ° 1 æ­¥
        // - fast æ¯æ¬¡èµ° 2 æ­¥
        // å½“ fast åˆ°è¾¾æœ«å°¾æ—¶ï¼Œslow æ°å¥½åœ¨ä¸­é—´ï¼ˆæˆ–ååŠéƒ¨åˆ†èµ·ç‚¹ï¼‰
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;         // æ…¢æŒ‡é’ˆå‰è¿›ä¸€æ­¥
            fast = fast.next.next;    // å¿«æŒ‡é’ˆå‰è¿›ä¸¤æ­¥
        }
        // æ­¤æ—¶ï¼š
        // - è‹¥é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼ˆå¦‚ 5ï¼‰ï¼Œslow æŒ‡å‘ç¬¬ 3 ä¸ªèŠ‚ç‚¹ï¼ˆä¸­å¿ƒï¼‰
        // - è‹¥ä¸ºå¶æ•°ï¼ˆå¦‚ 4ï¼‰ï¼Œslow æŒ‡å‘ç¬¬ 3 ä¸ªèŠ‚ç‚¹ï¼ˆååŠéƒ¨åˆ†èµ·ç‚¹ï¼‰

        // 2ï¸âƒ£ åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ï¼ˆä» slow å¼€å§‹ï¼‰
        ListNode prev = null;  // åè½¬åçš„å¤´èŠ‚ç‚¹ï¼ˆåˆå§‹ä¸º nullï¼‰
        while (slow != null) {
            ListNode nextNode = slow.next;  // ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé˜²æ­¢æ–­é“¾
            slow.next = prev;               // å°†å½“å‰èŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆåè½¬ï¼‰
            prev = slow;                    // prev å‰ç§»
            slow = nextNode;                // slow ç»§ç»­éå†åŸé“¾è¡¨
        }
        // å¾ªç¯ç»“æŸåï¼Œprev æŒ‡å‘åŸé“¾è¡¨ååŠéƒ¨åˆ†åè½¬åçš„å¤´èŠ‚ç‚¹

        // 3ï¸âƒ£ æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†
        ListNode left = head;   // å‰åŠéƒ¨åˆ†å¤´èŠ‚ç‚¹
        ListNode right = prev;  // åè½¬åçš„ååŠéƒ¨åˆ†å¤´èŠ‚ç‚¹
        while (right != null) { // åªéœ€éå†ååŠéƒ¨åˆ†ï¼ˆé•¿åº¦ â‰¤ å‰åŠéƒ¨åˆ†ï¼‰
            if (left.val != right.val) {
                return false;  // å‘ç°ä¸åŒ¹é…ï¼Œä¸æ˜¯å›æ–‡
            }
            left = left.next;
            right = right.next;
        }

        // æ‰€æœ‰èŠ‚ç‚¹åŒ¹é…ï¼Œæ˜¯å›æ–‡é“¾è¡¨
        return true;
    }
}
```

---

## ğŸ§  æ ¸å¿ƒè§£é¢˜æ€æƒ³åˆ†æ

### ğŸ” é—®é¢˜ç›®æ ‡ï¼š

åˆ¤æ–­ä¸€ä¸ªå•é“¾è¡¨æ˜¯å¦ä¸º**å›æ–‡é“¾è¡¨**ï¼ˆæ­£è¯»å’Œåè¯»ç›¸åŒï¼‰ã€‚

> ä¾‹å¦‚ï¼š`1 â†’ 2 â†’ 2 â†’ 1` æ˜¯å›æ–‡ï¼›`1 â†’ 2 â†’ 3` ä¸æ˜¯ã€‚

---

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š**â€œæ‰¾ä¸­ç‚¹ + åè½¬ååŠæ®µ + åŒæŒ‡é’ˆæ¯”è¾ƒâ€**

è¿™æ˜¯**ç©ºé—´æœ€ä¼˜ï¼ˆO(1)ï¼‰** çš„ç»å…¸è§£æ³•ï¼Œåˆ†ä¸ºä¸‰æ­¥ï¼š

#### ç¬¬ä¸€æ­¥ï¼š**å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹**

- å¿«æŒ‡é’ˆ `fast` æ¯æ¬¡èµ° 2 æ­¥ï¼Œæ…¢æŒ‡é’ˆ `slow` æ¯æ¬¡èµ° 1 æ­¥ï¼›
- å½“ `fast` åˆ°è¾¾æœ«å°¾ï¼ˆ`null` æˆ–æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œ`slow` æ°å¥½åœ¨**ååŠéƒ¨åˆ†çš„èµ·ç‚¹**ï¼›
- æ— éœ€åŒºåˆ†å¥‡å¶é•¿åº¦ï¼š**ååŠéƒ¨åˆ†æ€»æ˜¯ `slow` å¼€å§‹åˆ°ç»“å°¾**ã€‚

#### ç¬¬äºŒæ­¥ï¼š**åè½¬ååŠéƒ¨åˆ†é“¾è¡¨**

- ä» `slow` å¼€å§‹ï¼ŒåŸåœ°åè½¬é“¾è¡¨ï¼›
- åè½¬åï¼Œ`prev` æˆä¸ºæ–°å¤´èŠ‚ç‚¹ï¼›
- è¿™æ ·æˆ‘ä»¬å°±èƒ½ä»ä¸¤ç«¯å‘ä¸­é—´æ¯”è¾ƒã€‚

#### ç¬¬ä¸‰æ­¥ï¼š**åŒæŒ‡é’ˆåŒæ­¥æ¯”è¾ƒ**

- `left` ä»åŸå¤´å¼€å§‹ï¼Œ`right` ä»åè½¬åçš„ååŠéƒ¨åˆ†å¤´å¼€å§‹ï¼›
- é€ä¸ªæ¯”è¾ƒå€¼ï¼Œåªè¦æœ‰ä¸€ä¸ªä¸åŒå°±è¿”å› `false`ï¼›
- ç”±äºååŠéƒ¨åˆ†é•¿åº¦ â‰¤ å‰åŠéƒ¨åˆ†ï¼Œåªéœ€éå† `right != null` å³å¯ã€‚

> âœ… **ä¼˜ç‚¹**ï¼šåªç”¨ O(1) é¢å¤–ç©ºé—´ï¼ˆå‡ ä¸ªæŒ‡é’ˆï¼‰ï¼Œæ—¶é—´ O(n)  
> âš ï¸ **å‰¯ä½œç”¨**ï¼šåŸé“¾è¡¨è¢«ä¿®æ”¹ï¼ˆååŠéƒ¨åˆ†è¢«åè½¬ï¼‰ã€‚è‹¥é¢˜ç›®è¦æ±‚ä¸èƒ½ä¿®æ”¹ï¼Œéœ€é¢å¤–æ­¥éª¤æ¢å¤ã€‚

---

### ğŸ”„ ç¤ºä¾‹æ¼”ç¤ºï¼ˆå¶æ•°é•¿åº¦ï¼‰

åŸé“¾è¡¨ï¼š`1 â†’ 2 â†’ 2 â†’ 1`

1. **æ‰¾ä¸­ç‚¹**ï¼š
    - `slow` æœ€ç»ˆåœåœ¨ç¬¬ 3 ä¸ªèŠ‚ç‚¹ï¼ˆå€¼ä¸º 2ï¼‰
2. **åè½¬ååŠéƒ¨åˆ†**ï¼š
    - ååŠéƒ¨åˆ† `2 â†’ 1` åè½¬ä¸º `1 â†’ 2`
    - é“¾è¡¨å˜ä¸ºï¼š`1 â†’ 2 â†’ null` å’Œ `1 â†’ 2`ï¼ˆå‰åŠä¸ååŠåˆ†ç¦»ï¼‰
3. **æ¯”è¾ƒ**ï¼š
    - `left: 1, right: 1` â†’ åŒ¹é…
    - `left: 2, right: 2` â†’ åŒ¹é…
    - `right == null`ï¼Œç»“æŸ â†’ è¿”å› `true`

---

### â±ï¸ å¤æ‚åº¦åˆ†æï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n)  
    ï¼ˆæ‰¾ä¸­ç‚¹ O(n/2) + åè½¬ O(n/2) + æ¯”è¾ƒ O(n/2)ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(1)  
    ï¼ˆä»…ä½¿ç”¨å¸¸æ•°ä¸ªæŒ‡é’ˆå˜é‡ï¼‰

---

## ğŸ“š ç¬”è®°æ€»ç»“

### ğŸ§© æ ¸å¿ƒæ€æƒ³ï¼š

> **å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ + åŸåœ°åè½¬ååŠæ®µ + åŒæŒ‡é’ˆæ¯”è¾ƒ**

### âœ… ç®—æ³•æ­¥éª¤ï¼š

1. **è¾¹ç•Œå¤„ç†**ï¼šç©ºæˆ–å•èŠ‚ç‚¹ç›´æ¥è¿”å› `true`ï¼›
2. **å¿«æ…¢æŒ‡é’ˆ**ï¼š`fast` èµ°ä¸¤æ­¥ï¼Œ`slow` èµ°ä¸€æ­¥ï¼Œæ‰¾åˆ°ååŠéƒ¨åˆ†èµ·ç‚¹ï¼›
3. **åè½¬ååŠéƒ¨åˆ†**ï¼šä» `slow` å¼€å§‹åè½¬ï¼Œå¾—åˆ°æ–°å¤´ `prev`ï¼›
4. **åŒæŒ‡é’ˆæ¯”è¾ƒ**ï¼š`head` ä¸ `prev` åŒæ­¥éå†ï¼Œå€¼å¿…é¡»å…¨éƒ¨ç›¸ç­‰ã€‚

### ğŸ”‘ å…³é”®ç‚¹ï¼š

- **æ— éœ€åŒºåˆ†å¥‡å¶é•¿åº¦**ï¼šååŠéƒ¨åˆ†ç»Ÿä¸€ä» `slow` å¼€å§‹ï¼›
- **ç©ºé—´ O(1)**ï¼šä¼˜äºâ€œè½¬æ•°ç»„â€æˆ–â€œé€’å½’â€æ–¹æ³•ï¼›
- **ä¼šç ´ååŸé“¾è¡¨ç»“æ„**ï¼ˆè‹¥éœ€ä¿æŒï¼Œå¯åœ¨æ¯”è¾ƒåæ¢å¤åè½¬ï¼‰ã€‚

### â±ï¸ å¤æ‚åº¦ï¼š

- æ—¶é—´ï¼šO(n)
- ç©ºé—´ï¼šO(1)

### ğŸ’¡ å»¶ä¼¸æ€è€ƒï¼š

- è‹¥ä¸å…è®¸ä¿®æ”¹é“¾è¡¨ï¼Ÿâ†’ ç”¨æ ˆå­˜å‚¨å‰åŠéƒ¨åˆ†ï¼ˆç©ºé—´ O(n)ï¼‰ï¼›
- é€’å½’è§£æ³•ï¼Ÿâ†’ åˆ©ç”¨è°ƒç”¨æ ˆéšå¼å­˜å‚¨ï¼ˆç©ºé—´ O(n)ï¼Œä¸”å¯èƒ½æ ˆæº¢å‡ºï¼‰ã€‚

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;

        // 1. å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­å¿ƒ
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // 2. åè½¬ååŠéƒ¨åˆ†
        ListNode prev = null;
        while (slow != null) {
            ListNode nextNode = slow.next;
            slow.next = prev;
            prev = slow;
            slow = nextNode;
        }

        // 3. æ¯”è¾ƒ
        ListNode left = head, right = prev;
        while (right != null) {
            if (left.val != right.val) return false;
            left = left.next;
            right = right.next;
        }

        return true;
    }
}
```

![234_å›æ–‡é“¾è¡¨_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%9E%E6%BA%AF/Images/234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8_Java.png)

## Pythonä»£ç 

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return True
        
        # 1. å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # 2. åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
        prev = None
        while slow:
            next_node = slow.next
            slow.next = prev
            prev = slow
            slow = next_node
        
        # 3. æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†
        left, right = head, prev
        while right:  # ååŠéƒ¨åˆ†å¯èƒ½æ›´çŸ­
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        
        return True  
```



## C++ä»£ç 

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // ç©ºé“¾è¡¨æˆ–å•ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å› true
        if (!head || !head->next) {
            return true;
        }

        // 1. å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼ˆslow æœ€ç»ˆæŒ‡å‘ååŠéƒ¨åˆ†çš„å¼€å¤´ï¼‰
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 2. åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
        ListNode* prev = nullptr;
        while (slow) {
            ListNode* nextNode = slow->next;
            slow->next = prev;
            prev = slow;
            slow = nextNode;
        }

        // 3. æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†
        ListNode* left = head;
        ListNode* right = prev;  // prev ç°åœ¨æ˜¯åè½¬åååŠéƒ¨åˆ†çš„å¤´èŠ‚ç‚¹
        while (right) {  // ååŠéƒ¨åˆ†å¯èƒ½æ›´çŸ­ï¼Œä»¥å®ƒä¸ºå‡†
            if (left->val != right->val) {
                return false;
            }
            left = left->next;
            right = right->next;
        }
        
        return true;
    }
};
```

