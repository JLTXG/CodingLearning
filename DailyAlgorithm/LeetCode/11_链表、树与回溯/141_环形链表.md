æœ¬æ–‡é¢˜è§£åŸºäºä»¥ä¸‹åŸé¢˜æ•´ç†ï¼Œé¢˜æ„ç»æœ¬äººé‡æ–°è¡¨è¿°ï¼Œè§£é¢˜æ€è·¯ä¸ä»£ç å‡ä¸ºåŸåˆ›æˆ–è½¬è½½ï¼Œä»…ç”¨äºä¸ªäººå­¦ä¹ ä¸äº¤æµï¼Œå®Œæ•´é¢˜ç›®è¯·åŠ¡å¿…æŸ¥é˜…å®˜æ–¹åŸé¢˜é“¾æ¥ï¼š[141. ç¯å½¢é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)

>æ ‡ç­¾ï¼šå“ˆå¸Œè¡¨  |  é“¾è¡¨  |  åŒæŒ‡é’ˆ

# ä¸€ã€é¢˜ç›®æè¿°

## **é—®é¢˜æ¦‚æ‹¬**

ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨ç¯ã€‚ç¯çš„å®šä¹‰æ˜¯ï¼šé“¾è¡¨ä¸­æŸä¸ªèŠ‚ç‚¹çš„ `next` æŒ‡é’ˆæŒ‡å‘äº†é“¾è¡¨ä¸­åœ¨å®ƒä¹‹å‰å‡ºç°çš„æŸä¸ªèŠ‚ç‚¹ï¼Œä»è€Œå½¢æˆå¾ªç¯ã€‚å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯ï¼Œè¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

## **ç¤ºä¾‹è¯´æ˜**

- **ç¤ºä¾‹1**ï¼šé“¾è¡¨ `[3,2,0,-4]` å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼ˆç´¢å¼•ä»0å¼€å§‹ï¼‰ï¼Œå­˜åœ¨ç¯ï¼Œè¿”å› `true`ã€‚
- **ç¤ºä¾‹2**ï¼šé“¾è¡¨ `[1,2]` å°¾éƒ¨è¿æ¥åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå­˜åœ¨ç¯ï¼Œè¿”å› `true`ã€‚
- **ç¤ºä¾‹3**ï¼šé“¾è¡¨ `[1]` å°¾éƒ¨æ— è¿æ¥ï¼Œæ— ç¯ï¼Œè¿”å› `false`ã€‚

## **æ•°æ®èŒƒå›´**

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨ `[0, 10^4]` èŒƒå›´å†…ã€‚
- èŠ‚ç‚¹å€¼åœ¨ `-10^5` åˆ° `10^5` ä¹‹é—´ã€‚

## **è¿›é˜¶è¦æ±‚**

èƒ½å¦ä½¿ç”¨ O(1) çš„é¢å¤–å†…å­˜ç©ºé—´è§£å†³æ­¤é¢˜ï¼Ÿ



# äºŒã€è§£é¢˜æ€è·¯\è§£é¢˜è¿‡ç¨‹

## âœ… å¸¦è¯¦ç»†æ³¨é‡Šçš„ä»£ç 

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // è¾¹ç•Œæƒ…å†µï¼šç©ºé“¾è¡¨æˆ–å•èŠ‚ç‚¹æ— ç¯
        if (head == null || head.next == null) {
            return false;
        }

        // åˆå§‹åŒ–å¿«æ…¢æŒ‡é’ˆï¼Œéƒ½ä»å¤´èŠ‚ç‚¹å‡ºå‘
        ListNode slow = head;  // æ…¢æŒ‡é’ˆï¼šæ¯æ¬¡èµ° 1 æ­¥
        ListNode fast = head;  // å¿«æŒ‡é’ˆï¼šæ¯æ¬¡èµ° 2 æ­¥

        // å¾ªç¯æ¡ä»¶ï¼šfast å’Œ fast.next éƒ½ä¸èƒ½ä¸º nullï¼ˆå¦åˆ™ä¼šè¶Šç•Œï¼‰
        while (fast != null && fast.next != null) {
            slow = slow.next;        // æ…¢æŒ‡é’ˆå‰è¿›ä¸€æ­¥
            fast = fast.next.next;   // å¿«æŒ‡é’ˆå‰è¿›ä¸¤æ­¥

            // å¦‚æœå¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜é“¾è¡¨ä¸­å­˜åœ¨ç¯
            if (fast == slow) {
                return true;
            }
        }

        // å¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨æœ«å°¾ï¼ˆnullï¼‰ï¼Œè¯´æ˜æ— ç¯
        return false;
    }
}
```

> ğŸ’¡ æ³¨ï¼šè™½ç„¶ä»£ç ä¸­æ²¡æœ‰æ˜¾å¼å†™ `if (head == null)` çš„åˆ¤æ–­ï¼Œä½† `while` æ¡ä»¶å·²éšå«å¤„ç†â€”â€”è‹¥ `head == null`ï¼Œ`fast == null`ï¼Œå¾ªç¯ä¸æ‰§è¡Œï¼Œç›´æ¥è¿”å› `false`ã€‚

---

## ğŸ§  æ ¸å¿ƒè§£é¢˜æ€æƒ³åˆ†æ

### ğŸ” é—®é¢˜ç›®æ ‡ï¼š

åˆ¤æ–­ä¸€ä¸ªå•é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨**ç¯ï¼ˆcycleï¼‰**ã€‚

> å³ï¼šæŸä¸ªèŠ‚ç‚¹çš„ `next` æŒ‡é’ˆæŒ‡å‘äº†å‰é¢çš„æŸä¸ªèŠ‚ç‚¹ï¼Œå½¢æˆé—­ç¯ã€‚

---

### ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼š**Floyd åˆ¤åœˆç®—æ³•ï¼ˆé¾Ÿå…”èµ›è·‘ç®—æ³•ï¼‰**

- ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼š**æ…¢æŒ‡é’ˆï¼ˆslowï¼‰** å’Œ **å¿«æŒ‡é’ˆï¼ˆfastï¼‰**
    - `slow` æ¯æ¬¡èµ° 1 æ­¥
    - `fast` æ¯æ¬¡èµ° 2 æ­¥
- **å¦‚æœæœ‰ç¯**ï¼šå¿«æŒ‡é’ˆæœ€ç»ˆä¼šâ€œè¿½ä¸Šâ€æ…¢æŒ‡é’ˆï¼ˆåœ¨ç¯å†…ç›¸é‡ï¼‰
- **å¦‚æœæ²¡æœ‰ç¯**ï¼šå¿«æŒ‡é’ˆä¼šå…ˆåˆ°è¾¾é“¾è¡¨æœ«å°¾ï¼ˆ`null`ï¼‰

---

### ğŸ“ ä¸ºä»€ä¹ˆå¿«æ…¢æŒ‡é’ˆä¸€å®šèƒ½ç›¸é‡ï¼Ÿï¼ˆæ•°å­¦åŸç†ï¼‰

å‡è®¾é“¾è¡¨ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š

- **éç¯éƒ¨åˆ†**ï¼šé•¿åº¦ä¸º `a`
- **ç¯éƒ¨åˆ†**ï¼šé•¿åº¦ä¸º `b`

å½“ `slow` è¿›å…¥ç¯æ—¶ï¼Œ`fast` å·²ç»åœ¨ç¯å†…èµ°äº†è‹¥å¹²åœˆã€‚  
æ­¤æ—¶ï¼Œ`fast` å’Œ `slow` éƒ½åœ¨ç¯å†…ï¼Œä¸” `fast` æ¯æ¬¡æ¯” `slow` å¤šèµ° 1 æ­¥ã€‚

> ç›¸å¯¹é€Ÿåº¦ = 1 æ­¥/è½® â‡’ æœ€å¤š `b` æ­¥åï¼Œ`fast` ä¼šè¿½ä¸Š `slow`ã€‚

âœ… å› æ­¤ï¼Œ**åªè¦å­˜åœ¨ç¯ï¼Œå¿«æ…¢æŒ‡é’ˆå¿…å®šç›¸é‡**ã€‚

---

### ğŸ”„ ç¤ºä¾‹æ¼”ç¤º

**æœ‰ç¯æƒ…å†µ**ï¼š`1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 2ï¼ˆå›åˆ°èŠ‚ç‚¹2ï¼‰`

| æ­¥æ•° | slow | fast       |
| ---- | ---- | ---------- |
| 0    | 1    | 1          |
| 1    | 2    | 3          |
| 2    | 3    | 5          |
| 3    | 4    | 3          |
| 4    | 5    | 5 â† ç›¸é‡ï¼ |

â†’ è¿”å› `true`

**æ— ç¯æƒ…å†µ**ï¼š`1 â†’ 2 â†’ 3 â†’ null`

- `fast` ä¼šèµ°åˆ° `null`ï¼Œå¾ªç¯ç»“æŸ â†’ è¿”å› `false`

---

### â±ï¸ å¤æ‚åº¦åˆ†æï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n)
    - æ— ç¯ï¼šå¿«æŒ‡é’ˆèµ° n/2 æ­¥
    - æœ‰ç¯ï¼šæœ€å¤šèµ° a + b æ­¥ï¼ˆè¿›å…¥ç¯ + ç¯å†…è¿½ä¸Šï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(1)
    - åªç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œå¸¸æ•°ç©ºé—´

---

## ğŸ“š ç¬”è®°æ€»ç»“

### ğŸ§© æ ¸å¿ƒæ€æƒ³ï¼š

> **Floyd åˆ¤åœˆç®—æ³•ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰**

### âœ… ç®—æ³•æ­¥éª¤ï¼š

1. åˆå§‹åŒ– `slow = fast = head`ï¼›
2. å¾ªç¯ä¸­ï¼š
    - `slow = slow.next`
    - `fast = fast.next.next`
    - è‹¥ `slow == fast` â†’ æœ‰ç¯ï¼Œè¿”å› `true`
3. è‹¥ `fast` æˆ– `fast.next` ä¸º `null` â†’ æ— ç¯ï¼Œè¿”å› `false`

### ğŸ”‘ å…³é”®ç‚¹ï¼š

- **å¿«æŒ‡é’ˆå¿…é¡»èµ°ä¸¤æ­¥**ï¼ˆè‹¥èµ°ä¸‰æ­¥å¯èƒ½è·³è¿‡ç›¸é‡ç‚¹ï¼‰ï¼›
- **æ— éœ€é¢å¤–ç©ºé—´**ï¼Œä¼˜äºå“ˆå¸Œè¡¨æ–¹æ³•ï¼ˆO(n) ç©ºé—´ï¼‰ï¼›
- **æ•°å­¦ä¿è¯**ï¼šæœ‰ç¯å¿…ç›¸é‡ï¼Œæ— ç¯å¿…ç»ˆæ­¢ã€‚

### â±ï¸ å¤æ‚åº¦ï¼š

- æ—¶é—´ï¼šO(n)
- ç©ºé—´ï¼šO(1)

### ğŸ’¡ å»¶ä¼¸æ€è€ƒï¼š

- å¦‚ä½•æ‰¾**ç¯çš„å…¥å£**ï¼Ÿâ†’ ç»§ç»­ç”¨å¿«æ…¢æŒ‡é’ˆï¼ˆLeetCode 142ï¼‰
- å“ˆå¸Œè¡¨è§£æ³•ï¼Ÿâ†’ éå†å¹¶è®°å½•è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼ˆç©ºé—´ O(n)ï¼‰

---

# ä¸‰ã€ä»£ç æ¼”ç¤º

## Javaä»£ç 

```Java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
}
```

![141_ç¯å½¢é“¾è¡¨_Java](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/11_%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E4%B8%8E%E5%9B%9E%E6%BA%AF/Images/141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_Java.png)

## Pythonä»£ç 

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                return True
        return False
```



## C++ä»£ç 

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
};
```

