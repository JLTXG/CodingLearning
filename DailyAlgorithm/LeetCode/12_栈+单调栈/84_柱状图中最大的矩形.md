[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

>标签：栈  |  数组  |  单调栈

# 一、题目描述

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

**示例 1:**

![img](E:\NoteTakingSoftwares\Typora\Images\histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**示例 2：**

![img](E:\NoteTakingSoftwares\Typora\Images\histogram-1.jpg)

```
输入： heights = [2,4]
输出： 4
```

 

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`



# 二、解题思路\解题过程

以下思路转载至灵神的思路——[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/2695467/dan-diao-zhan-fu-ti-dan-pythonjavacgojsr-89s7/)，具体思路如下所示：

![84_柱状图中最大的矩形_示例1]()

首先，面积最大矩形的高度一定是 heights 中的元素。这可以用反证法证明：假如高度不在 heights 中，比如 4，那我们可以增加高度直到触及某根柱子的顶部，比如增加到 5，由于矩形底边长不变，高度增加，我们得到了面积更大的矩形，矛盾，所以面积最大矩形的高度一定是 heights 中的元素。

枚举每个 h=heights[i]，作为矩形的高。那么矩形的宽最大是多少？我们需要知道：

- 在 i 左侧的小于 h 的最近元素的下标 left，如果不存在则为 −1。求出了 left，那么 left+1 就是矩形最左边那根柱子。如果 left=−1，那么加一后是 0，就是整个 heights 最左边的柱子。
- 在 i 右侧的小于 h 的最近元素的下标 right，如果不存在则为 n。求出了 right，那么 right−1 就是矩形最右边那根柱子。如果 right=n，那么减一后是 n−1，就是整个 heights 最右边的柱子。

比如上图所示，选择 i=2 这个柱子作为矩形的高，那么左边小于 heights[2]=5 的最近元素的下标为 left=1，右边小于 heights[2]=5 的最近元素的下标为 right=4。矩形的宽就是 `right − left − 1 = 4 − 1 − 1 = 2`，矩形面积为 `h ⋅ (right − left − 1) = 5 ⋅ 2 = 10`。

枚举 i，计算对应的矩形面积，更新答案的最大值。

为什么这样做不会漏掉答案？题目本质是计算高×宽的最大值，高是我们枚举的，所以只要保证宽尽量大，答案就一定能被我们枚举计算到。

代码如下：
```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = size(heights);
        vector<int> left(n);
        stack<int> flag;
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            left[i] = flag.empty() ? -1 : flag.top();
            flag.push(i);
        }

        vector<int> right(n);
        stack<int>().swap(flag);
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            right[i] = flag.empty() ? n : flag.top();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        Deque<Integer> flag = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.isEmpty() && heights[flag.peek()] >= h) {
                flag.pop();
            }
            left[i] = flag.isEmpty() ? -1 : flag.peek();
            flag.push(i);
        }

        int[] right = new int[n];
        flag.clear();
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.isEmpty() && heights[flag.peek()] >= h) {
                flag.pop();
            }
            right[i] = flag.isEmpty() ? n : flag.peek();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
}
```



## Python代码

```Python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n, answer = len(heights), 0
        left, right, flag = [0] * n, [0] * n, []
        for i in range(n) :
            h = heights[i]
            while flag and heights[flag[-1]] >= h :
                flag.pop()
            left[i] = flag[-1] if flag else -1
            flag.append(i)

        flag = []
        for i in range(n - 1, -1, -1) :
            h = heights[i]
            while flag and heights[flag[-1]] >= h :
                flag.pop()
            right[i] = flag[-1] if flag else n
            flag.append(i)

        for i in range(n) :
            answer = answer if answer > heights[i] * (right[i] - left[i] - 1) else heights[i] * (right[i] - left[i] - 1)
        return answer
```



## C++代码

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = size(heights);
        vector<int> left(n);
        stack<int> flag;
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            left[i] = flag.empty() ? -1 : flag.top();
            flag.push(i);
        }

        vector<int> right(n);
        stack<int>().swap(flag);
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            right[i] = flag.empty() ? n : flag.top();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
};
```

![84_柱状图中最大的矩形_C++]()