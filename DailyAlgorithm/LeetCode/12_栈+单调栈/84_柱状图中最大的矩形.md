本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

>标签：栈  |  数组  |  单调栈

# 一、题目描述

## **问题概括**

给定一个长度为 `n` 的非负整数数组 `heights`，其中的每个元素代表一个竖直柱子的高度。这些柱子宽度为 1，并按照数组顺序紧挨着排列。

请你找出并返回由这些柱子所构成图形中，**能够勾勒出的最大矩形的面积**。勾勒出的矩形必须由连续的若干根柱子作为底边，其高度由这些柱子中的**最矮柱子的高度**决定。

矩形的面积计算公式为：`面积 = 最矮柱子的高度 × 所选柱子的数量（宽度）`。

## **示例核心说明**

- 在示例 `heights = [2,1,5,6,2,3]` 中，最大的矩形面积是 `10`。它对应一个高度为 `2`、宽度为 `5` 的矩形。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/84_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E7%A4%BA%E4%BE%8B1.jpg)

- 在示例 `heights = [2,4]` 中，最大矩形面积为 `4`。

    ![img](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/84_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E7%A4%BA%E4%BE%8B2.jpg)

## **数据范围**

- `1 <= heights.length <= 10^5`
- `0 <= heights[i] <= 10^4`



# 二、解题思路\解题过程

以下思路转载至灵神的思路——[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/2695467/dan-diao-zhan-fu-ti-dan-pythonjavacgojsr-89s7/)，具体思路如下所示：

![84_柱状图中最大的矩形_示例1](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/84_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E7%A4%BA%E4%BE%8B1.jpg)

首先，面积最大矩形的高度一定是 heights 中的元素。这可以用反证法证明：假如高度不在 heights 中，比如 4，那我们可以增加高度直到触及某根柱子的顶部，比如增加到 5，由于矩形底边长不变，高度增加，我们得到了面积更大的矩形，矛盾，所以面积最大矩形的高度一定是 heights 中的元素。

枚举每个 h=heights[i]，作为矩形的高。那么矩形的宽最大是多少？我们需要知道：

- 在 i 左侧的小于 h 的最近元素的下标 left，如果不存在则为 −1。求出了 left，那么 left+1 就是矩形最左边那根柱子。如果 left=−1，那么加一后是 0，就是整个 heights 最左边的柱子。
- 在 i 右侧的小于 h 的最近元素的下标 right，如果不存在则为 n。求出了 right，那么 right−1 就是矩形最右边那根柱子。如果 right=n，那么减一后是 n−1，就是整个 heights 最右边的柱子。

比如上图所示，选择 i=2 这个柱子作为矩形的高，那么左边小于 heights[2]=5 的最近元素的下标为 left=1，右边小于 heights[2]=5 的最近元素的下标为 right=4。矩形的宽就是 `right − left − 1 = 4 − 1 − 1 = 2`，矩形面积为 `h ⋅ (right − left − 1) = 5 ⋅ 2 = 10`。

枚举 i，计算对应的矩形面积，更新答案的最大值。

为什么这样做不会漏掉答案？题目本质是计算高×宽的最大值，高是我们枚举的，所以只要保证宽尽量大，答案就一定能被我们枚举计算到。

代码如下：
```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = size(heights);
        vector<int> left(n);
        stack<int> flag;
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            left[i] = flag.empty() ? -1 : flag.top();
            flag.push(i);
        }

        vector<int> right(n);
        stack<int>().swap(flag);
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            right[i] = flag.empty() ? n : flag.top();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
};
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        Deque<Integer> flag = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.isEmpty() && heights[flag.peek()] >= h) {
                flag.pop();
            }
            left[i] = flag.isEmpty() ? -1 : flag.peek();
            flag.push(i);
        }

        int[] right = new int[n];
        flag.clear();
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.isEmpty() && heights[flag.peek()] >= h) {
                flag.pop();
            }
            right[i] = flag.isEmpty() ? n : flag.peek();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
}
```



## Python代码

```Python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n, answer = len(heights), 0
        left, right, flag = [0] * n, [0] * n, []
        for i in range(n) :
            h = heights[i]
            while flag and heights[flag[-1]] >= h :
                flag.pop()
            left[i] = flag[-1] if flag else -1
            flag.append(i)

        flag = []
        for i in range(n - 1, -1, -1) :
            h = heights[i]
            while flag and heights[flag[-1]] >= h :
                flag.pop()
            right[i] = flag[-1] if flag else n
            flag.append(i)

        for i in range(n) :
            answer = answer if answer > heights[i] * (right[i] - left[i] - 1) else heights[i] * (right[i] - left[i] - 1)
        return answer
```



## C++代码

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = size(heights);
        vector<int> left(n);
        stack<int> flag;
        for (int i = 0; i < n; i++) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            left[i] = flag.empty() ? -1 : flag.top();
            flag.push(i);
        }

        vector<int> right(n);
        stack<int>().swap(flag);
        for (int i = n - 1; i >= 0; i--) {
            int h = heights[i];
            while (!flag.empty() && heights[flag.top()] >= h) {
                flag.pop();
            }
            right[i] = flag.empty() ? n : flag.top();
            flag.push(i);
        }

        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = answer > heights[i] * (right[i] - left[i] - 1) ? answer : heights[i] * (right[i] - left[i] - 1);
        }
        return answer;
    }
};
```

![84_柱状图中最大的矩形_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/84_%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_C++.png)