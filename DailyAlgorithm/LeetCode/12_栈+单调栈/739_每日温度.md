[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)

>标签：栈  |  数组  |  单调栈

# 一、题目描述

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`



# 二、解题思路\解题过程

这道题是一道中等难度的题目，可以采用单调栈来进行求解（以下思路参考了灵神的思路求解（转载）——[单调栈【基础算法精讲 26】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=12bf3ca6137fdd845e5fdc4e85bccc36)）：
#### 从右往左遍历

具体思路参考如下图片：
![739_每日温度_从右往左遍历]()

代码如下(代码中有对应的解释和说明！)：
```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        for i in range(n - 1, -1, -1) :
            tmp = temperatures[i]
            # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
            while flag and tmp >= temperatures[flag[-1]] :
                flag.pop()
            # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
            if flag :
                answer[i] = flag[-1] - i
            flag.append(i)
        return answer
```

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = size(temperatures);
        vector<int> answer(n);
        // 定义一个存储int的栈（实际是 Integer）
        stack<int> flag;
        for (int i = n - 1; i >= 0; i--) {
            int tmp = temperatures[i];
            // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
            while (!flag.empty() && tmp >= temperatures[flag.top()]) {
                flag.pop();
            }
            // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
            if (!flag.empty()) {
                answer[i] = flag.top() - i;
            }
            flag.push(i);
        }
        return answer;
    }
};
```

#### 从左往右遍历

灵神原话：

><mark>及时去掉无用数据，保证栈中数据有序！</mark>
>
>注：“无用”：后续遍历中不会在使用到的数据！

![739_每日温度_从左往右遍历]()

从左往后遍历的代码如下，通过代码即可理解到对应的思路和想法了，这里就不在多说了，直接上代码，如下：
【注】：这里会用到`enumerate`(可以去查看这一天[[Study_26_01_10]]笔记中的`enumerate`所记录的知识点！)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        # for i in range(n - 1, -1, -1) :
        #     tmp = temperatures[i]
        #     # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        #     while flag and tmp >= temperatures[flag[-1]] :
        #         flag.pop()
        #     # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        #     if flag :
        #         answer[i] = flag[-1] - i
        #     flag.append(i)

        # 从左往右遍历
        for i, tmp in enumerate(temperatures) :
            while flag and tmp > temperatures[flag[-1]] :
	            # 只要出现了下标i的温度大于栈顶j的温度，那么就说明下标i的温度就是栈顶j温度后出现的下一个更高温度，这个时候就可以弹出栈顶，并更新answer数组中对应的值了！
                j = flag.pop()
                answer[j] = i - j
            flag.append(i)
        return answer
```

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        // 定义一个存储int的栈（实际是 Integer）
        Deque<Integer> flag = new ArrayDeque<>();
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.isEmpty() && tmp >= temperatures[flag.peek()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.isEmpty()) {
        //         answer[i] = flag.peek() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.isEmpty() && tmp > temperatures[flag.peek()]){
                int j = flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
}
```



# 三、代码演示

## Java代码

```Java代码
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        // 定义一个存储int的栈（实际是 Integer）
        Deque<Integer> flag = new ArrayDeque<>();
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.isEmpty() && tmp >= temperatures[flag.peek()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.isEmpty()) {
        //         answer[i] = flag.peek() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.isEmpty() && tmp > temperatures[flag.peek()]){
                int j = flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
}
```



## Python代码

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        # for i in range(n - 1, -1, -1) :
        #     tmp = temperatures[i]
        #     # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        #     while flag and tmp >= temperatures[flag[-1]] :
        #         flag.pop()
        #     # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        #     if flag :
        #         answer[i] = flag[-1] - i
        #     flag.append(i)

        # 从左往右遍历
        for i, tmp in enumerate(temperatures) :
            while flag and tmp > temperatures[flag[-1]] :
                j = flag.pop()
                answer[j] = i - j
            flag.append(i)
        return answer
```



## C++代码

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = size(temperatures);
        vector<int> answer(n);
        // 定义一个存储int的栈（实际是 Integer）
        stack<int> flag;
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.empty() && tmp >= temperatures[flag.top()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.empty()) {
        //         answer[i] = flag.top() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.empty() && tmp > temperatures[flag.top()]){
                int j = flag.top();
                flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
};
```

