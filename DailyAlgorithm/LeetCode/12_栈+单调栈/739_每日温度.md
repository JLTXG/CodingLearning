本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)

>标签：栈  |  数组  |  单调栈

# 一、题目描述

## **问题概括**

给定一个整数数组 `temperatures`，其中 `temperatures[i]` 表示第 `i` 天的温度。你需要为每一天 `i` 计算：在未来的日子里，需要等待多少天（即索引差）才能遇到一个比当天温度更高的温度。将结果存入数组 `answer` 并返回。如果未来没有温度比当天更高，则在 `answer[i]` 中填入 `0`。

## **示例核心说明**

- 输入 `temperatures = [73,74,75,71,69,72,76,73]`
    - 第 0 天 (73°)，下一天温度更高 (74°)，所以 `answer[0] = 1`
    - 第 2 天 (75°)，需要等待 4 天到第 6 天 (76°)，所以 `answer[2] = 4`
    - 最后两天未来没有更高温度，结果为 `0`
    - 最终输出 `[1,1,4,2,1,1,0,0]`

## **数据范围**

- 数组长度在 `1` 到 `10^5` 之间
- 每天的温度在 `30` 到 `100` 之间



# 二、解题思路\解题过程

这道题是一道中等难度的题目，可以采用单调栈来进行求解（以下思路参考了灵神的思路求解（转载）——[单调栈【基础算法精讲 26】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=12bf3ca6137fdd845e5fdc4e85bccc36)）：
## 从右往左遍历

具体思路参考如下图片：

![739_每日温度_从右往左遍历](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6_%E4%BB%8E%E5%8F%B3%E5%BE%80%E5%B7%A6%E9%81%8D%E5%8E%86.jpg)

代码如下(代码中有对应的解释和说明！)：

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        for i in range(n - 1, -1, -1) :
            tmp = temperatures[i]
            # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
            while flag and tmp >= temperatures[flag[-1]] :
                flag.pop()
            # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
            if flag :
                answer[i] = flag[-1] - i
            flag.append(i)
        return answer
```

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = size(temperatures);
        vector<int> answer(n);
        // 定义一个存储int的栈（实际是 Integer）
        stack<int> flag;
        for (int i = n - 1; i >= 0; i--) {
            int tmp = temperatures[i];
            // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
            while (!flag.empty() && tmp >= temperatures[flag.top()]) {
                flag.pop();
            }
            // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
            if (!flag.empty()) {
                answer[i] = flag.top() - i;
            }
            flag.push(i);
        }
        return answer;
    }
};
```

## 从左往右遍历

灵神原话：

><mark>及时去掉无用数据，保证栈中数据有序！</mark>
>
>注：“无用”：后续遍历中不会在使用到的数据！

![739_每日温度_从左往右遍历](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6_%E4%BB%8E%E5%B7%A6%E5%BE%80%E5%8F%B3%E9%81%8D%E5%8E%86.jpg)

从左往后遍历的代码如下，通过代码即可理解到对应的思路和想法了，这里就不在多说了，直接上代码，如下：
【注】：这里会用到`enumerate`(可以去查看这一天[[Study_26_01_10]]笔记中的`enumerate`所记录的知识点！)

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        # for i in range(n - 1, -1, -1) :
        #     tmp = temperatures[i]
        #     # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        #     while flag and tmp >= temperatures[flag[-1]] :
        #         flag.pop()
        #     # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        #     if flag :
        #         answer[i] = flag[-1] - i
        #     flag.append(i)

        # 从左往右遍历
        for i, tmp in enumerate(temperatures) :
            while flag and tmp > temperatures[flag[-1]] :
	            # 只要出现了下标i的温度大于栈顶j的温度，那么就说明下标i的温度就是栈顶j温度后出现的下一个更高温度，这个时候就可以弹出栈顶，并更新answer数组中对应的值了！
                j = flag.pop()
                answer[j] = i - j
            flag.append(i)
        return answer
```

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        // 定义一个存储int的栈（实际是 Integer）
        Deque<Integer> flag = new ArrayDeque<>();
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.isEmpty() && tmp >= temperatures[flag.peek()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.isEmpty()) {
        //         answer[i] = flag.peek() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.isEmpty() && tmp > temperatures[flag.peek()]){
                int j = flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
}
```



# 三、代码演示

## Java代码

```Java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        // 定义一个存储int的栈（实际是 Integer）
        Deque<Integer> flag = new ArrayDeque<>();
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.isEmpty() && tmp >= temperatures[flag.peek()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.isEmpty()) {
        //         answer[i] = flag.peek() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.isEmpty() && tmp > temperatures[flag.peek()]){
                int j = flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
}
```



## Python代码

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        answer, flag = [0] * n, []
        # 从右往左遍历
        # for i in range(n - 1, -1, -1) :
        #     tmp = temperatures[i]
        #     # 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        #     while flag and tmp >= temperatures[flag[-1]] :
        #         flag.pop()
        #     # 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        #     if flag :
        #         answer[i] = flag[-1] - i
        #     flag.append(i)

        # 从左往右遍历
        for i, tmp in enumerate(temperatures) :
            while flag and tmp > temperatures[flag[-1]] :
                j = flag.pop()
                answer[j] = i - j
            flag.append(i)
        return answer
```

![739_每日温度_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/12_%E6%A0%88+%E5%8D%95%E8%B0%83%E6%A0%88/Images/739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6_Python.png)

## C++代码

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = size(temperatures);
        vector<int> answer(n);
        // 定义一个存储int的栈（实际是 Integer）
        stack<int> flag;
        // 从右往左遍历
        // for (int i = n - 1; i >= 0; i--) {
        //     int tmp = temperatures[i];
        //     // 剔除哪些数值比较低(或者与tmp值相等)的“山峰”，当然，前提是flag数组不为空
        //     while (!flag.empty() && tmp >= temperatures[flag.top()]) {
        //         flag.pop();
        //     }
        //     // 上述while已经剔除了数值小的或者相等的山峰，如果flag此时还不为空，那么就可以得到——当前值的下一个更大的值出现的下标了，这个时候，只要将两个下标相减即可得到当前值对应的答案值了
        //     if (!flag.empty()) {
        //         answer[i] = flag.top() - i;
        //     }
        //     flag.push(i);
        // }

        // 从左往右遍历
        for(int i = 0; i < n; i++){
            int tmp = temperatures[i];
            while(!flag.empty() && tmp > temperatures[flag.top()]){
                int j = flag.top();
                flag.pop();
                answer[j] = i - j;
            }
            flag.push(i);
        }
        return answer;
    }
};
```

