[1390. 四因数 - 力扣（LeetCode）](https://leetcode.cn/problems/four-divisors/description/?envType=daily-question&envId=2026-01-04)

>标签：数组  |  数学

# 一、题目描述

给你一个整数数组 `nums`，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 `0` 。

 

**示例 1：**

```
输入：nums = [21,4,7]
输出：32
解释：
21 有 4 个因数：1, 3, 7, 21
4 有 3 个因数：1, 2, 4
7 有 2 个因数：1, 7
答案仅为 21 的所有因数的和。
```

**示例 2:**

```
输入: nums = [21,21]
输出: 64
```

**示例 3:**

```
输入: nums = [1,2,3,4,5]
输出: 0
```

 

**提示：**

- `1 <= nums.length <= 104`
- `1 <= nums[i] <= 105`



# 二、解题思路\解题过程

这道题一眼看去是一道数学题，先不管三七二十一，直接采用暴力求解的方法，代码如下，结果一提交，可想而知，超时了！
```java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int sum = 0, count = 2, n = nums.length, nums_sum = 0;
        for(int i = 0; i < n; i++){
            nums_sum += (1 + nums[i]);
            for(int j = 2; j < nums[i]; j++){
                if(nums[i] % j == 0){
                    count++;
                    nums_sum += j;
                }
            }
            if(count == 4){
                sum += nums_sum;
            }
            nums_sum = 0;
            count = 2;
        }
        return sum;
    }
}
```
然后，我又想了一下，之前的代码是需要找出除了“1和这个数本身”以外的两个因数，也就是说其实是把四个因数全部找出来了，这个想法一共通过了15个测试用例，总共18个测试用例，然后我想了一下，“1和这个数本身”已经是我们已经知道的其中两个因数了，只要我在找到第三个，第四个就可以通过相除来得到，那么这样，第二层的循环只要小于`Math.sqrt(nums[i])`即可，代码如下，但是很可惜，这样提交代码只有通过例如17个测试用例，只剩下最后一个测试用例没有通过了！
```java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int sum = 0, count = 1, n = nums.length, nums_sum = 0;
        for(int i = 0; i < n; i++){
            nums_sum += (1 + nums[i]);
            for(int j = 2; j < Math.sqrt(nums[i]); j++){
                if(nums[i] % j == 0){
                    count++;
                    nums_sum += j + nums[i] / j;
                }
            }
            if(count == 2){
                sum += nums_sum;
            }
            nums_sum = 0;
            count = 1;
        }
        return sum;
    }
}
```
但是，最后一个测试用例没通过不是因为“超时”，而是因为“解答错误”！经过一系列的思考，终究找到上述修改后的代码的Bug了：
- Bug1：没有考虑到“完全平方数”，完全平方数只能算一个因数；
- Bug2：精度问题，`Math.sqrt(nums[i])`是`double`类型的，在`for`循环遍历(`int`)中，可能存在`int`与`double`之间的浮点精度问题，导致多循环一次或者少循环一次，后续如果需要的话，最好写成`i * i <= nums[i]`，在循环中最好不要采用`Math.sqrt()`！

另外，如果统计的`count`超过了题目要求的因数的个数，也可以提前跳出本次循环，减少时间开销，最终代码如下：

```java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int sum = 0;
        for(int m : nums){
            int nums_sum = 1 + m, count = 2;
            for(int i = 2; i * i <= m; i++){
                if(m % i == 0){
                    //  完全平方数，也就是说两个一样的数相乘等于m，所以只加一个因数
                    if(i * i == m){
                        nums_sum += i;
                        count += 1;
                    } else { //  不是完全平方数，则加上对应的两个因数
                        nums_sum += i + m / i;
                        count += 2;
                    }
                    //  如果count大于4了，就可以将flag置为false，也可以跳出本轮循环，节省时间开销
                    if(count > 4){
                        break;
                    }
                }
            }
            if(count == 4){
                sum += nums_sum;
            }
        }
        return sum;
    }
}
```
我上述的代码是用的暴力的思想，我在“题解”中看到了一个“枚举”的思想，真的是非常不错！

>直接从“因子”角度出发，枚举每一个数的因子，在加起来，并计数每个数有多少个因子，这样在题目给出对应的数组之后，只需要判断我们枚举好的每个数的因子数是否符合要求即可，如果符合，就将对应的因子和加起来即可！

代码如下：

```java
class Solution {
    private static final int numsMax = 100001;
    private static final int[] nums_nums = new int[numsMax];
    private static final int[] nums_sums = new int[numsMax];
    private static boolean init = false;

    //  初始化
    public Solution() {
        if (init) {
            return;
        }
        init = true;

        //  核心
        for(int i = 1; i < numsMax; i++){
            for(int j = i; j < numsMax; j += i){
                nums_nums[j]++;  //  计算每个数j的因子个数
                nums_sums[j] += i;  //  将每个数j的因子相加
            }
        }
    }

    public int sumFourDivisors(int[] nums) {
        int totalSum = 0;
        for(int n : nums){
            if(nums_nums[n] == 4){
                totalSum += nums_sums[n];
            }
        }
        return totalSum;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int sum = 0;
        for(int m : nums){
            int nums_sum = 1 + m, count = 2;
            for(int i = 2; i * i <= m; i++){
                if(m % i == 0){
                    //  完全平方数，也就是说两个一样的数相乘等于m，所以只加一个因数
                    if(i * i == m){
                        nums_sum += i;
                        count += 1;
                    } else { //  不是完全平方数，则加上对应的两个因数
                        nums_sum += i + m / i;
                        count += 2;
                    }
                    //  如果count大于4了，就可以将flag置为false，也可以跳出本轮循环，节省时间开销
                    if(count > 4){
                        break;
                    }
                }
            }
            if(count == 4){
                sum += nums_sum;
            }
        }
        return sum;
    }
}
```

![1390_四因数_Java_解法1](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E6%95%B0%E5%AD%A6/Images/1390_%E5%9B%9B%E5%9B%A0%E6%95%B0_Java_%E8%A7%A3%E6%B3%951.png)

```java
class Solution {
    private static final int numsMax = 100001;
    private static final int[] nums_nums = new int[numsMax];
    private static final int[] nums_sums = new int[numsMax];
    private static boolean init = false;

    //  初始化
    public Solution() {
        if (init) {
            return;
        }
        init = true;

        //  核心
        for(int i = 1; i < numsMax; i++){
            for(int j = i; j < numsMax; j += i){
                nums_nums[j]++;  //  计算每个数j的因子个数
                nums_sums[j] += i;  //  将每个数j的因子相加
            }
        }
    }

    public int sumFourDivisors(int[] nums) {
        int totalSum = 0;
        for(int n : nums){
            if(nums_nums[n] == 4){
                totalSum += nums_sums[n];
            }
        }
        return totalSum;
    }
}
```

![1390_四因数_Java_解法2](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E6%95%B0%E5%AD%A6/Images/1390_%E5%9B%9B%E5%9B%A0%E6%95%B0_Java_%E8%A7%A3%E6%B3%952.png)

## Python代码

```python
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        total_sum = 0
        for i in nums:
            nums_sum, nums_count, j = 1 + i, 2, 2
            while j * j <= i :
                if i % j == 0 :
                    if j * j == i :
                        nums_sum += j
                        nums_count += 1
                    else :
                        nums_sum += j + i // j
                        nums_count += 2
                if nums_count > 4 :
                    break
                j += 1
            if nums_count == 4 :
                total_sum += nums_sum
        return total_sum
```



## C++代码

```C++
class Solution {
public:
    int sumFourDivisors(vector<int>& nums) {
        int sum = 0;
        for(int m : nums){
            int nums_sum = 1 + m, count = 2;
            for(int i = 2; i * i <= m; i++){
                if(m % i == 0){
                    //  完全平方数，也就是说两个一样的数相乘等于m，所以只加一个因数
                    if(i * i == m){
                        nums_sum += i;
                        count += 1;
                    } else { //  不是完全平方数，则加上对应的两个因数
                        nums_sum += i + m / i;
                        count += 2;
                    }
                    //  如果count大于4了，就可以将flag置为false，也可以跳出本轮循环，节省时间开销
                    if(count > 4){
                        break;
                    }
                }
            }
            if(count == 4){
                sum += nums_sum;
            }
        }
        return sum;
    }
};
```

