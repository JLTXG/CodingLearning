[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/description/?envType=study-plan-v2&envId=primers-list)

>标签：位运算  |  递归  |  数学

# 一、题目描述

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

 

**示例 1：**

```
输入：n = 1
输出：true
解释：20 = 1
```

**示例 2：**

```
输入：n = 16
输出：true
解释：24 = 16
```

**示例 3：**

```
输入：n = 3
输出：false
```

 

**提示：**

- `-231 <= n <= 231 - 1`

 

**进阶：**你能够不使用循环/递归解决此问题吗？



# 二、解题思路\解题过程

这也是一道简单的数学题目，这里提供两种解题思路：
#### 第一种：模拟（暴力求解）

根据题意一步步模拟，只需要保证代码中更新的数据在不超过对应的数值范围即可，具体代码如下所示：
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
};
```
#### 第二种：位运算

参考灵神的题解——[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/solutions/2973442/yan-ge-zheng-ming-yi-xing-xie-fa-pythonj-h04o/?envType=study-plan-v2&envId=primers-list)，知识合集——[分享｜从集合论到位运算，常见位运算技巧分类总结！ - 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)！

总得来说，灵神的位运算思路归结如下：
- 如果 `n>0`，可以用 `n&(n−1)=0` 判断。若成立，则 `n` 是 `2` 的幂；若不成立，则 `n` 不是 `2` 的幂。
- 如果 `n≤0`，`n` 不是 `2` 的幂。

> 注：n&(n−1) 相当于去掉 n 二进制的最低位，可以用这个技巧枚举 n 中的比特 1。

代码如下：
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
};
```



# 三、代码演示

## Java代码

```Java
// 模拟（暴力求解）
class Solution {
    public boolean isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
}

// 位运算
class Solution {
    public boolean isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
}
```



## Python代码

```Python
# 模拟（暴力求解）
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1 :
            return True
        flag = 1
        for i in range(1, 32):
            flag *= 2
            if flag == n :
                return True
            elif flag > n :
                return False
        return False
    
# 位运算
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
```



## C++代码

```C++
// 模拟（暴力求解）
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if ( n == 1) {
            return true;
        }
        long flag = 1;
        for (int i = 1; i <= 31; i++) {
            flag *= 2;
            if (flag == n) {
                return true;
            } else if (flag > n) {
                return false;
            }
        }
        return false;
    }
};

// 位运算
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return (n > 0) && (n & (n - 1)) == 0;
    }
};
```

![231_2 的幂_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E6%95%B0%E5%AD%A6/Images/231_2%20%E7%9A%84%E5%B9%82_C++.png)