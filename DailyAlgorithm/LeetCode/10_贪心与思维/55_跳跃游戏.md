本文题解基于以下原题整理，题意经本人重新表述，解题思路与代码均为原创或转载，仅用于个人学习与交流，完整题目请务必查阅官方原题链接：[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/?envType=problem-list-v2&envId=greedy)

>标签：贪心  |  数组  |  动态规划

# 一、题目描述

## **问题概括**

你面临一个非负整数数组 `nums`，你的起始位置是数组的第一个元素处（下标 `0`）。数组中的每个元素 `nums[i]` 表示从该位置能够**向右跳跃的最大步数**。例如，如果 `nums[i] = 3`，那么你可以从下标 `i` 跳转到下标 `i+1`、`i+2` 或 `i+3`。

你的目标是判断是否能够通过一系列的跳跃，从起始位置到达数组的最后一个下标（即 `nums` 的末尾）。如果能够到达，则返回 `true`；否则，返回 `false`。

## **示例说明**

- **示例1**：数组为 `[2,3,1,1,4]`。一种可行的跳跃路径是：从下标 `0` 跳 `1` 步到下标 `1`，然后从下标 `1` 跳 `3` 步直接到达最后一个下标 `4`。因此，返回 `true`。
- **示例2**：数组为 `[3,2,1,0,4]`。无论从下标 `0` 如何跳跃，最终都会停留在下标 `3` 处，因为该位置的跳跃步数为 `0`，无法继续前进。因此，无法到达最后一个下标，返回 `false`。

## **数据范围**

- 数组的长度在 `1` 到 `10^4` 之间。
- 数组中的每个元素值在 `0` 到 `10^5` 之间。



# 二、解题思路\解题过程

这道题目是上一道题目的简单版本，只需要判断是否能不能跳转到终点即可，不需要记录跳转了多少次！
我们需要定义两个变量，一个`cover`表明从一开始往后遍历所能覆盖到的最大的下标值，一个`n`用以记录题目给的数组的长度。最开始，如果题目给的数组的长度为`1`，那么就可以直接返回`true`了，如果不为`1`，我们就需要去遍历整个数组，但是，需要注意的是，数组截止遍历的条件不在是`i < n`，而是`i <= cover`，这样我们才循环里设置判断`if(cover >= n - 1)`，如果`cover >= n - 1`，即可返回`true`，否则就继续循环下去，直到跳出循环，跳出循环之后即可返回`false`，因为`cover`是我们可以覆盖到的最大下标值，既然在循环里面没有达到`cover >= n - 1`的情况，那么就说明无法到达终点！
但是，这里需要有一个注意的地方，`if(cover >= n - 1)`的判断得在“更新`cover`值”的前面，因为`cover`的值可能大于`n - 1`，所以，当`cover`在大于`n - 1`的情况下，必须先进入`if`判断，否则后续更新`cover`的值的时候，会显示“超出数组序列下标”！
代码如下：

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int cover = 0, n = nums.length;
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
}
```



# 三、代码演示

## Java代码

```java
class Solution {
    public boolean canJump(int[] nums) {
        int cover = 0, n = nums.length;
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
}
```



## Python代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        i, cover, n = 0, 0, len(nums)
        if n == 1 :
            return True
        while i <= cover :
            if cover >= n - 1:
                return True
            cover = cover if cover > (i + nums[i]) else (i + nums[i])
            i += 1
        return False
```

注意，如果要用Python来写这道题目的话，千万要注意`range`的用法！
> **`range()` 在循环开始时就确定了迭代次数，不会动态变化！**
> 需要动态边界时，请用 `while`。

![55_跳跃游戏_Python](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%80%9D%E7%BB%B4/Images/55_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_Python.png)

## C++代码

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0, n = size(nums);
        if(n == 1){
            return true;
        }
        for(int i = 0; i <= cover; i++){
            if(cover >= n - 1){
                return true;
            }
            cover = cover > (i + nums[i]) ? cover : (i + nums[i]);
        }
        return false;
    }
};
```

![55_跳跃游戏_C++](https://gitee.com/lei-weijun/CodingLearning/raw/main/DailyAlgorithm/LeetCode/10_%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%80%9D%E7%BB%B4/Images/55_%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_C++.png)